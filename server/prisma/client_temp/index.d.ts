
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Cto
 * 
 */
export type Cto = $Result.DefaultSelection<Prisma.$CtoPayload>
/**
 * Model Pop
 * 
 */
export type Pop = $Result.DefaultSelection<Prisma.$PopPayload>
/**
 * Model Cable
 * 
 */
export type Cable = $Result.DefaultSelection<Prisma.$CablePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model CatalogSplitter
 * 
 */
export type CatalogSplitter = $Result.DefaultSelection<Prisma.$CatalogSplitterPayload>
/**
 * Model TemplateSplitter
 * 
 */
export type TemplateSplitter = $Result.DefaultSelection<Prisma.$TemplateSplitterPayload>
/**
 * Model CatalogCable
 * 
 */
export type CatalogCable = $Result.DefaultSelection<Prisma.$CatalogCablePayload>
/**
 * Model TemplateCable
 * 
 */
export type TemplateCable = $Result.DefaultSelection<Prisma.$TemplateCablePayload>
/**
 * Model CatalogBox
 * 
 */
export type CatalogBox = $Result.DefaultSelection<Prisma.$CatalogBoxPayload>
/**
 * Model TemplateBox
 * 
 */
export type TemplateBox = $Result.DefaultSelection<Prisma.$TemplateBoxPayload>
/**
 * Model CatalogPole
 * 
 */
export type CatalogPole = $Result.DefaultSelection<Prisma.$CatalogPolePayload>
/**
 * Model TemplatePole
 * 
 */
export type TemplatePole = $Result.DefaultSelection<Prisma.$TemplatePolePayload>
/**
 * Model Pole
 * 
 */
export type Pole = $Result.DefaultSelection<Prisma.$PolePayload>
/**
 * Model CatalogFusion
 * 
 */
export type CatalogFusion = $Result.DefaultSelection<Prisma.$CatalogFusionPayload>
/**
 * Model TemplateFusion
 * 
 */
export type TemplateFusion = $Result.DefaultSelection<Prisma.$TemplateFusionPayload>
/**
 * Model CatalogOLT
 * 
 */
export type CatalogOLT = $Result.DefaultSelection<Prisma.$CatalogOLTPayload>
/**
 * Model TemplateOLT
 * 
 */
export type TemplateOLT = $Result.DefaultSelection<Prisma.$TemplateOLTPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const EquipmentStatus: {
  PLANNED: 'PLANNED',
  NOT_DEPLOYED: 'NOT_DEPLOYED',
  DEPLOYED: 'DEPLOYED',
  CERTIFIED: 'CERTIFIED',
  ANALYSING: 'ANALYSING',
  LICENSED: 'LICENSED'
};

export type EquipmentStatus = (typeof EquipmentStatus)[keyof typeof EquipmentStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type EquipmentStatus = $Enums.EquipmentStatus

export const EquipmentStatus: typeof $Enums.EquipmentStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.cto`: Exposes CRUD operations for the **Cto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ctos
    * const ctos = await prisma.cto.findMany()
    * ```
    */
  get cto(): Prisma.CtoDelegate<ExtArgs>;

  /**
   * `prisma.pop`: Exposes CRUD operations for the **Pop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pops
    * const pops = await prisma.pop.findMany()
    * ```
    */
  get pop(): Prisma.PopDelegate<ExtArgs>;

  /**
   * `prisma.cable`: Exposes CRUD operations for the **Cable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cables
    * const cables = await prisma.cable.findMany()
    * ```
    */
  get cable(): Prisma.CableDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.catalogSplitter`: Exposes CRUD operations for the **CatalogSplitter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogSplitters
    * const catalogSplitters = await prisma.catalogSplitter.findMany()
    * ```
    */
  get catalogSplitter(): Prisma.CatalogSplitterDelegate<ExtArgs>;

  /**
   * `prisma.templateSplitter`: Exposes CRUD operations for the **TemplateSplitter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateSplitters
    * const templateSplitters = await prisma.templateSplitter.findMany()
    * ```
    */
  get templateSplitter(): Prisma.TemplateSplitterDelegate<ExtArgs>;

  /**
   * `prisma.catalogCable`: Exposes CRUD operations for the **CatalogCable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogCables
    * const catalogCables = await prisma.catalogCable.findMany()
    * ```
    */
  get catalogCable(): Prisma.CatalogCableDelegate<ExtArgs>;

  /**
   * `prisma.templateCable`: Exposes CRUD operations for the **TemplateCable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateCables
    * const templateCables = await prisma.templateCable.findMany()
    * ```
    */
  get templateCable(): Prisma.TemplateCableDelegate<ExtArgs>;

  /**
   * `prisma.catalogBox`: Exposes CRUD operations for the **CatalogBox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogBoxes
    * const catalogBoxes = await prisma.catalogBox.findMany()
    * ```
    */
  get catalogBox(): Prisma.CatalogBoxDelegate<ExtArgs>;

  /**
   * `prisma.templateBox`: Exposes CRUD operations for the **TemplateBox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateBoxes
    * const templateBoxes = await prisma.templateBox.findMany()
    * ```
    */
  get templateBox(): Prisma.TemplateBoxDelegate<ExtArgs>;

  /**
   * `prisma.catalogPole`: Exposes CRUD operations for the **CatalogPole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogPoles
    * const catalogPoles = await prisma.catalogPole.findMany()
    * ```
    */
  get catalogPole(): Prisma.CatalogPoleDelegate<ExtArgs>;

  /**
   * `prisma.templatePole`: Exposes CRUD operations for the **TemplatePole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplatePoles
    * const templatePoles = await prisma.templatePole.findMany()
    * ```
    */
  get templatePole(): Prisma.TemplatePoleDelegate<ExtArgs>;

  /**
   * `prisma.pole`: Exposes CRUD operations for the **Pole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Poles
    * const poles = await prisma.pole.findMany()
    * ```
    */
  get pole(): Prisma.PoleDelegate<ExtArgs>;

  /**
   * `prisma.catalogFusion`: Exposes CRUD operations for the **CatalogFusion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogFusions
    * const catalogFusions = await prisma.catalogFusion.findMany()
    * ```
    */
  get catalogFusion(): Prisma.CatalogFusionDelegate<ExtArgs>;

  /**
   * `prisma.templateFusion`: Exposes CRUD operations for the **TemplateFusion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateFusions
    * const templateFusions = await prisma.templateFusion.findMany()
    * ```
    */
  get templateFusion(): Prisma.TemplateFusionDelegate<ExtArgs>;

  /**
   * `prisma.catalogOLT`: Exposes CRUD operations for the **CatalogOLT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogOLTS
    * const catalogOLTS = await prisma.catalogOLT.findMany()
    * ```
    */
  get catalogOLT(): Prisma.CatalogOLTDelegate<ExtArgs>;

  /**
   * `prisma.templateOLT`: Exposes CRUD operations for the **TemplateOLT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateOLTS
    * const templateOLTS = await prisma.templateOLT.findMany()
    * ```
    */
  get templateOLT(): Prisma.TemplateOLTDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Company: 'Company',
    Plan: 'Plan',
    Project: 'Project',
    Cto: 'Cto',
    Pop: 'Pop',
    Cable: 'Cable',
    AuditLog: 'AuditLog',
    CatalogSplitter: 'CatalogSplitter',
    TemplateSplitter: 'TemplateSplitter',
    CatalogCable: 'CatalogCable',
    TemplateCable: 'TemplateCable',
    CatalogBox: 'CatalogBox',
    TemplateBox: 'TemplateBox',
    CatalogPole: 'CatalogPole',
    TemplatePole: 'TemplatePole',
    Pole: 'Pole',
    CatalogFusion: 'CatalogFusion',
    TemplateFusion: 'TemplateFusion',
    CatalogOLT: 'CatalogOLT',
    TemplateOLT: 'TemplateOLT'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "company" | "plan" | "project" | "cto" | "pop" | "cable" | "auditLog" | "catalogSplitter" | "templateSplitter" | "catalogCable" | "templateCable" | "catalogBox" | "templateBox" | "catalogPole" | "templatePole" | "pole" | "catalogFusion" | "templateFusion" | "catalogOLT" | "templateOLT"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Cto: {
        payload: Prisma.$CtoPayload<ExtArgs>
        fields: Prisma.CtoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CtoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CtoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtoPayload>
          }
          findFirst: {
            args: Prisma.CtoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CtoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtoPayload>
          }
          findMany: {
            args: Prisma.CtoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtoPayload>[]
          }
          create: {
            args: Prisma.CtoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtoPayload>
          }
          createMany: {
            args: Prisma.CtoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CtoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtoPayload>[]
          }
          delete: {
            args: Prisma.CtoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtoPayload>
          }
          update: {
            args: Prisma.CtoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtoPayload>
          }
          deleteMany: {
            args: Prisma.CtoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CtoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CtoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtoPayload>
          }
          aggregate: {
            args: Prisma.CtoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCto>
          }
          groupBy: {
            args: Prisma.CtoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CtoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CtoCountArgs<ExtArgs>
            result: $Utils.Optional<CtoCountAggregateOutputType> | number
          }
        }
      }
      Pop: {
        payload: Prisma.$PopPayload<ExtArgs>
        fields: Prisma.PopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopPayload>
          }
          findFirst: {
            args: Prisma.PopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopPayload>
          }
          findMany: {
            args: Prisma.PopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopPayload>[]
          }
          create: {
            args: Prisma.PopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopPayload>
          }
          createMany: {
            args: Prisma.PopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopPayload>[]
          }
          delete: {
            args: Prisma.PopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopPayload>
          }
          update: {
            args: Prisma.PopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopPayload>
          }
          deleteMany: {
            args: Prisma.PopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopPayload>
          }
          aggregate: {
            args: Prisma.PopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePop>
          }
          groupBy: {
            args: Prisma.PopGroupByArgs<ExtArgs>
            result: $Utils.Optional<PopGroupByOutputType>[]
          }
          count: {
            args: Prisma.PopCountArgs<ExtArgs>
            result: $Utils.Optional<PopCountAggregateOutputType> | number
          }
        }
      }
      Cable: {
        payload: Prisma.$CablePayload<ExtArgs>
        fields: Prisma.CableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CablePayload>
          }
          findFirst: {
            args: Prisma.CableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CablePayload>
          }
          findMany: {
            args: Prisma.CableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CablePayload>[]
          }
          create: {
            args: Prisma.CableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CablePayload>
          }
          createMany: {
            args: Prisma.CableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CablePayload>[]
          }
          delete: {
            args: Prisma.CableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CablePayload>
          }
          update: {
            args: Prisma.CableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CablePayload>
          }
          deleteMany: {
            args: Prisma.CableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CablePayload>
          }
          aggregate: {
            args: Prisma.CableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCable>
          }
          groupBy: {
            args: Prisma.CableGroupByArgs<ExtArgs>
            result: $Utils.Optional<CableGroupByOutputType>[]
          }
          count: {
            args: Prisma.CableCountArgs<ExtArgs>
            result: $Utils.Optional<CableCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      CatalogSplitter: {
        payload: Prisma.$CatalogSplitterPayload<ExtArgs>
        fields: Prisma.CatalogSplitterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogSplitterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogSplitterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogSplitterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogSplitterPayload>
          }
          findFirst: {
            args: Prisma.CatalogSplitterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogSplitterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogSplitterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogSplitterPayload>
          }
          findMany: {
            args: Prisma.CatalogSplitterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogSplitterPayload>[]
          }
          create: {
            args: Prisma.CatalogSplitterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogSplitterPayload>
          }
          createMany: {
            args: Prisma.CatalogSplitterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogSplitterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogSplitterPayload>[]
          }
          delete: {
            args: Prisma.CatalogSplitterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogSplitterPayload>
          }
          update: {
            args: Prisma.CatalogSplitterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogSplitterPayload>
          }
          deleteMany: {
            args: Prisma.CatalogSplitterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogSplitterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatalogSplitterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogSplitterPayload>
          }
          aggregate: {
            args: Prisma.CatalogSplitterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogSplitter>
          }
          groupBy: {
            args: Prisma.CatalogSplitterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogSplitterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogSplitterCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogSplitterCountAggregateOutputType> | number
          }
        }
      }
      TemplateSplitter: {
        payload: Prisma.$TemplateSplitterPayload<ExtArgs>
        fields: Prisma.TemplateSplitterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateSplitterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSplitterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateSplitterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSplitterPayload>
          }
          findFirst: {
            args: Prisma.TemplateSplitterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSplitterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateSplitterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSplitterPayload>
          }
          findMany: {
            args: Prisma.TemplateSplitterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSplitterPayload>[]
          }
          create: {
            args: Prisma.TemplateSplitterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSplitterPayload>
          }
          createMany: {
            args: Prisma.TemplateSplitterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateSplitterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSplitterPayload>[]
          }
          delete: {
            args: Prisma.TemplateSplitterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSplitterPayload>
          }
          update: {
            args: Prisma.TemplateSplitterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSplitterPayload>
          }
          deleteMany: {
            args: Prisma.TemplateSplitterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateSplitterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateSplitterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSplitterPayload>
          }
          aggregate: {
            args: Prisma.TemplateSplitterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateSplitter>
          }
          groupBy: {
            args: Prisma.TemplateSplitterGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateSplitterGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateSplitterCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateSplitterCountAggregateOutputType> | number
          }
        }
      }
      CatalogCable: {
        payload: Prisma.$CatalogCablePayload<ExtArgs>
        fields: Prisma.CatalogCableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogCableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogCablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogCableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogCablePayload>
          }
          findFirst: {
            args: Prisma.CatalogCableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogCablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogCableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogCablePayload>
          }
          findMany: {
            args: Prisma.CatalogCableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogCablePayload>[]
          }
          create: {
            args: Prisma.CatalogCableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogCablePayload>
          }
          createMany: {
            args: Prisma.CatalogCableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogCableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogCablePayload>[]
          }
          delete: {
            args: Prisma.CatalogCableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogCablePayload>
          }
          update: {
            args: Prisma.CatalogCableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogCablePayload>
          }
          deleteMany: {
            args: Prisma.CatalogCableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogCableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatalogCableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogCablePayload>
          }
          aggregate: {
            args: Prisma.CatalogCableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogCable>
          }
          groupBy: {
            args: Prisma.CatalogCableGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogCableGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogCableCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogCableCountAggregateOutputType> | number
          }
        }
      }
      TemplateCable: {
        payload: Prisma.$TemplateCablePayload<ExtArgs>
        fields: Prisma.TemplateCableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateCableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateCablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateCableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateCablePayload>
          }
          findFirst: {
            args: Prisma.TemplateCableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateCablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateCableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateCablePayload>
          }
          findMany: {
            args: Prisma.TemplateCableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateCablePayload>[]
          }
          create: {
            args: Prisma.TemplateCableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateCablePayload>
          }
          createMany: {
            args: Prisma.TemplateCableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateCableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateCablePayload>[]
          }
          delete: {
            args: Prisma.TemplateCableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateCablePayload>
          }
          update: {
            args: Prisma.TemplateCableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateCablePayload>
          }
          deleteMany: {
            args: Prisma.TemplateCableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateCableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateCableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateCablePayload>
          }
          aggregate: {
            args: Prisma.TemplateCableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateCable>
          }
          groupBy: {
            args: Prisma.TemplateCableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateCableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateCableCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateCableCountAggregateOutputType> | number
          }
        }
      }
      CatalogBox: {
        payload: Prisma.$CatalogBoxPayload<ExtArgs>
        fields: Prisma.CatalogBoxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogBoxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogBoxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogBoxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogBoxPayload>
          }
          findFirst: {
            args: Prisma.CatalogBoxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogBoxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogBoxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogBoxPayload>
          }
          findMany: {
            args: Prisma.CatalogBoxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogBoxPayload>[]
          }
          create: {
            args: Prisma.CatalogBoxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogBoxPayload>
          }
          createMany: {
            args: Prisma.CatalogBoxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogBoxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogBoxPayload>[]
          }
          delete: {
            args: Prisma.CatalogBoxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogBoxPayload>
          }
          update: {
            args: Prisma.CatalogBoxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogBoxPayload>
          }
          deleteMany: {
            args: Prisma.CatalogBoxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogBoxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatalogBoxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogBoxPayload>
          }
          aggregate: {
            args: Prisma.CatalogBoxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogBox>
          }
          groupBy: {
            args: Prisma.CatalogBoxGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogBoxGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogBoxCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogBoxCountAggregateOutputType> | number
          }
        }
      }
      TemplateBox: {
        payload: Prisma.$TemplateBoxPayload<ExtArgs>
        fields: Prisma.TemplateBoxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateBoxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateBoxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateBoxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateBoxPayload>
          }
          findFirst: {
            args: Prisma.TemplateBoxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateBoxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateBoxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateBoxPayload>
          }
          findMany: {
            args: Prisma.TemplateBoxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateBoxPayload>[]
          }
          create: {
            args: Prisma.TemplateBoxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateBoxPayload>
          }
          createMany: {
            args: Prisma.TemplateBoxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateBoxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateBoxPayload>[]
          }
          delete: {
            args: Prisma.TemplateBoxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateBoxPayload>
          }
          update: {
            args: Prisma.TemplateBoxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateBoxPayload>
          }
          deleteMany: {
            args: Prisma.TemplateBoxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateBoxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateBoxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateBoxPayload>
          }
          aggregate: {
            args: Prisma.TemplateBoxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateBox>
          }
          groupBy: {
            args: Prisma.TemplateBoxGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateBoxGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateBoxCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateBoxCountAggregateOutputType> | number
          }
        }
      }
      CatalogPole: {
        payload: Prisma.$CatalogPolePayload<ExtArgs>
        fields: Prisma.CatalogPoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogPoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogPoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPolePayload>
          }
          findFirst: {
            args: Prisma.CatalogPoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogPoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPolePayload>
          }
          findMany: {
            args: Prisma.CatalogPoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPolePayload>[]
          }
          create: {
            args: Prisma.CatalogPoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPolePayload>
          }
          createMany: {
            args: Prisma.CatalogPoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogPoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPolePayload>[]
          }
          delete: {
            args: Prisma.CatalogPoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPolePayload>
          }
          update: {
            args: Prisma.CatalogPoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPolePayload>
          }
          deleteMany: {
            args: Prisma.CatalogPoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogPoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatalogPoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPolePayload>
          }
          aggregate: {
            args: Prisma.CatalogPoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogPole>
          }
          groupBy: {
            args: Prisma.CatalogPoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogPoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogPoleCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogPoleCountAggregateOutputType> | number
          }
        }
      }
      TemplatePole: {
        payload: Prisma.$TemplatePolePayload<ExtArgs>
        fields: Prisma.TemplatePoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplatePoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplatePoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePolePayload>
          }
          findFirst: {
            args: Prisma.TemplatePoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplatePoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePolePayload>
          }
          findMany: {
            args: Prisma.TemplatePoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePolePayload>[]
          }
          create: {
            args: Prisma.TemplatePoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePolePayload>
          }
          createMany: {
            args: Prisma.TemplatePoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplatePoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePolePayload>[]
          }
          delete: {
            args: Prisma.TemplatePoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePolePayload>
          }
          update: {
            args: Prisma.TemplatePoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePolePayload>
          }
          deleteMany: {
            args: Prisma.TemplatePoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplatePoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplatePoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePolePayload>
          }
          aggregate: {
            args: Prisma.TemplatePoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplatePole>
          }
          groupBy: {
            args: Prisma.TemplatePoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplatePoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplatePoleCountArgs<ExtArgs>
            result: $Utils.Optional<TemplatePoleCountAggregateOutputType> | number
          }
        }
      }
      Pole: {
        payload: Prisma.$PolePayload<ExtArgs>
        fields: Prisma.PoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolePayload>
          }
          findFirst: {
            args: Prisma.PoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolePayload>
          }
          findMany: {
            args: Prisma.PoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolePayload>[]
          }
          create: {
            args: Prisma.PoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolePayload>
          }
          createMany: {
            args: Prisma.PoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolePayload>[]
          }
          delete: {
            args: Prisma.PoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolePayload>
          }
          update: {
            args: Prisma.PoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolePayload>
          }
          deleteMany: {
            args: Prisma.PoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolePayload>
          }
          aggregate: {
            args: Prisma.PoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePole>
          }
          groupBy: {
            args: Prisma.PoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PoleCountArgs<ExtArgs>
            result: $Utils.Optional<PoleCountAggregateOutputType> | number
          }
        }
      }
      CatalogFusion: {
        payload: Prisma.$CatalogFusionPayload<ExtArgs>
        fields: Prisma.CatalogFusionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogFusionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogFusionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogFusionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogFusionPayload>
          }
          findFirst: {
            args: Prisma.CatalogFusionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogFusionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogFusionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogFusionPayload>
          }
          findMany: {
            args: Prisma.CatalogFusionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogFusionPayload>[]
          }
          create: {
            args: Prisma.CatalogFusionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogFusionPayload>
          }
          createMany: {
            args: Prisma.CatalogFusionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogFusionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogFusionPayload>[]
          }
          delete: {
            args: Prisma.CatalogFusionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogFusionPayload>
          }
          update: {
            args: Prisma.CatalogFusionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogFusionPayload>
          }
          deleteMany: {
            args: Prisma.CatalogFusionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogFusionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatalogFusionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogFusionPayload>
          }
          aggregate: {
            args: Prisma.CatalogFusionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogFusion>
          }
          groupBy: {
            args: Prisma.CatalogFusionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogFusionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogFusionCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogFusionCountAggregateOutputType> | number
          }
        }
      }
      TemplateFusion: {
        payload: Prisma.$TemplateFusionPayload<ExtArgs>
        fields: Prisma.TemplateFusionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateFusionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateFusionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateFusionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateFusionPayload>
          }
          findFirst: {
            args: Prisma.TemplateFusionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateFusionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateFusionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateFusionPayload>
          }
          findMany: {
            args: Prisma.TemplateFusionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateFusionPayload>[]
          }
          create: {
            args: Prisma.TemplateFusionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateFusionPayload>
          }
          createMany: {
            args: Prisma.TemplateFusionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateFusionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateFusionPayload>[]
          }
          delete: {
            args: Prisma.TemplateFusionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateFusionPayload>
          }
          update: {
            args: Prisma.TemplateFusionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateFusionPayload>
          }
          deleteMany: {
            args: Prisma.TemplateFusionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateFusionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateFusionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateFusionPayload>
          }
          aggregate: {
            args: Prisma.TemplateFusionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateFusion>
          }
          groupBy: {
            args: Prisma.TemplateFusionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateFusionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateFusionCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateFusionCountAggregateOutputType> | number
          }
        }
      }
      CatalogOLT: {
        payload: Prisma.$CatalogOLTPayload<ExtArgs>
        fields: Prisma.CatalogOLTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogOLTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogOLTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogOLTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogOLTPayload>
          }
          findFirst: {
            args: Prisma.CatalogOLTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogOLTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogOLTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogOLTPayload>
          }
          findMany: {
            args: Prisma.CatalogOLTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogOLTPayload>[]
          }
          create: {
            args: Prisma.CatalogOLTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogOLTPayload>
          }
          createMany: {
            args: Prisma.CatalogOLTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogOLTCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogOLTPayload>[]
          }
          delete: {
            args: Prisma.CatalogOLTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogOLTPayload>
          }
          update: {
            args: Prisma.CatalogOLTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogOLTPayload>
          }
          deleteMany: {
            args: Prisma.CatalogOLTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogOLTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatalogOLTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogOLTPayload>
          }
          aggregate: {
            args: Prisma.CatalogOLTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogOLT>
          }
          groupBy: {
            args: Prisma.CatalogOLTGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogOLTGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogOLTCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogOLTCountAggregateOutputType> | number
          }
        }
      }
      TemplateOLT: {
        payload: Prisma.$TemplateOLTPayload<ExtArgs>
        fields: Prisma.TemplateOLTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateOLTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateOLTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateOLTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateOLTPayload>
          }
          findFirst: {
            args: Prisma.TemplateOLTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateOLTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateOLTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateOLTPayload>
          }
          findMany: {
            args: Prisma.TemplateOLTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateOLTPayload>[]
          }
          create: {
            args: Prisma.TemplateOLTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateOLTPayload>
          }
          createMany: {
            args: Prisma.TemplateOLTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateOLTCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateOLTPayload>[]
          }
          delete: {
            args: Prisma.TemplateOLTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateOLTPayload>
          }
          update: {
            args: Prisma.TemplateOLTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateOLTPayload>
          }
          deleteMany: {
            args: Prisma.TemplateOLTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateOLTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateOLTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateOLTPayload>
          }
          aggregate: {
            args: Prisma.TemplateOLTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateOLT>
          }
          groupBy: {
            args: Prisma.TemplateOLTGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateOLTGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateOLTCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateOLTCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    projects: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    cables: number
    ctos: number
    pops: number
    projects: number
    users: number
    poles: number
    catalogCables: number
    catalogBoxes: number
    catalogPoles: number
    catalogSplitters: number
    catalogFusions: number
    catalogOLTs: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cables?: boolean | CompanyCountOutputTypeCountCablesArgs
    ctos?: boolean | CompanyCountOutputTypeCountCtosArgs
    pops?: boolean | CompanyCountOutputTypeCountPopsArgs
    projects?: boolean | CompanyCountOutputTypeCountProjectsArgs
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    poles?: boolean | CompanyCountOutputTypeCountPolesArgs
    catalogCables?: boolean | CompanyCountOutputTypeCountCatalogCablesArgs
    catalogBoxes?: boolean | CompanyCountOutputTypeCountCatalogBoxesArgs
    catalogPoles?: boolean | CompanyCountOutputTypeCountCatalogPolesArgs
    catalogSplitters?: boolean | CompanyCountOutputTypeCountCatalogSplittersArgs
    catalogFusions?: boolean | CompanyCountOutputTypeCountCatalogFusionsArgs
    catalogOLTs?: boolean | CompanyCountOutputTypeCountCatalogOLTsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CableWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCtosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CtoWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PopWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoleWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCatalogCablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogCableWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCatalogBoxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogBoxWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCatalogPolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogPoleWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCatalogSplittersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogSplitterWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCatalogFusionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogFusionWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCatalogOLTsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogOLTWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    companies: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | PlanCountOutputTypeCountCompaniesArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    cables: number
    ctos: number
    pops: number
    poles: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cables?: boolean | ProjectCountOutputTypeCountCablesArgs
    ctos?: boolean | ProjectCountOutputTypeCountCtosArgs
    pops?: boolean | ProjectCountOutputTypeCountPopsArgs
    poles?: boolean | ProjectCountOutputTypeCountPolesArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CableWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCtosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CtoWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PopWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoleWhereInput
  }


  /**
   * Count Type CatalogPoleCountOutputType
   */

  export type CatalogPoleCountOutputType = {
    instances: number
  }

  export type CatalogPoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instances?: boolean | CatalogPoleCountOutputTypeCountInstancesArgs
  }

  // Custom InputTypes
  /**
   * CatalogPoleCountOutputType without action
   */
  export type CatalogPoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPoleCountOutputType
     */
    select?: CatalogPoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogPoleCountOutputType without action
   */
  export type CatalogPoleCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    passwordHash: string | null
    createdAt: Date | null
    companyId: string | null
    role: $Enums.UserRole | null
    active: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    passwordHash: string | null
    createdAt: Date | null
    companyId: string | null
    role: $Enums.UserRole | null
    active: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    passwordHash: number
    createdAt: number
    companyId: number
    role: number
    active: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    passwordHash?: true
    createdAt?: true
    companyId?: true
    role?: true
    active?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    passwordHash?: true
    createdAt?: true
    companyId?: true
    role?: true
    active?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    passwordHash?: true
    createdAt?: true
    companyId?: true
    role?: true
    active?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    passwordHash: string
    createdAt: Date
    companyId: string | null
    role: $Enums.UserRole
    active: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    companyId?: boolean
    role?: boolean
    active?: boolean
    projects?: boolean | User$projectsArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    companyId?: boolean
    role?: boolean
    active?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    companyId?: boolean
    role?: boolean
    active?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | User$projectsArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs> | null
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      passwordHash: string
      createdAt: Date
      companyId: string | null
      role: $Enums.UserRole
      active: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends User$companyArgs<ExtArgs> = {}>(args?: Subset<T, User$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly companyId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly active: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.company
   */
  export type User$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    planId: string | null
    subscriptionExpiresAt: Date | null
    status: string | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    planId: string | null
    subscriptionExpiresAt: Date | null
    status: string | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    planId: number
    subscriptionExpiresAt: number
    status: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    planId?: true
    subscriptionExpiresAt?: true
    status?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    planId?: true
    subscriptionExpiresAt?: true
    status?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    planId?: true
    subscriptionExpiresAt?: true
    status?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    planId: string | null
    subscriptionExpiresAt: Date | null
    status: string
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planId?: boolean
    subscriptionExpiresAt?: boolean
    status?: boolean
    cables?: boolean | Company$cablesArgs<ExtArgs>
    plan?: boolean | Company$planArgs<ExtArgs>
    ctos?: boolean | Company$ctosArgs<ExtArgs>
    pops?: boolean | Company$popsArgs<ExtArgs>
    projects?: boolean | Company$projectsArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    poles?: boolean | Company$polesArgs<ExtArgs>
    catalogCables?: boolean | Company$catalogCablesArgs<ExtArgs>
    catalogBoxes?: boolean | Company$catalogBoxesArgs<ExtArgs>
    catalogPoles?: boolean | Company$catalogPolesArgs<ExtArgs>
    catalogSplitters?: boolean | Company$catalogSplittersArgs<ExtArgs>
    catalogFusions?: boolean | Company$catalogFusionsArgs<ExtArgs>
    catalogOLTs?: boolean | Company$catalogOLTsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planId?: boolean
    subscriptionExpiresAt?: boolean
    status?: boolean
    plan?: boolean | Company$planArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planId?: boolean
    subscriptionExpiresAt?: boolean
    status?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cables?: boolean | Company$cablesArgs<ExtArgs>
    plan?: boolean | Company$planArgs<ExtArgs>
    ctos?: boolean | Company$ctosArgs<ExtArgs>
    pops?: boolean | Company$popsArgs<ExtArgs>
    projects?: boolean | Company$projectsArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    poles?: boolean | Company$polesArgs<ExtArgs>
    catalogCables?: boolean | Company$catalogCablesArgs<ExtArgs>
    catalogBoxes?: boolean | Company$catalogBoxesArgs<ExtArgs>
    catalogPoles?: boolean | Company$catalogPolesArgs<ExtArgs>
    catalogSplitters?: boolean | Company$catalogSplittersArgs<ExtArgs>
    catalogFusions?: boolean | Company$catalogFusionsArgs<ExtArgs>
    catalogOLTs?: boolean | Company$catalogOLTsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | Company$planArgs<ExtArgs>
  }

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      cables: Prisma.$CablePayload<ExtArgs>[]
      plan: Prisma.$PlanPayload<ExtArgs> | null
      ctos: Prisma.$CtoPayload<ExtArgs>[]
      pops: Prisma.$PopPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      poles: Prisma.$PolePayload<ExtArgs>[]
      catalogCables: Prisma.$CatalogCablePayload<ExtArgs>[]
      catalogBoxes: Prisma.$CatalogBoxPayload<ExtArgs>[]
      catalogPoles: Prisma.$CatalogPolePayload<ExtArgs>[]
      catalogSplitters: Prisma.$CatalogSplitterPayload<ExtArgs>[]
      catalogFusions: Prisma.$CatalogFusionPayload<ExtArgs>[]
      catalogOLTs: Prisma.$CatalogOLTPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      planId: string | null
      subscriptionExpiresAt: Date | null
      status: string
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cables<T extends Company$cablesArgs<ExtArgs> = {}>(args?: Subset<T, Company$cablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CablePayload<ExtArgs>, T, "findMany"> | Null>
    plan<T extends Company$planArgs<ExtArgs> = {}>(args?: Subset<T, Company$planArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ctos<T extends Company$ctosArgs<ExtArgs> = {}>(args?: Subset<T, Company$ctosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CtoPayload<ExtArgs>, T, "findMany"> | Null>
    pops<T extends Company$popsArgs<ExtArgs> = {}>(args?: Subset<T, Company$popsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PopPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends Company$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Company$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    poles<T extends Company$polesArgs<ExtArgs> = {}>(args?: Subset<T, Company$polesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "findMany"> | Null>
    catalogCables<T extends Company$catalogCablesArgs<ExtArgs> = {}>(args?: Subset<T, Company$catalogCablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogCablePayload<ExtArgs>, T, "findMany"> | Null>
    catalogBoxes<T extends Company$catalogBoxesArgs<ExtArgs> = {}>(args?: Subset<T, Company$catalogBoxesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogBoxPayload<ExtArgs>, T, "findMany"> | Null>
    catalogPoles<T extends Company$catalogPolesArgs<ExtArgs> = {}>(args?: Subset<T, Company$catalogPolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPolePayload<ExtArgs>, T, "findMany"> | Null>
    catalogSplitters<T extends Company$catalogSplittersArgs<ExtArgs> = {}>(args?: Subset<T, Company$catalogSplittersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogSplitterPayload<ExtArgs>, T, "findMany"> | Null>
    catalogFusions<T extends Company$catalogFusionsArgs<ExtArgs> = {}>(args?: Subset<T, Company$catalogFusionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogFusionPayload<ExtArgs>, T, "findMany"> | Null>
    catalogOLTs<T extends Company$catalogOLTsArgs<ExtArgs> = {}>(args?: Subset<T, Company$catalogOLTsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogOLTPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
    readonly planId: FieldRef<"Company", 'String'>
    readonly subscriptionExpiresAt: FieldRef<"Company", 'DateTime'>
    readonly status: FieldRef<"Company", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.cables
   */
  export type Company$cablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableInclude<ExtArgs> | null
    where?: CableWhereInput
    orderBy?: CableOrderByWithRelationInput | CableOrderByWithRelationInput[]
    cursor?: CableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CableScalarFieldEnum | CableScalarFieldEnum[]
  }

  /**
   * Company.plan
   */
  export type Company$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
  }

  /**
   * Company.ctos
   */
  export type Company$ctosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoInclude<ExtArgs> | null
    where?: CtoWhereInput
    orderBy?: CtoOrderByWithRelationInput | CtoOrderByWithRelationInput[]
    cursor?: CtoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CtoScalarFieldEnum | CtoScalarFieldEnum[]
  }

  /**
   * Company.pops
   */
  export type Company$popsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopInclude<ExtArgs> | null
    where?: PopWhereInput
    orderBy?: PopOrderByWithRelationInput | PopOrderByWithRelationInput[]
    cursor?: PopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PopScalarFieldEnum | PopScalarFieldEnum[]
  }

  /**
   * Company.projects
   */
  export type Company$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.poles
   */
  export type Company$polesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
    where?: PoleWhereInput
    orderBy?: PoleOrderByWithRelationInput | PoleOrderByWithRelationInput[]
    cursor?: PoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PoleScalarFieldEnum | PoleScalarFieldEnum[]
  }

  /**
   * Company.catalogCables
   */
  export type Company$catalogCablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCable
     */
    select?: CatalogCableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCableInclude<ExtArgs> | null
    where?: CatalogCableWhereInput
    orderBy?: CatalogCableOrderByWithRelationInput | CatalogCableOrderByWithRelationInput[]
    cursor?: CatalogCableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogCableScalarFieldEnum | CatalogCableScalarFieldEnum[]
  }

  /**
   * Company.catalogBoxes
   */
  export type Company$catalogBoxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBox
     */
    select?: CatalogBoxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogBoxInclude<ExtArgs> | null
    where?: CatalogBoxWhereInput
    orderBy?: CatalogBoxOrderByWithRelationInput | CatalogBoxOrderByWithRelationInput[]
    cursor?: CatalogBoxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogBoxScalarFieldEnum | CatalogBoxScalarFieldEnum[]
  }

  /**
   * Company.catalogPoles
   */
  export type Company$catalogPolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleInclude<ExtArgs> | null
    where?: CatalogPoleWhereInput
    orderBy?: CatalogPoleOrderByWithRelationInput | CatalogPoleOrderByWithRelationInput[]
    cursor?: CatalogPoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogPoleScalarFieldEnum | CatalogPoleScalarFieldEnum[]
  }

  /**
   * Company.catalogSplitters
   */
  export type Company$catalogSplittersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogSplitter
     */
    select?: CatalogSplitterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogSplitterInclude<ExtArgs> | null
    where?: CatalogSplitterWhereInput
    orderBy?: CatalogSplitterOrderByWithRelationInput | CatalogSplitterOrderByWithRelationInput[]
    cursor?: CatalogSplitterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogSplitterScalarFieldEnum | CatalogSplitterScalarFieldEnum[]
  }

  /**
   * Company.catalogFusions
   */
  export type Company$catalogFusionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogFusion
     */
    select?: CatalogFusionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogFusionInclude<ExtArgs> | null
    where?: CatalogFusionWhereInput
    orderBy?: CatalogFusionOrderByWithRelationInput | CatalogFusionOrderByWithRelationInput[]
    cursor?: CatalogFusionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogFusionScalarFieldEnum | CatalogFusionScalarFieldEnum[]
  }

  /**
   * Company.catalogOLTs
   */
  export type Company$catalogOLTsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogOLT
     */
    select?: CatalogOLTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogOLTInclude<ExtArgs> | null
    where?: CatalogOLTWhereInput
    orderBy?: CatalogOLTOrderByWithRelationInput | CatalogOLTOrderByWithRelationInput[]
    cursor?: CatalogOLTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogOLTScalarFieldEnum | CatalogOLTScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    price: number | null
  }

  export type PlanSumAggregateOutputType = {
    price: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    createdAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    createdAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    price: number
    limits: number
    createdAt: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    price?: true
  }

  export type PlanSumAggregateInputType = {
    price?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    createdAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    createdAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    limits?: true
    createdAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    price: number
    limits: JsonValue
    createdAt: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    limits?: boolean
    createdAt?: boolean
    companies?: boolean | Plan$companiesArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    limits?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    limits?: boolean
    createdAt?: boolean
  }

  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | Plan$companiesArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      companies: Prisma.$CompanyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: number
      limits: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends Plan$companiesArgs<ExtArgs> = {}>(args?: Subset<T, Plan$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */ 
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly price: FieldRef<"Plan", 'Float'>
    readonly limits: FieldRef<"Plan", 'Json'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
  }

  /**
   * Plan.companies
   */
  export type Plan$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    cursor?: CompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    centerLat: number | null
    centerLng: number | null
    zoom: number | null
  }

  export type ProjectSumAggregateOutputType = {
    centerLat: number | null
    centerLng: number | null
    zoom: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    centerLat: number | null
    centerLng: number | null
    zoom: number | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    centerLat: number | null
    centerLng: number | null
    zoom: number | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    centerLat: number
    centerLng: number
    zoom: number
    settings: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    centerLat?: true
    centerLng?: true
    zoom?: true
  }

  export type ProjectSumAggregateInputType = {
    centerLat?: true
    centerLng?: true
    zoom?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    centerLat?: true
    centerLng?: true
    zoom?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    centerLat?: true
    centerLng?: true
    zoom?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    centerLat?: true
    centerLng?: true
    zoom?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    userId: string
    name: string
    centerLat: number
    centerLng: number
    zoom: number
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    companyId: string | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    centerLat?: boolean
    centerLng?: boolean
    zoom?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    cables?: boolean | Project$cablesArgs<ExtArgs>
    ctos?: boolean | Project$ctosArgs<ExtArgs>
    pops?: boolean | Project$popsArgs<ExtArgs>
    poles?: boolean | Project$polesArgs<ExtArgs>
    company?: boolean | Project$companyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    centerLat?: boolean
    centerLng?: boolean
    zoom?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | Project$companyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    centerLat?: boolean
    centerLng?: boolean
    zoom?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cables?: boolean | Project$cablesArgs<ExtArgs>
    ctos?: boolean | Project$ctosArgs<ExtArgs>
    pops?: boolean | Project$popsArgs<ExtArgs>
    poles?: boolean | Project$polesArgs<ExtArgs>
    company?: boolean | Project$companyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Project$companyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      cables: Prisma.$CablePayload<ExtArgs>[]
      ctos: Prisma.$CtoPayload<ExtArgs>[]
      pops: Prisma.$PopPayload<ExtArgs>[]
      poles: Prisma.$PolePayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      centerLat: number
      centerLng: number
      zoom: number
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      companyId: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cables<T extends Project$cablesArgs<ExtArgs> = {}>(args?: Subset<T, Project$cablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CablePayload<ExtArgs>, T, "findMany"> | Null>
    ctos<T extends Project$ctosArgs<ExtArgs> = {}>(args?: Subset<T, Project$ctosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CtoPayload<ExtArgs>, T, "findMany"> | Null>
    pops<T extends Project$popsArgs<ExtArgs> = {}>(args?: Subset<T, Project$popsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PopPayload<ExtArgs>, T, "findMany"> | Null>
    poles<T extends Project$polesArgs<ExtArgs> = {}>(args?: Subset<T, Project$polesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends Project$companyArgs<ExtArgs> = {}>(args?: Subset<T, Project$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly userId: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly centerLat: FieldRef<"Project", 'Float'>
    readonly centerLng: FieldRef<"Project", 'Float'>
    readonly zoom: FieldRef<"Project", 'Int'>
    readonly settings: FieldRef<"Project", 'Json'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly companyId: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.cables
   */
  export type Project$cablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableInclude<ExtArgs> | null
    where?: CableWhereInput
    orderBy?: CableOrderByWithRelationInput | CableOrderByWithRelationInput[]
    cursor?: CableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CableScalarFieldEnum | CableScalarFieldEnum[]
  }

  /**
   * Project.ctos
   */
  export type Project$ctosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoInclude<ExtArgs> | null
    where?: CtoWhereInput
    orderBy?: CtoOrderByWithRelationInput | CtoOrderByWithRelationInput[]
    cursor?: CtoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CtoScalarFieldEnum | CtoScalarFieldEnum[]
  }

  /**
   * Project.pops
   */
  export type Project$popsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopInclude<ExtArgs> | null
    where?: PopWhereInput
    orderBy?: PopOrderByWithRelationInput | PopOrderByWithRelationInput[]
    cursor?: PopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PopScalarFieldEnum | PopScalarFieldEnum[]
  }

  /**
   * Project.poles
   */
  export type Project$polesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
    where?: PoleWhereInput
    orderBy?: PoleOrderByWithRelationInput | PoleOrderByWithRelationInput[]
    cursor?: PoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PoleScalarFieldEnum | PoleScalarFieldEnum[]
  }

  /**
   * Project.company
   */
  export type Project$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Cto
   */

  export type AggregateCto = {
    _count: CtoCountAggregateOutputType | null
    _avg: CtoAvgAggregateOutputType | null
    _sum: CtoSumAggregateOutputType | null
    _min: CtoMinAggregateOutputType | null
    _max: CtoMaxAggregateOutputType | null
  }

  export type CtoAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
    clientCount: number | null
    reserveLoopLength: number | null
  }

  export type CtoSumAggregateOutputType = {
    lat: number | null
    lng: number | null
    clientCount: number | null
    reserveLoopLength: number | null
  }

  export type CtoMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    status: $Enums.EquipmentStatus | null
    lat: number | null
    lng: number | null
    clientCount: number | null
    catalogId: string | null
    type: string | null
    color: string | null
    reserveLoopLength: number | null
    companyId: string | null
  }

  export type CtoMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    status: $Enums.EquipmentStatus | null
    lat: number | null
    lng: number | null
    clientCount: number | null
    catalogId: string | null
    type: string | null
    color: string | null
    reserveLoopLength: number | null
    companyId: string | null
  }

  export type CtoCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    status: number
    lat: number
    lng: number
    splitters: number
    fusions: number
    connections: number
    inputCableIds: number
    layout: number
    clientCount: number
    catalogId: number
    type: number
    color: number
    reserveLoopLength: number
    companyId: number
    _all: number
  }


  export type CtoAvgAggregateInputType = {
    lat?: true
    lng?: true
    clientCount?: true
    reserveLoopLength?: true
  }

  export type CtoSumAggregateInputType = {
    lat?: true
    lng?: true
    clientCount?: true
    reserveLoopLength?: true
  }

  export type CtoMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    status?: true
    lat?: true
    lng?: true
    clientCount?: true
    catalogId?: true
    type?: true
    color?: true
    reserveLoopLength?: true
    companyId?: true
  }

  export type CtoMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    status?: true
    lat?: true
    lng?: true
    clientCount?: true
    catalogId?: true
    type?: true
    color?: true
    reserveLoopLength?: true
    companyId?: true
  }

  export type CtoCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    status?: true
    lat?: true
    lng?: true
    splitters?: true
    fusions?: true
    connections?: true
    inputCableIds?: true
    layout?: true
    clientCount?: true
    catalogId?: true
    type?: true
    color?: true
    reserveLoopLength?: true
    companyId?: true
    _all?: true
  }

  export type CtoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cto to aggregate.
     */
    where?: CtoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ctos to fetch.
     */
    orderBy?: CtoOrderByWithRelationInput | CtoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CtoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ctos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ctos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ctos
    **/
    _count?: true | CtoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CtoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CtoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CtoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CtoMaxAggregateInputType
  }

  export type GetCtoAggregateType<T extends CtoAggregateArgs> = {
        [P in keyof T & keyof AggregateCto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCto[P]>
      : GetScalarType<T[P], AggregateCto[P]>
  }




  export type CtoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CtoWhereInput
    orderBy?: CtoOrderByWithAggregationInput | CtoOrderByWithAggregationInput[]
    by: CtoScalarFieldEnum[] | CtoScalarFieldEnum
    having?: CtoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CtoCountAggregateInputType | true
    _avg?: CtoAvgAggregateInputType
    _sum?: CtoSumAggregateInputType
    _min?: CtoMinAggregateInputType
    _max?: CtoMaxAggregateInputType
  }

  export type CtoGroupByOutputType = {
    id: string
    projectId: string
    name: string
    status: $Enums.EquipmentStatus
    lat: number
    lng: number
    splitters: JsonValue | null
    fusions: JsonValue | null
    connections: JsonValue | null
    inputCableIds: string[]
    layout: JsonValue | null
    clientCount: number
    catalogId: string | null
    type: string | null
    color: string | null
    reserveLoopLength: number | null
    companyId: string | null
    _count: CtoCountAggregateOutputType | null
    _avg: CtoAvgAggregateOutputType | null
    _sum: CtoSumAggregateOutputType | null
    _min: CtoMinAggregateOutputType | null
    _max: CtoMaxAggregateOutputType | null
  }

  type GetCtoGroupByPayload<T extends CtoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CtoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CtoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CtoGroupByOutputType[P]>
            : GetScalarType<T[P], CtoGroupByOutputType[P]>
        }
      >
    >


  export type CtoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    status?: boolean
    lat?: boolean
    lng?: boolean
    splitters?: boolean
    fusions?: boolean
    connections?: boolean
    inputCableIds?: boolean
    layout?: boolean
    clientCount?: boolean
    catalogId?: boolean
    type?: boolean
    color?: boolean
    reserveLoopLength?: boolean
    companyId?: boolean
    company?: boolean | Cto$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cto"]>

  export type CtoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    status?: boolean
    lat?: boolean
    lng?: boolean
    splitters?: boolean
    fusions?: boolean
    connections?: boolean
    inputCableIds?: boolean
    layout?: boolean
    clientCount?: boolean
    catalogId?: boolean
    type?: boolean
    color?: boolean
    reserveLoopLength?: boolean
    companyId?: boolean
    company?: boolean | Cto$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cto"]>

  export type CtoSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    status?: boolean
    lat?: boolean
    lng?: boolean
    splitters?: boolean
    fusions?: boolean
    connections?: boolean
    inputCableIds?: boolean
    layout?: boolean
    clientCount?: boolean
    catalogId?: boolean
    type?: boolean
    color?: boolean
    reserveLoopLength?: boolean
    companyId?: boolean
  }

  export type CtoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Cto$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type CtoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Cto$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $CtoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cto"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      status: $Enums.EquipmentStatus
      lat: number
      lng: number
      splitters: Prisma.JsonValue | null
      fusions: Prisma.JsonValue | null
      connections: Prisma.JsonValue | null
      inputCableIds: string[]
      layout: Prisma.JsonValue | null
      clientCount: number
      catalogId: string | null
      type: string | null
      color: string | null
      reserveLoopLength: number | null
      companyId: string | null
    }, ExtArgs["result"]["cto"]>
    composites: {}
  }

  type CtoGetPayload<S extends boolean | null | undefined | CtoDefaultArgs> = $Result.GetResult<Prisma.$CtoPayload, S>

  type CtoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CtoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CtoCountAggregateInputType | true
    }

  export interface CtoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cto'], meta: { name: 'Cto' } }
    /**
     * Find zero or one Cto that matches the filter.
     * @param {CtoFindUniqueArgs} args - Arguments to find a Cto
     * @example
     * // Get one Cto
     * const cto = await prisma.cto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CtoFindUniqueArgs>(args: SelectSubset<T, CtoFindUniqueArgs<ExtArgs>>): Prisma__CtoClient<$Result.GetResult<Prisma.$CtoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CtoFindUniqueOrThrowArgs} args - Arguments to find a Cto
     * @example
     * // Get one Cto
     * const cto = await prisma.cto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CtoFindUniqueOrThrowArgs>(args: SelectSubset<T, CtoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CtoClient<$Result.GetResult<Prisma.$CtoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtoFindFirstArgs} args - Arguments to find a Cto
     * @example
     * // Get one Cto
     * const cto = await prisma.cto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CtoFindFirstArgs>(args?: SelectSubset<T, CtoFindFirstArgs<ExtArgs>>): Prisma__CtoClient<$Result.GetResult<Prisma.$CtoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtoFindFirstOrThrowArgs} args - Arguments to find a Cto
     * @example
     * // Get one Cto
     * const cto = await prisma.cto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CtoFindFirstOrThrowArgs>(args?: SelectSubset<T, CtoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CtoClient<$Result.GetResult<Prisma.$CtoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ctos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ctos
     * const ctos = await prisma.cto.findMany()
     * 
     * // Get first 10 Ctos
     * const ctos = await prisma.cto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ctoWithIdOnly = await prisma.cto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CtoFindManyArgs>(args?: SelectSubset<T, CtoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CtoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cto.
     * @param {CtoCreateArgs} args - Arguments to create a Cto.
     * @example
     * // Create one Cto
     * const Cto = await prisma.cto.create({
     *   data: {
     *     // ... data to create a Cto
     *   }
     * })
     * 
     */
    create<T extends CtoCreateArgs>(args: SelectSubset<T, CtoCreateArgs<ExtArgs>>): Prisma__CtoClient<$Result.GetResult<Prisma.$CtoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ctos.
     * @param {CtoCreateManyArgs} args - Arguments to create many Ctos.
     * @example
     * // Create many Ctos
     * const cto = await prisma.cto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CtoCreateManyArgs>(args?: SelectSubset<T, CtoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ctos and returns the data saved in the database.
     * @param {CtoCreateManyAndReturnArgs} args - Arguments to create many Ctos.
     * @example
     * // Create many Ctos
     * const cto = await prisma.cto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ctos and only return the `id`
     * const ctoWithIdOnly = await prisma.cto.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CtoCreateManyAndReturnArgs>(args?: SelectSubset<T, CtoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CtoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cto.
     * @param {CtoDeleteArgs} args - Arguments to delete one Cto.
     * @example
     * // Delete one Cto
     * const Cto = await prisma.cto.delete({
     *   where: {
     *     // ... filter to delete one Cto
     *   }
     * })
     * 
     */
    delete<T extends CtoDeleteArgs>(args: SelectSubset<T, CtoDeleteArgs<ExtArgs>>): Prisma__CtoClient<$Result.GetResult<Prisma.$CtoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cto.
     * @param {CtoUpdateArgs} args - Arguments to update one Cto.
     * @example
     * // Update one Cto
     * const cto = await prisma.cto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CtoUpdateArgs>(args: SelectSubset<T, CtoUpdateArgs<ExtArgs>>): Prisma__CtoClient<$Result.GetResult<Prisma.$CtoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ctos.
     * @param {CtoDeleteManyArgs} args - Arguments to filter Ctos to delete.
     * @example
     * // Delete a few Ctos
     * const { count } = await prisma.cto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CtoDeleteManyArgs>(args?: SelectSubset<T, CtoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ctos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ctos
     * const cto = await prisma.cto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CtoUpdateManyArgs>(args: SelectSubset<T, CtoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cto.
     * @param {CtoUpsertArgs} args - Arguments to update or create a Cto.
     * @example
     * // Update or create a Cto
     * const cto = await prisma.cto.upsert({
     *   create: {
     *     // ... data to create a Cto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cto we want to update
     *   }
     * })
     */
    upsert<T extends CtoUpsertArgs>(args: SelectSubset<T, CtoUpsertArgs<ExtArgs>>): Prisma__CtoClient<$Result.GetResult<Prisma.$CtoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ctos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtoCountArgs} args - Arguments to filter Ctos to count.
     * @example
     * // Count the number of Ctos
     * const count = await prisma.cto.count({
     *   where: {
     *     // ... the filter for the Ctos we want to count
     *   }
     * })
    **/
    count<T extends CtoCountArgs>(
      args?: Subset<T, CtoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CtoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CtoAggregateArgs>(args: Subset<T, CtoAggregateArgs>): Prisma.PrismaPromise<GetCtoAggregateType<T>>

    /**
     * Group by Cto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CtoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CtoGroupByArgs['orderBy'] }
        : { orderBy?: CtoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CtoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCtoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cto model
   */
  readonly fields: CtoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CtoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends Cto$companyArgs<ExtArgs> = {}>(args?: Subset<T, Cto$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cto model
   */ 
  interface CtoFieldRefs {
    readonly id: FieldRef<"Cto", 'String'>
    readonly projectId: FieldRef<"Cto", 'String'>
    readonly name: FieldRef<"Cto", 'String'>
    readonly status: FieldRef<"Cto", 'EquipmentStatus'>
    readonly lat: FieldRef<"Cto", 'Float'>
    readonly lng: FieldRef<"Cto", 'Float'>
    readonly splitters: FieldRef<"Cto", 'Json'>
    readonly fusions: FieldRef<"Cto", 'Json'>
    readonly connections: FieldRef<"Cto", 'Json'>
    readonly inputCableIds: FieldRef<"Cto", 'String[]'>
    readonly layout: FieldRef<"Cto", 'Json'>
    readonly clientCount: FieldRef<"Cto", 'Int'>
    readonly catalogId: FieldRef<"Cto", 'String'>
    readonly type: FieldRef<"Cto", 'String'>
    readonly color: FieldRef<"Cto", 'String'>
    readonly reserveLoopLength: FieldRef<"Cto", 'Float'>
    readonly companyId: FieldRef<"Cto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cto findUnique
   */
  export type CtoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoInclude<ExtArgs> | null
    /**
     * Filter, which Cto to fetch.
     */
    where: CtoWhereUniqueInput
  }

  /**
   * Cto findUniqueOrThrow
   */
  export type CtoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoInclude<ExtArgs> | null
    /**
     * Filter, which Cto to fetch.
     */
    where: CtoWhereUniqueInput
  }

  /**
   * Cto findFirst
   */
  export type CtoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoInclude<ExtArgs> | null
    /**
     * Filter, which Cto to fetch.
     */
    where?: CtoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ctos to fetch.
     */
    orderBy?: CtoOrderByWithRelationInput | CtoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ctos.
     */
    cursor?: CtoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ctos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ctos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ctos.
     */
    distinct?: CtoScalarFieldEnum | CtoScalarFieldEnum[]
  }

  /**
   * Cto findFirstOrThrow
   */
  export type CtoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoInclude<ExtArgs> | null
    /**
     * Filter, which Cto to fetch.
     */
    where?: CtoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ctos to fetch.
     */
    orderBy?: CtoOrderByWithRelationInput | CtoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ctos.
     */
    cursor?: CtoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ctos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ctos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ctos.
     */
    distinct?: CtoScalarFieldEnum | CtoScalarFieldEnum[]
  }

  /**
   * Cto findMany
   */
  export type CtoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoInclude<ExtArgs> | null
    /**
     * Filter, which Ctos to fetch.
     */
    where?: CtoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ctos to fetch.
     */
    orderBy?: CtoOrderByWithRelationInput | CtoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ctos.
     */
    cursor?: CtoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ctos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ctos.
     */
    skip?: number
    distinct?: CtoScalarFieldEnum | CtoScalarFieldEnum[]
  }

  /**
   * Cto create
   */
  export type CtoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoInclude<ExtArgs> | null
    /**
     * The data needed to create a Cto.
     */
    data: XOR<CtoCreateInput, CtoUncheckedCreateInput>
  }

  /**
   * Cto createMany
   */
  export type CtoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ctos.
     */
    data: CtoCreateManyInput | CtoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cto createManyAndReturn
   */
  export type CtoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Ctos.
     */
    data: CtoCreateManyInput | CtoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cto update
   */
  export type CtoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoInclude<ExtArgs> | null
    /**
     * The data needed to update a Cto.
     */
    data: XOR<CtoUpdateInput, CtoUncheckedUpdateInput>
    /**
     * Choose, which Cto to update.
     */
    where: CtoWhereUniqueInput
  }

  /**
   * Cto updateMany
   */
  export type CtoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ctos.
     */
    data: XOR<CtoUpdateManyMutationInput, CtoUncheckedUpdateManyInput>
    /**
     * Filter which Ctos to update
     */
    where?: CtoWhereInput
  }

  /**
   * Cto upsert
   */
  export type CtoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoInclude<ExtArgs> | null
    /**
     * The filter to search for the Cto to update in case it exists.
     */
    where: CtoWhereUniqueInput
    /**
     * In case the Cto found by the `where` argument doesn't exist, create a new Cto with this data.
     */
    create: XOR<CtoCreateInput, CtoUncheckedCreateInput>
    /**
     * In case the Cto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CtoUpdateInput, CtoUncheckedUpdateInput>
  }

  /**
   * Cto delete
   */
  export type CtoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoInclude<ExtArgs> | null
    /**
     * Filter which Cto to delete.
     */
    where: CtoWhereUniqueInput
  }

  /**
   * Cto deleteMany
   */
  export type CtoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ctos to delete
     */
    where?: CtoWhereInput
  }

  /**
   * Cto.company
   */
  export type Cto$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Cto without action
   */
  export type CtoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cto
     */
    select?: CtoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtoInclude<ExtArgs> | null
  }


  /**
   * Model Pop
   */

  export type AggregatePop = {
    _count: PopCountAggregateOutputType | null
    _avg: PopAvgAggregateOutputType | null
    _sum: PopSumAggregateOutputType | null
    _min: PopMinAggregateOutputType | null
    _max: PopMaxAggregateOutputType | null
  }

  export type PopAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
    size: number | null
  }

  export type PopSumAggregateOutputType = {
    lat: number | null
    lng: number | null
    size: number | null
  }

  export type PopMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    status: $Enums.EquipmentStatus | null
    lat: number | null
    lng: number | null
    color: string | null
    size: number | null
    companyId: string | null
  }

  export type PopMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    status: $Enums.EquipmentStatus | null
    lat: number | null
    lng: number | null
    color: string | null
    size: number | null
    companyId: string | null
  }

  export type PopCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    status: number
    lat: number
    lng: number
    olts: number
    dios: number
    fusions: number
    connections: number
    inputCableIds: number
    layout: number
    color: number
    size: number
    companyId: number
    _all: number
  }


  export type PopAvgAggregateInputType = {
    lat?: true
    lng?: true
    size?: true
  }

  export type PopSumAggregateInputType = {
    lat?: true
    lng?: true
    size?: true
  }

  export type PopMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    status?: true
    lat?: true
    lng?: true
    color?: true
    size?: true
    companyId?: true
  }

  export type PopMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    status?: true
    lat?: true
    lng?: true
    color?: true
    size?: true
    companyId?: true
  }

  export type PopCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    status?: true
    lat?: true
    lng?: true
    olts?: true
    dios?: true
    fusions?: true
    connections?: true
    inputCableIds?: true
    layout?: true
    color?: true
    size?: true
    companyId?: true
    _all?: true
  }

  export type PopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pop to aggregate.
     */
    where?: PopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pops to fetch.
     */
    orderBy?: PopOrderByWithRelationInput | PopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pops
    **/
    _count?: true | PopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PopMaxAggregateInputType
  }

  export type GetPopAggregateType<T extends PopAggregateArgs> = {
        [P in keyof T & keyof AggregatePop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePop[P]>
      : GetScalarType<T[P], AggregatePop[P]>
  }




  export type PopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PopWhereInput
    orderBy?: PopOrderByWithAggregationInput | PopOrderByWithAggregationInput[]
    by: PopScalarFieldEnum[] | PopScalarFieldEnum
    having?: PopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PopCountAggregateInputType | true
    _avg?: PopAvgAggregateInputType
    _sum?: PopSumAggregateInputType
    _min?: PopMinAggregateInputType
    _max?: PopMaxAggregateInputType
  }

  export type PopGroupByOutputType = {
    id: string
    projectId: string
    name: string
    status: $Enums.EquipmentStatus
    lat: number
    lng: number
    olts: JsonValue | null
    dios: JsonValue | null
    fusions: JsonValue | null
    connections: JsonValue | null
    inputCableIds: string[]
    layout: JsonValue | null
    color: string | null
    size: number | null
    companyId: string | null
    _count: PopCountAggregateOutputType | null
    _avg: PopAvgAggregateOutputType | null
    _sum: PopSumAggregateOutputType | null
    _min: PopMinAggregateOutputType | null
    _max: PopMaxAggregateOutputType | null
  }

  type GetPopGroupByPayload<T extends PopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PopGroupByOutputType[P]>
            : GetScalarType<T[P], PopGroupByOutputType[P]>
        }
      >
    >


  export type PopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    status?: boolean
    lat?: boolean
    lng?: boolean
    olts?: boolean
    dios?: boolean
    fusions?: boolean
    connections?: boolean
    inputCableIds?: boolean
    layout?: boolean
    color?: boolean
    size?: boolean
    companyId?: boolean
    company?: boolean | Pop$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pop"]>

  export type PopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    status?: boolean
    lat?: boolean
    lng?: boolean
    olts?: boolean
    dios?: boolean
    fusions?: boolean
    connections?: boolean
    inputCableIds?: boolean
    layout?: boolean
    color?: boolean
    size?: boolean
    companyId?: boolean
    company?: boolean | Pop$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pop"]>

  export type PopSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    status?: boolean
    lat?: boolean
    lng?: boolean
    olts?: boolean
    dios?: boolean
    fusions?: boolean
    connections?: boolean
    inputCableIds?: boolean
    layout?: boolean
    color?: boolean
    size?: boolean
    companyId?: boolean
  }

  export type PopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Pop$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type PopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Pop$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $PopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pop"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      status: $Enums.EquipmentStatus
      lat: number
      lng: number
      olts: Prisma.JsonValue | null
      dios: Prisma.JsonValue | null
      fusions: Prisma.JsonValue | null
      connections: Prisma.JsonValue | null
      inputCableIds: string[]
      layout: Prisma.JsonValue | null
      color: string | null
      size: number | null
      companyId: string | null
    }, ExtArgs["result"]["pop"]>
    composites: {}
  }

  type PopGetPayload<S extends boolean | null | undefined | PopDefaultArgs> = $Result.GetResult<Prisma.$PopPayload, S>

  type PopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PopFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PopCountAggregateInputType | true
    }

  export interface PopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pop'], meta: { name: 'Pop' } }
    /**
     * Find zero or one Pop that matches the filter.
     * @param {PopFindUniqueArgs} args - Arguments to find a Pop
     * @example
     * // Get one Pop
     * const pop = await prisma.pop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PopFindUniqueArgs>(args: SelectSubset<T, PopFindUniqueArgs<ExtArgs>>): Prisma__PopClient<$Result.GetResult<Prisma.$PopPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pop that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PopFindUniqueOrThrowArgs} args - Arguments to find a Pop
     * @example
     * // Get one Pop
     * const pop = await prisma.pop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PopFindUniqueOrThrowArgs>(args: SelectSubset<T, PopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PopClient<$Result.GetResult<Prisma.$PopPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopFindFirstArgs} args - Arguments to find a Pop
     * @example
     * // Get one Pop
     * const pop = await prisma.pop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PopFindFirstArgs>(args?: SelectSubset<T, PopFindFirstArgs<ExtArgs>>): Prisma__PopClient<$Result.GetResult<Prisma.$PopPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopFindFirstOrThrowArgs} args - Arguments to find a Pop
     * @example
     * // Get one Pop
     * const pop = await prisma.pop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PopFindFirstOrThrowArgs>(args?: SelectSubset<T, PopFindFirstOrThrowArgs<ExtArgs>>): Prisma__PopClient<$Result.GetResult<Prisma.$PopPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pops
     * const pops = await prisma.pop.findMany()
     * 
     * // Get first 10 Pops
     * const pops = await prisma.pop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const popWithIdOnly = await prisma.pop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PopFindManyArgs>(args?: SelectSubset<T, PopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PopPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pop.
     * @param {PopCreateArgs} args - Arguments to create a Pop.
     * @example
     * // Create one Pop
     * const Pop = await prisma.pop.create({
     *   data: {
     *     // ... data to create a Pop
     *   }
     * })
     * 
     */
    create<T extends PopCreateArgs>(args: SelectSubset<T, PopCreateArgs<ExtArgs>>): Prisma__PopClient<$Result.GetResult<Prisma.$PopPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pops.
     * @param {PopCreateManyArgs} args - Arguments to create many Pops.
     * @example
     * // Create many Pops
     * const pop = await prisma.pop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PopCreateManyArgs>(args?: SelectSubset<T, PopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pops and returns the data saved in the database.
     * @param {PopCreateManyAndReturnArgs} args - Arguments to create many Pops.
     * @example
     * // Create many Pops
     * const pop = await prisma.pop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pops and only return the `id`
     * const popWithIdOnly = await prisma.pop.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PopCreateManyAndReturnArgs>(args?: SelectSubset<T, PopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PopPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pop.
     * @param {PopDeleteArgs} args - Arguments to delete one Pop.
     * @example
     * // Delete one Pop
     * const Pop = await prisma.pop.delete({
     *   where: {
     *     // ... filter to delete one Pop
     *   }
     * })
     * 
     */
    delete<T extends PopDeleteArgs>(args: SelectSubset<T, PopDeleteArgs<ExtArgs>>): Prisma__PopClient<$Result.GetResult<Prisma.$PopPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pop.
     * @param {PopUpdateArgs} args - Arguments to update one Pop.
     * @example
     * // Update one Pop
     * const pop = await prisma.pop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PopUpdateArgs>(args: SelectSubset<T, PopUpdateArgs<ExtArgs>>): Prisma__PopClient<$Result.GetResult<Prisma.$PopPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pops.
     * @param {PopDeleteManyArgs} args - Arguments to filter Pops to delete.
     * @example
     * // Delete a few Pops
     * const { count } = await prisma.pop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PopDeleteManyArgs>(args?: SelectSubset<T, PopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pops
     * const pop = await prisma.pop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PopUpdateManyArgs>(args: SelectSubset<T, PopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pop.
     * @param {PopUpsertArgs} args - Arguments to update or create a Pop.
     * @example
     * // Update or create a Pop
     * const pop = await prisma.pop.upsert({
     *   create: {
     *     // ... data to create a Pop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pop we want to update
     *   }
     * })
     */
    upsert<T extends PopUpsertArgs>(args: SelectSubset<T, PopUpsertArgs<ExtArgs>>): Prisma__PopClient<$Result.GetResult<Prisma.$PopPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopCountArgs} args - Arguments to filter Pops to count.
     * @example
     * // Count the number of Pops
     * const count = await prisma.pop.count({
     *   where: {
     *     // ... the filter for the Pops we want to count
     *   }
     * })
    **/
    count<T extends PopCountArgs>(
      args?: Subset<T, PopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PopAggregateArgs>(args: Subset<T, PopAggregateArgs>): Prisma.PrismaPromise<GetPopAggregateType<T>>

    /**
     * Group by Pop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PopGroupByArgs['orderBy'] }
        : { orderBy?: PopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pop model
   */
  readonly fields: PopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends Pop$companyArgs<ExtArgs> = {}>(args?: Subset<T, Pop$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pop model
   */ 
  interface PopFieldRefs {
    readonly id: FieldRef<"Pop", 'String'>
    readonly projectId: FieldRef<"Pop", 'String'>
    readonly name: FieldRef<"Pop", 'String'>
    readonly status: FieldRef<"Pop", 'EquipmentStatus'>
    readonly lat: FieldRef<"Pop", 'Float'>
    readonly lng: FieldRef<"Pop", 'Float'>
    readonly olts: FieldRef<"Pop", 'Json'>
    readonly dios: FieldRef<"Pop", 'Json'>
    readonly fusions: FieldRef<"Pop", 'Json'>
    readonly connections: FieldRef<"Pop", 'Json'>
    readonly inputCableIds: FieldRef<"Pop", 'String[]'>
    readonly layout: FieldRef<"Pop", 'Json'>
    readonly color: FieldRef<"Pop", 'String'>
    readonly size: FieldRef<"Pop", 'Int'>
    readonly companyId: FieldRef<"Pop", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pop findUnique
   */
  export type PopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopInclude<ExtArgs> | null
    /**
     * Filter, which Pop to fetch.
     */
    where: PopWhereUniqueInput
  }

  /**
   * Pop findUniqueOrThrow
   */
  export type PopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopInclude<ExtArgs> | null
    /**
     * Filter, which Pop to fetch.
     */
    where: PopWhereUniqueInput
  }

  /**
   * Pop findFirst
   */
  export type PopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopInclude<ExtArgs> | null
    /**
     * Filter, which Pop to fetch.
     */
    where?: PopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pops to fetch.
     */
    orderBy?: PopOrderByWithRelationInput | PopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pops.
     */
    cursor?: PopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pops.
     */
    distinct?: PopScalarFieldEnum | PopScalarFieldEnum[]
  }

  /**
   * Pop findFirstOrThrow
   */
  export type PopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopInclude<ExtArgs> | null
    /**
     * Filter, which Pop to fetch.
     */
    where?: PopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pops to fetch.
     */
    orderBy?: PopOrderByWithRelationInput | PopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pops.
     */
    cursor?: PopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pops.
     */
    distinct?: PopScalarFieldEnum | PopScalarFieldEnum[]
  }

  /**
   * Pop findMany
   */
  export type PopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopInclude<ExtArgs> | null
    /**
     * Filter, which Pops to fetch.
     */
    where?: PopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pops to fetch.
     */
    orderBy?: PopOrderByWithRelationInput | PopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pops.
     */
    cursor?: PopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pops.
     */
    skip?: number
    distinct?: PopScalarFieldEnum | PopScalarFieldEnum[]
  }

  /**
   * Pop create
   */
  export type PopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopInclude<ExtArgs> | null
    /**
     * The data needed to create a Pop.
     */
    data: XOR<PopCreateInput, PopUncheckedCreateInput>
  }

  /**
   * Pop createMany
   */
  export type PopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pops.
     */
    data: PopCreateManyInput | PopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pop createManyAndReturn
   */
  export type PopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pops.
     */
    data: PopCreateManyInput | PopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pop update
   */
  export type PopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopInclude<ExtArgs> | null
    /**
     * The data needed to update a Pop.
     */
    data: XOR<PopUpdateInput, PopUncheckedUpdateInput>
    /**
     * Choose, which Pop to update.
     */
    where: PopWhereUniqueInput
  }

  /**
   * Pop updateMany
   */
  export type PopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pops.
     */
    data: XOR<PopUpdateManyMutationInput, PopUncheckedUpdateManyInput>
    /**
     * Filter which Pops to update
     */
    where?: PopWhereInput
  }

  /**
   * Pop upsert
   */
  export type PopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopInclude<ExtArgs> | null
    /**
     * The filter to search for the Pop to update in case it exists.
     */
    where: PopWhereUniqueInput
    /**
     * In case the Pop found by the `where` argument doesn't exist, create a new Pop with this data.
     */
    create: XOR<PopCreateInput, PopUncheckedCreateInput>
    /**
     * In case the Pop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PopUpdateInput, PopUncheckedUpdateInput>
  }

  /**
   * Pop delete
   */
  export type PopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopInclude<ExtArgs> | null
    /**
     * Filter which Pop to delete.
     */
    where: PopWhereUniqueInput
  }

  /**
   * Pop deleteMany
   */
  export type PopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pops to delete
     */
    where?: PopWhereInput
  }

  /**
   * Pop.company
   */
  export type Pop$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Pop without action
   */
  export type PopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pop
     */
    select?: PopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopInclude<ExtArgs> | null
  }


  /**
   * Model Cable
   */

  export type AggregateCable = {
    _count: CableCountAggregateOutputType | null
    _avg: CableAvgAggregateOutputType | null
    _sum: CableSumAggregateOutputType | null
    _min: CableMinAggregateOutputType | null
    _max: CableMaxAggregateOutputType | null
  }

  export type CableAvgAggregateOutputType = {
    fiberCount: number | null
    looseTubeCount: number | null
  }

  export type CableSumAggregateOutputType = {
    fiberCount: number | null
    looseTubeCount: number | null
  }

  export type CableMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    status: string | null
    fiberCount: number | null
    looseTubeCount: number | null
    color: string | null
    fromNodeId: string | null
    toNodeId: string | null
    catalogId: string | null
    companyId: string | null
  }

  export type CableMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    status: string | null
    fiberCount: number | null
    looseTubeCount: number | null
    color: string | null
    fromNodeId: string | null
    toNodeId: string | null
    catalogId: string | null
    companyId: string | null
  }

  export type CableCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    status: number
    fiberCount: number
    looseTubeCount: number
    color: number
    coordinates: number
    fromNodeId: number
    toNodeId: number
    catalogId: number
    companyId: number
    _all: number
  }


  export type CableAvgAggregateInputType = {
    fiberCount?: true
    looseTubeCount?: true
  }

  export type CableSumAggregateInputType = {
    fiberCount?: true
    looseTubeCount?: true
  }

  export type CableMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    status?: true
    fiberCount?: true
    looseTubeCount?: true
    color?: true
    fromNodeId?: true
    toNodeId?: true
    catalogId?: true
    companyId?: true
  }

  export type CableMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    status?: true
    fiberCount?: true
    looseTubeCount?: true
    color?: true
    fromNodeId?: true
    toNodeId?: true
    catalogId?: true
    companyId?: true
  }

  export type CableCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    status?: true
    fiberCount?: true
    looseTubeCount?: true
    color?: true
    coordinates?: true
    fromNodeId?: true
    toNodeId?: true
    catalogId?: true
    companyId?: true
    _all?: true
  }

  export type CableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cable to aggregate.
     */
    where?: CableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cables to fetch.
     */
    orderBy?: CableOrderByWithRelationInput | CableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cables
    **/
    _count?: true | CableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CableMaxAggregateInputType
  }

  export type GetCableAggregateType<T extends CableAggregateArgs> = {
        [P in keyof T & keyof AggregateCable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCable[P]>
      : GetScalarType<T[P], AggregateCable[P]>
  }




  export type CableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CableWhereInput
    orderBy?: CableOrderByWithAggregationInput | CableOrderByWithAggregationInput[]
    by: CableScalarFieldEnum[] | CableScalarFieldEnum
    having?: CableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CableCountAggregateInputType | true
    _avg?: CableAvgAggregateInputType
    _sum?: CableSumAggregateInputType
    _min?: CableMinAggregateInputType
    _max?: CableMaxAggregateInputType
  }

  export type CableGroupByOutputType = {
    id: string
    projectId: string
    name: string
    status: string | null
    fiberCount: number
    looseTubeCount: number | null
    color: string | null
    coordinates: JsonValue
    fromNodeId: string | null
    toNodeId: string | null
    catalogId: string | null
    companyId: string | null
    _count: CableCountAggregateOutputType | null
    _avg: CableAvgAggregateOutputType | null
    _sum: CableSumAggregateOutputType | null
    _min: CableMinAggregateOutputType | null
    _max: CableMaxAggregateOutputType | null
  }

  type GetCableGroupByPayload<T extends CableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CableGroupByOutputType[P]>
            : GetScalarType<T[P], CableGroupByOutputType[P]>
        }
      >
    >


  export type CableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    status?: boolean
    fiberCount?: boolean
    looseTubeCount?: boolean
    color?: boolean
    coordinates?: boolean
    fromNodeId?: boolean
    toNodeId?: boolean
    catalogId?: boolean
    companyId?: boolean
    company?: boolean | Cable$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cable"]>

  export type CableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    status?: boolean
    fiberCount?: boolean
    looseTubeCount?: boolean
    color?: boolean
    coordinates?: boolean
    fromNodeId?: boolean
    toNodeId?: boolean
    catalogId?: boolean
    companyId?: boolean
    company?: boolean | Cable$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cable"]>

  export type CableSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    status?: boolean
    fiberCount?: boolean
    looseTubeCount?: boolean
    color?: boolean
    coordinates?: boolean
    fromNodeId?: boolean
    toNodeId?: boolean
    catalogId?: boolean
    companyId?: boolean
  }

  export type CableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Cable$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type CableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Cable$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $CablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cable"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      status: string | null
      fiberCount: number
      looseTubeCount: number | null
      color: string | null
      coordinates: Prisma.JsonValue
      fromNodeId: string | null
      toNodeId: string | null
      catalogId: string | null
      companyId: string | null
    }, ExtArgs["result"]["cable"]>
    composites: {}
  }

  type CableGetPayload<S extends boolean | null | undefined | CableDefaultArgs> = $Result.GetResult<Prisma.$CablePayload, S>

  type CableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CableCountAggregateInputType | true
    }

  export interface CableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cable'], meta: { name: 'Cable' } }
    /**
     * Find zero or one Cable that matches the filter.
     * @param {CableFindUniqueArgs} args - Arguments to find a Cable
     * @example
     * // Get one Cable
     * const cable = await prisma.cable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CableFindUniqueArgs>(args: SelectSubset<T, CableFindUniqueArgs<ExtArgs>>): Prisma__CableClient<$Result.GetResult<Prisma.$CablePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cable that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CableFindUniqueOrThrowArgs} args - Arguments to find a Cable
     * @example
     * // Get one Cable
     * const cable = await prisma.cable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CableFindUniqueOrThrowArgs>(args: SelectSubset<T, CableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CableClient<$Result.GetResult<Prisma.$CablePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CableFindFirstArgs} args - Arguments to find a Cable
     * @example
     * // Get one Cable
     * const cable = await prisma.cable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CableFindFirstArgs>(args?: SelectSubset<T, CableFindFirstArgs<ExtArgs>>): Prisma__CableClient<$Result.GetResult<Prisma.$CablePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CableFindFirstOrThrowArgs} args - Arguments to find a Cable
     * @example
     * // Get one Cable
     * const cable = await prisma.cable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CableFindFirstOrThrowArgs>(args?: SelectSubset<T, CableFindFirstOrThrowArgs<ExtArgs>>): Prisma__CableClient<$Result.GetResult<Prisma.$CablePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cables
     * const cables = await prisma.cable.findMany()
     * 
     * // Get first 10 Cables
     * const cables = await prisma.cable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cableWithIdOnly = await prisma.cable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CableFindManyArgs>(args?: SelectSubset<T, CableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CablePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cable.
     * @param {CableCreateArgs} args - Arguments to create a Cable.
     * @example
     * // Create one Cable
     * const Cable = await prisma.cable.create({
     *   data: {
     *     // ... data to create a Cable
     *   }
     * })
     * 
     */
    create<T extends CableCreateArgs>(args: SelectSubset<T, CableCreateArgs<ExtArgs>>): Prisma__CableClient<$Result.GetResult<Prisma.$CablePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cables.
     * @param {CableCreateManyArgs} args - Arguments to create many Cables.
     * @example
     * // Create many Cables
     * const cable = await prisma.cable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CableCreateManyArgs>(args?: SelectSubset<T, CableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cables and returns the data saved in the database.
     * @param {CableCreateManyAndReturnArgs} args - Arguments to create many Cables.
     * @example
     * // Create many Cables
     * const cable = await prisma.cable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cables and only return the `id`
     * const cableWithIdOnly = await prisma.cable.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CableCreateManyAndReturnArgs>(args?: SelectSubset<T, CableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CablePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cable.
     * @param {CableDeleteArgs} args - Arguments to delete one Cable.
     * @example
     * // Delete one Cable
     * const Cable = await prisma.cable.delete({
     *   where: {
     *     // ... filter to delete one Cable
     *   }
     * })
     * 
     */
    delete<T extends CableDeleteArgs>(args: SelectSubset<T, CableDeleteArgs<ExtArgs>>): Prisma__CableClient<$Result.GetResult<Prisma.$CablePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cable.
     * @param {CableUpdateArgs} args - Arguments to update one Cable.
     * @example
     * // Update one Cable
     * const cable = await prisma.cable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CableUpdateArgs>(args: SelectSubset<T, CableUpdateArgs<ExtArgs>>): Prisma__CableClient<$Result.GetResult<Prisma.$CablePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cables.
     * @param {CableDeleteManyArgs} args - Arguments to filter Cables to delete.
     * @example
     * // Delete a few Cables
     * const { count } = await prisma.cable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CableDeleteManyArgs>(args?: SelectSubset<T, CableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cables
     * const cable = await prisma.cable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CableUpdateManyArgs>(args: SelectSubset<T, CableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cable.
     * @param {CableUpsertArgs} args - Arguments to update or create a Cable.
     * @example
     * // Update or create a Cable
     * const cable = await prisma.cable.upsert({
     *   create: {
     *     // ... data to create a Cable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cable we want to update
     *   }
     * })
     */
    upsert<T extends CableUpsertArgs>(args: SelectSubset<T, CableUpsertArgs<ExtArgs>>): Prisma__CableClient<$Result.GetResult<Prisma.$CablePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CableCountArgs} args - Arguments to filter Cables to count.
     * @example
     * // Count the number of Cables
     * const count = await prisma.cable.count({
     *   where: {
     *     // ... the filter for the Cables we want to count
     *   }
     * })
    **/
    count<T extends CableCountArgs>(
      args?: Subset<T, CableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CableAggregateArgs>(args: Subset<T, CableAggregateArgs>): Prisma.PrismaPromise<GetCableAggregateType<T>>

    /**
     * Group by Cable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CableGroupByArgs['orderBy'] }
        : { orderBy?: CableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cable model
   */
  readonly fields: CableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends Cable$companyArgs<ExtArgs> = {}>(args?: Subset<T, Cable$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cable model
   */ 
  interface CableFieldRefs {
    readonly id: FieldRef<"Cable", 'String'>
    readonly projectId: FieldRef<"Cable", 'String'>
    readonly name: FieldRef<"Cable", 'String'>
    readonly status: FieldRef<"Cable", 'String'>
    readonly fiberCount: FieldRef<"Cable", 'Int'>
    readonly looseTubeCount: FieldRef<"Cable", 'Int'>
    readonly color: FieldRef<"Cable", 'String'>
    readonly coordinates: FieldRef<"Cable", 'Json'>
    readonly fromNodeId: FieldRef<"Cable", 'String'>
    readonly toNodeId: FieldRef<"Cable", 'String'>
    readonly catalogId: FieldRef<"Cable", 'String'>
    readonly companyId: FieldRef<"Cable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cable findUnique
   */
  export type CableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableInclude<ExtArgs> | null
    /**
     * Filter, which Cable to fetch.
     */
    where: CableWhereUniqueInput
  }

  /**
   * Cable findUniqueOrThrow
   */
  export type CableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableInclude<ExtArgs> | null
    /**
     * Filter, which Cable to fetch.
     */
    where: CableWhereUniqueInput
  }

  /**
   * Cable findFirst
   */
  export type CableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableInclude<ExtArgs> | null
    /**
     * Filter, which Cable to fetch.
     */
    where?: CableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cables to fetch.
     */
    orderBy?: CableOrderByWithRelationInput | CableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cables.
     */
    cursor?: CableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cables.
     */
    distinct?: CableScalarFieldEnum | CableScalarFieldEnum[]
  }

  /**
   * Cable findFirstOrThrow
   */
  export type CableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableInclude<ExtArgs> | null
    /**
     * Filter, which Cable to fetch.
     */
    where?: CableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cables to fetch.
     */
    orderBy?: CableOrderByWithRelationInput | CableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cables.
     */
    cursor?: CableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cables.
     */
    distinct?: CableScalarFieldEnum | CableScalarFieldEnum[]
  }

  /**
   * Cable findMany
   */
  export type CableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableInclude<ExtArgs> | null
    /**
     * Filter, which Cables to fetch.
     */
    where?: CableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cables to fetch.
     */
    orderBy?: CableOrderByWithRelationInput | CableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cables.
     */
    cursor?: CableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cables.
     */
    skip?: number
    distinct?: CableScalarFieldEnum | CableScalarFieldEnum[]
  }

  /**
   * Cable create
   */
  export type CableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableInclude<ExtArgs> | null
    /**
     * The data needed to create a Cable.
     */
    data: XOR<CableCreateInput, CableUncheckedCreateInput>
  }

  /**
   * Cable createMany
   */
  export type CableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cables.
     */
    data: CableCreateManyInput | CableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cable createManyAndReturn
   */
  export type CableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cables.
     */
    data: CableCreateManyInput | CableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cable update
   */
  export type CableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableInclude<ExtArgs> | null
    /**
     * The data needed to update a Cable.
     */
    data: XOR<CableUpdateInput, CableUncheckedUpdateInput>
    /**
     * Choose, which Cable to update.
     */
    where: CableWhereUniqueInput
  }

  /**
   * Cable updateMany
   */
  export type CableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cables.
     */
    data: XOR<CableUpdateManyMutationInput, CableUncheckedUpdateManyInput>
    /**
     * Filter which Cables to update
     */
    where?: CableWhereInput
  }

  /**
   * Cable upsert
   */
  export type CableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableInclude<ExtArgs> | null
    /**
     * The filter to search for the Cable to update in case it exists.
     */
    where: CableWhereUniqueInput
    /**
     * In case the Cable found by the `where` argument doesn't exist, create a new Cable with this data.
     */
    create: XOR<CableCreateInput, CableUncheckedCreateInput>
    /**
     * In case the Cable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CableUpdateInput, CableUncheckedUpdateInput>
  }

  /**
   * Cable delete
   */
  export type CableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableInclude<ExtArgs> | null
    /**
     * Filter which Cable to delete.
     */
    where: CableWhereUniqueInput
  }

  /**
   * Cable deleteMany
   */
  export type CableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cables to delete
     */
    where?: CableWhereInput
  }

  /**
   * Cable.company
   */
  export type Cable$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Cable without action
   */
  export type CableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cable
     */
    select?: CableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CableInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    userId: string | null
    companyId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    userId: string | null
    companyId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    entity: number
    entityId: number
    details: number
    userId: number
    companyId: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    entityId?: true
    userId?: true
    companyId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    entityId?: true
    userId?: true
    companyId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    entityId?: true
    details?: true
    userId?: true
    companyId?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: string
    entity: string
    entityId: string
    details: JsonValue | null
    userId: string | null
    companyId: string | null
    ipAddress: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    userId?: boolean
    companyId?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    userId?: boolean
    companyId?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    userId?: boolean
    companyId?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      entity: string
      entityId: string
      details: Prisma.JsonValue | null
      userId: string | null
      companyId: string | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly companyId: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model CatalogSplitter
   */

  export type AggregateCatalogSplitter = {
    _count: CatalogSplitterCountAggregateOutputType | null
    _avg: CatalogSplitterAvgAggregateOutputType | null
    _sum: CatalogSplitterSumAggregateOutputType | null
    _min: CatalogSplitterMinAggregateOutputType | null
    _max: CatalogSplitterMaxAggregateOutputType | null
  }

  export type CatalogSplitterAvgAggregateOutputType = {
    inputs: number | null
    outputs: number | null
  }

  export type CatalogSplitterSumAggregateOutputType = {
    inputs: number | null
    outputs: number | null
  }

  export type CatalogSplitterMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    mode: string | null
    inputs: number | null
    outputs: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CatalogSplitterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    mode: string | null
    inputs: number | null
    outputs: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CatalogSplitterCountAggregateOutputType = {
    id: number
    name: number
    type: number
    mode: number
    inputs: number
    outputs: number
    attenuation: number
    description: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type CatalogSplitterAvgAggregateInputType = {
    inputs?: true
    outputs?: true
  }

  export type CatalogSplitterSumAggregateInputType = {
    inputs?: true
    outputs?: true
  }

  export type CatalogSplitterMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    mode?: true
    inputs?: true
    outputs?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CatalogSplitterMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    mode?: true
    inputs?: true
    outputs?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CatalogSplitterCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    mode?: true
    inputs?: true
    outputs?: true
    attenuation?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type CatalogSplitterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogSplitter to aggregate.
     */
    where?: CatalogSplitterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogSplitters to fetch.
     */
    orderBy?: CatalogSplitterOrderByWithRelationInput | CatalogSplitterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogSplitterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogSplitters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogSplitters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogSplitters
    **/
    _count?: true | CatalogSplitterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogSplitterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogSplitterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogSplitterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogSplitterMaxAggregateInputType
  }

  export type GetCatalogSplitterAggregateType<T extends CatalogSplitterAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogSplitter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogSplitter[P]>
      : GetScalarType<T[P], AggregateCatalogSplitter[P]>
  }




  export type CatalogSplitterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogSplitterWhereInput
    orderBy?: CatalogSplitterOrderByWithAggregationInput | CatalogSplitterOrderByWithAggregationInput[]
    by: CatalogSplitterScalarFieldEnum[] | CatalogSplitterScalarFieldEnum
    having?: CatalogSplitterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogSplitterCountAggregateInputType | true
    _avg?: CatalogSplitterAvgAggregateInputType
    _sum?: CatalogSplitterSumAggregateInputType
    _min?: CatalogSplitterMinAggregateInputType
    _max?: CatalogSplitterMaxAggregateInputType
  }

  export type CatalogSplitterGroupByOutputType = {
    id: string
    name: string
    type: string
    mode: string
    inputs: number
    outputs: number
    attenuation: JsonValue | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string | null
    _count: CatalogSplitterCountAggregateOutputType | null
    _avg: CatalogSplitterAvgAggregateOutputType | null
    _sum: CatalogSplitterSumAggregateOutputType | null
    _min: CatalogSplitterMinAggregateOutputType | null
    _max: CatalogSplitterMaxAggregateOutputType | null
  }

  type GetCatalogSplitterGroupByPayload<T extends CatalogSplitterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogSplitterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogSplitterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogSplitterGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogSplitterGroupByOutputType[P]>
        }
      >
    >


  export type CatalogSplitterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    mode?: boolean
    inputs?: boolean
    outputs?: boolean
    attenuation?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CatalogSplitter$companyArgs<ExtArgs>
  }, ExtArgs["result"]["catalogSplitter"]>

  export type CatalogSplitterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    mode?: boolean
    inputs?: boolean
    outputs?: boolean
    attenuation?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CatalogSplitter$companyArgs<ExtArgs>
  }, ExtArgs["result"]["catalogSplitter"]>

  export type CatalogSplitterSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    mode?: boolean
    inputs?: boolean
    outputs?: boolean
    attenuation?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type CatalogSplitterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CatalogSplitter$companyArgs<ExtArgs>
  }
  export type CatalogSplitterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CatalogSplitter$companyArgs<ExtArgs>
  }

  export type $CatalogSplitterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogSplitter"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      mode: string
      inputs: number
      outputs: number
      attenuation: Prisma.JsonValue | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string | null
    }, ExtArgs["result"]["catalogSplitter"]>
    composites: {}
  }

  type CatalogSplitterGetPayload<S extends boolean | null | undefined | CatalogSplitterDefaultArgs> = $Result.GetResult<Prisma.$CatalogSplitterPayload, S>

  type CatalogSplitterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogSplitterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogSplitterCountAggregateInputType | true
    }

  export interface CatalogSplitterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogSplitter'], meta: { name: 'CatalogSplitter' } }
    /**
     * Find zero or one CatalogSplitter that matches the filter.
     * @param {CatalogSplitterFindUniqueArgs} args - Arguments to find a CatalogSplitter
     * @example
     * // Get one CatalogSplitter
     * const catalogSplitter = await prisma.catalogSplitter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogSplitterFindUniqueArgs>(args: SelectSubset<T, CatalogSplitterFindUniqueArgs<ExtArgs>>): Prisma__CatalogSplitterClient<$Result.GetResult<Prisma.$CatalogSplitterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatalogSplitter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogSplitterFindUniqueOrThrowArgs} args - Arguments to find a CatalogSplitter
     * @example
     * // Get one CatalogSplitter
     * const catalogSplitter = await prisma.catalogSplitter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogSplitterFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogSplitterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogSplitterClient<$Result.GetResult<Prisma.$CatalogSplitterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatalogSplitter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogSplitterFindFirstArgs} args - Arguments to find a CatalogSplitter
     * @example
     * // Get one CatalogSplitter
     * const catalogSplitter = await prisma.catalogSplitter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogSplitterFindFirstArgs>(args?: SelectSubset<T, CatalogSplitterFindFirstArgs<ExtArgs>>): Prisma__CatalogSplitterClient<$Result.GetResult<Prisma.$CatalogSplitterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatalogSplitter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogSplitterFindFirstOrThrowArgs} args - Arguments to find a CatalogSplitter
     * @example
     * // Get one CatalogSplitter
     * const catalogSplitter = await prisma.catalogSplitter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogSplitterFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogSplitterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogSplitterClient<$Result.GetResult<Prisma.$CatalogSplitterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatalogSplitters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogSplitterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogSplitters
     * const catalogSplitters = await prisma.catalogSplitter.findMany()
     * 
     * // Get first 10 CatalogSplitters
     * const catalogSplitters = await prisma.catalogSplitter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogSplitterWithIdOnly = await prisma.catalogSplitter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogSplitterFindManyArgs>(args?: SelectSubset<T, CatalogSplitterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogSplitterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatalogSplitter.
     * @param {CatalogSplitterCreateArgs} args - Arguments to create a CatalogSplitter.
     * @example
     * // Create one CatalogSplitter
     * const CatalogSplitter = await prisma.catalogSplitter.create({
     *   data: {
     *     // ... data to create a CatalogSplitter
     *   }
     * })
     * 
     */
    create<T extends CatalogSplitterCreateArgs>(args: SelectSubset<T, CatalogSplitterCreateArgs<ExtArgs>>): Prisma__CatalogSplitterClient<$Result.GetResult<Prisma.$CatalogSplitterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatalogSplitters.
     * @param {CatalogSplitterCreateManyArgs} args - Arguments to create many CatalogSplitters.
     * @example
     * // Create many CatalogSplitters
     * const catalogSplitter = await prisma.catalogSplitter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogSplitterCreateManyArgs>(args?: SelectSubset<T, CatalogSplitterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogSplitters and returns the data saved in the database.
     * @param {CatalogSplitterCreateManyAndReturnArgs} args - Arguments to create many CatalogSplitters.
     * @example
     * // Create many CatalogSplitters
     * const catalogSplitter = await prisma.catalogSplitter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogSplitters and only return the `id`
     * const catalogSplitterWithIdOnly = await prisma.catalogSplitter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatalogSplitterCreateManyAndReturnArgs>(args?: SelectSubset<T, CatalogSplitterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogSplitterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CatalogSplitter.
     * @param {CatalogSplitterDeleteArgs} args - Arguments to delete one CatalogSplitter.
     * @example
     * // Delete one CatalogSplitter
     * const CatalogSplitter = await prisma.catalogSplitter.delete({
     *   where: {
     *     // ... filter to delete one CatalogSplitter
     *   }
     * })
     * 
     */
    delete<T extends CatalogSplitterDeleteArgs>(args: SelectSubset<T, CatalogSplitterDeleteArgs<ExtArgs>>): Prisma__CatalogSplitterClient<$Result.GetResult<Prisma.$CatalogSplitterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatalogSplitter.
     * @param {CatalogSplitterUpdateArgs} args - Arguments to update one CatalogSplitter.
     * @example
     * // Update one CatalogSplitter
     * const catalogSplitter = await prisma.catalogSplitter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogSplitterUpdateArgs>(args: SelectSubset<T, CatalogSplitterUpdateArgs<ExtArgs>>): Prisma__CatalogSplitterClient<$Result.GetResult<Prisma.$CatalogSplitterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatalogSplitters.
     * @param {CatalogSplitterDeleteManyArgs} args - Arguments to filter CatalogSplitters to delete.
     * @example
     * // Delete a few CatalogSplitters
     * const { count } = await prisma.catalogSplitter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogSplitterDeleteManyArgs>(args?: SelectSubset<T, CatalogSplitterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogSplitters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogSplitterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogSplitters
     * const catalogSplitter = await prisma.catalogSplitter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogSplitterUpdateManyArgs>(args: SelectSubset<T, CatalogSplitterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogSplitter.
     * @param {CatalogSplitterUpsertArgs} args - Arguments to update or create a CatalogSplitter.
     * @example
     * // Update or create a CatalogSplitter
     * const catalogSplitter = await prisma.catalogSplitter.upsert({
     *   create: {
     *     // ... data to create a CatalogSplitter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogSplitter we want to update
     *   }
     * })
     */
    upsert<T extends CatalogSplitterUpsertArgs>(args: SelectSubset<T, CatalogSplitterUpsertArgs<ExtArgs>>): Prisma__CatalogSplitterClient<$Result.GetResult<Prisma.$CatalogSplitterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatalogSplitters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogSplitterCountArgs} args - Arguments to filter CatalogSplitters to count.
     * @example
     * // Count the number of CatalogSplitters
     * const count = await prisma.catalogSplitter.count({
     *   where: {
     *     // ... the filter for the CatalogSplitters we want to count
     *   }
     * })
    **/
    count<T extends CatalogSplitterCountArgs>(
      args?: Subset<T, CatalogSplitterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogSplitterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogSplitter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogSplitterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogSplitterAggregateArgs>(args: Subset<T, CatalogSplitterAggregateArgs>): Prisma.PrismaPromise<GetCatalogSplitterAggregateType<T>>

    /**
     * Group by CatalogSplitter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogSplitterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogSplitterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogSplitterGroupByArgs['orderBy'] }
        : { orderBy?: CatalogSplitterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogSplitterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogSplitterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogSplitter model
   */
  readonly fields: CatalogSplitterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogSplitter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogSplitterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CatalogSplitter$companyArgs<ExtArgs> = {}>(args?: Subset<T, CatalogSplitter$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatalogSplitter model
   */ 
  interface CatalogSplitterFieldRefs {
    readonly id: FieldRef<"CatalogSplitter", 'String'>
    readonly name: FieldRef<"CatalogSplitter", 'String'>
    readonly type: FieldRef<"CatalogSplitter", 'String'>
    readonly mode: FieldRef<"CatalogSplitter", 'String'>
    readonly inputs: FieldRef<"CatalogSplitter", 'Int'>
    readonly outputs: FieldRef<"CatalogSplitter", 'Int'>
    readonly attenuation: FieldRef<"CatalogSplitter", 'Json'>
    readonly description: FieldRef<"CatalogSplitter", 'String'>
    readonly createdAt: FieldRef<"CatalogSplitter", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogSplitter", 'DateTime'>
    readonly companyId: FieldRef<"CatalogSplitter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CatalogSplitter findUnique
   */
  export type CatalogSplitterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogSplitter
     */
    select?: CatalogSplitterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogSplitterInclude<ExtArgs> | null
    /**
     * Filter, which CatalogSplitter to fetch.
     */
    where: CatalogSplitterWhereUniqueInput
  }

  /**
   * CatalogSplitter findUniqueOrThrow
   */
  export type CatalogSplitterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogSplitter
     */
    select?: CatalogSplitterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogSplitterInclude<ExtArgs> | null
    /**
     * Filter, which CatalogSplitter to fetch.
     */
    where: CatalogSplitterWhereUniqueInput
  }

  /**
   * CatalogSplitter findFirst
   */
  export type CatalogSplitterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogSplitter
     */
    select?: CatalogSplitterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogSplitterInclude<ExtArgs> | null
    /**
     * Filter, which CatalogSplitter to fetch.
     */
    where?: CatalogSplitterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogSplitters to fetch.
     */
    orderBy?: CatalogSplitterOrderByWithRelationInput | CatalogSplitterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogSplitters.
     */
    cursor?: CatalogSplitterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogSplitters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogSplitters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogSplitters.
     */
    distinct?: CatalogSplitterScalarFieldEnum | CatalogSplitterScalarFieldEnum[]
  }

  /**
   * CatalogSplitter findFirstOrThrow
   */
  export type CatalogSplitterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogSplitter
     */
    select?: CatalogSplitterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogSplitterInclude<ExtArgs> | null
    /**
     * Filter, which CatalogSplitter to fetch.
     */
    where?: CatalogSplitterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogSplitters to fetch.
     */
    orderBy?: CatalogSplitterOrderByWithRelationInput | CatalogSplitterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogSplitters.
     */
    cursor?: CatalogSplitterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogSplitters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogSplitters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogSplitters.
     */
    distinct?: CatalogSplitterScalarFieldEnum | CatalogSplitterScalarFieldEnum[]
  }

  /**
   * CatalogSplitter findMany
   */
  export type CatalogSplitterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogSplitter
     */
    select?: CatalogSplitterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogSplitterInclude<ExtArgs> | null
    /**
     * Filter, which CatalogSplitters to fetch.
     */
    where?: CatalogSplitterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogSplitters to fetch.
     */
    orderBy?: CatalogSplitterOrderByWithRelationInput | CatalogSplitterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogSplitters.
     */
    cursor?: CatalogSplitterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogSplitters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogSplitters.
     */
    skip?: number
    distinct?: CatalogSplitterScalarFieldEnum | CatalogSplitterScalarFieldEnum[]
  }

  /**
   * CatalogSplitter create
   */
  export type CatalogSplitterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogSplitter
     */
    select?: CatalogSplitterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogSplitterInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogSplitter.
     */
    data: XOR<CatalogSplitterCreateInput, CatalogSplitterUncheckedCreateInput>
  }

  /**
   * CatalogSplitter createMany
   */
  export type CatalogSplitterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogSplitters.
     */
    data: CatalogSplitterCreateManyInput | CatalogSplitterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogSplitter createManyAndReturn
   */
  export type CatalogSplitterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogSplitter
     */
    select?: CatalogSplitterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CatalogSplitters.
     */
    data: CatalogSplitterCreateManyInput | CatalogSplitterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogSplitterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatalogSplitter update
   */
  export type CatalogSplitterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogSplitter
     */
    select?: CatalogSplitterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogSplitterInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogSplitter.
     */
    data: XOR<CatalogSplitterUpdateInput, CatalogSplitterUncheckedUpdateInput>
    /**
     * Choose, which CatalogSplitter to update.
     */
    where: CatalogSplitterWhereUniqueInput
  }

  /**
   * CatalogSplitter updateMany
   */
  export type CatalogSplitterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogSplitters.
     */
    data: XOR<CatalogSplitterUpdateManyMutationInput, CatalogSplitterUncheckedUpdateManyInput>
    /**
     * Filter which CatalogSplitters to update
     */
    where?: CatalogSplitterWhereInput
  }

  /**
   * CatalogSplitter upsert
   */
  export type CatalogSplitterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogSplitter
     */
    select?: CatalogSplitterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogSplitterInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogSplitter to update in case it exists.
     */
    where: CatalogSplitterWhereUniqueInput
    /**
     * In case the CatalogSplitter found by the `where` argument doesn't exist, create a new CatalogSplitter with this data.
     */
    create: XOR<CatalogSplitterCreateInput, CatalogSplitterUncheckedCreateInput>
    /**
     * In case the CatalogSplitter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogSplitterUpdateInput, CatalogSplitterUncheckedUpdateInput>
  }

  /**
   * CatalogSplitter delete
   */
  export type CatalogSplitterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogSplitter
     */
    select?: CatalogSplitterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogSplitterInclude<ExtArgs> | null
    /**
     * Filter which CatalogSplitter to delete.
     */
    where: CatalogSplitterWhereUniqueInput
  }

  /**
   * CatalogSplitter deleteMany
   */
  export type CatalogSplitterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogSplitters to delete
     */
    where?: CatalogSplitterWhereInput
  }

  /**
   * CatalogSplitter.company
   */
  export type CatalogSplitter$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * CatalogSplitter without action
   */
  export type CatalogSplitterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogSplitter
     */
    select?: CatalogSplitterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogSplitterInclude<ExtArgs> | null
  }


  /**
   * Model TemplateSplitter
   */

  export type AggregateTemplateSplitter = {
    _count: TemplateSplitterCountAggregateOutputType | null
    _avg: TemplateSplitterAvgAggregateOutputType | null
    _sum: TemplateSplitterSumAggregateOutputType | null
    _min: TemplateSplitterMinAggregateOutputType | null
    _max: TemplateSplitterMaxAggregateOutputType | null
  }

  export type TemplateSplitterAvgAggregateOutputType = {
    inputs: number | null
    outputs: number | null
  }

  export type TemplateSplitterSumAggregateOutputType = {
    inputs: number | null
    outputs: number | null
  }

  export type TemplateSplitterMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    mode: string | null
    inputs: number | null
    outputs: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateSplitterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    mode: string | null
    inputs: number | null
    outputs: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateSplitterCountAggregateOutputType = {
    id: number
    name: number
    type: number
    mode: number
    inputs: number
    outputs: number
    attenuation: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateSplitterAvgAggregateInputType = {
    inputs?: true
    outputs?: true
  }

  export type TemplateSplitterSumAggregateInputType = {
    inputs?: true
    outputs?: true
  }

  export type TemplateSplitterMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    mode?: true
    inputs?: true
    outputs?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateSplitterMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    mode?: true
    inputs?: true
    outputs?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateSplitterCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    mode?: true
    inputs?: true
    outputs?: true
    attenuation?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateSplitterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateSplitter to aggregate.
     */
    where?: TemplateSplitterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateSplitters to fetch.
     */
    orderBy?: TemplateSplitterOrderByWithRelationInput | TemplateSplitterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateSplitterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateSplitters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateSplitters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateSplitters
    **/
    _count?: true | TemplateSplitterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateSplitterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateSplitterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateSplitterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateSplitterMaxAggregateInputType
  }

  export type GetTemplateSplitterAggregateType<T extends TemplateSplitterAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateSplitter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateSplitter[P]>
      : GetScalarType<T[P], AggregateTemplateSplitter[P]>
  }




  export type TemplateSplitterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateSplitterWhereInput
    orderBy?: TemplateSplitterOrderByWithAggregationInput | TemplateSplitterOrderByWithAggregationInput[]
    by: TemplateSplitterScalarFieldEnum[] | TemplateSplitterScalarFieldEnum
    having?: TemplateSplitterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateSplitterCountAggregateInputType | true
    _avg?: TemplateSplitterAvgAggregateInputType
    _sum?: TemplateSplitterSumAggregateInputType
    _min?: TemplateSplitterMinAggregateInputType
    _max?: TemplateSplitterMaxAggregateInputType
  }

  export type TemplateSplitterGroupByOutputType = {
    id: string
    name: string
    type: string
    mode: string
    inputs: number
    outputs: number
    attenuation: JsonValue | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TemplateSplitterCountAggregateOutputType | null
    _avg: TemplateSplitterAvgAggregateOutputType | null
    _sum: TemplateSplitterSumAggregateOutputType | null
    _min: TemplateSplitterMinAggregateOutputType | null
    _max: TemplateSplitterMaxAggregateOutputType | null
  }

  type GetTemplateSplitterGroupByPayload<T extends TemplateSplitterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateSplitterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateSplitterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateSplitterGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateSplitterGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSplitterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    mode?: boolean
    inputs?: boolean
    outputs?: boolean
    attenuation?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templateSplitter"]>

  export type TemplateSplitterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    mode?: boolean
    inputs?: boolean
    outputs?: boolean
    attenuation?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templateSplitter"]>

  export type TemplateSplitterSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    mode?: boolean
    inputs?: boolean
    outputs?: boolean
    attenuation?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TemplateSplitterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateSplitter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      mode: string
      inputs: number
      outputs: number
      attenuation: Prisma.JsonValue | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["templateSplitter"]>
    composites: {}
  }

  type TemplateSplitterGetPayload<S extends boolean | null | undefined | TemplateSplitterDefaultArgs> = $Result.GetResult<Prisma.$TemplateSplitterPayload, S>

  type TemplateSplitterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateSplitterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateSplitterCountAggregateInputType | true
    }

  export interface TemplateSplitterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateSplitter'], meta: { name: 'TemplateSplitter' } }
    /**
     * Find zero or one TemplateSplitter that matches the filter.
     * @param {TemplateSplitterFindUniqueArgs} args - Arguments to find a TemplateSplitter
     * @example
     * // Get one TemplateSplitter
     * const templateSplitter = await prisma.templateSplitter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateSplitterFindUniqueArgs>(args: SelectSubset<T, TemplateSplitterFindUniqueArgs<ExtArgs>>): Prisma__TemplateSplitterClient<$Result.GetResult<Prisma.$TemplateSplitterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TemplateSplitter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TemplateSplitterFindUniqueOrThrowArgs} args - Arguments to find a TemplateSplitter
     * @example
     * // Get one TemplateSplitter
     * const templateSplitter = await prisma.templateSplitter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateSplitterFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateSplitterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateSplitterClient<$Result.GetResult<Prisma.$TemplateSplitterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TemplateSplitter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSplitterFindFirstArgs} args - Arguments to find a TemplateSplitter
     * @example
     * // Get one TemplateSplitter
     * const templateSplitter = await prisma.templateSplitter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateSplitterFindFirstArgs>(args?: SelectSubset<T, TemplateSplitterFindFirstArgs<ExtArgs>>): Prisma__TemplateSplitterClient<$Result.GetResult<Prisma.$TemplateSplitterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TemplateSplitter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSplitterFindFirstOrThrowArgs} args - Arguments to find a TemplateSplitter
     * @example
     * // Get one TemplateSplitter
     * const templateSplitter = await prisma.templateSplitter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateSplitterFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateSplitterFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateSplitterClient<$Result.GetResult<Prisma.$TemplateSplitterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TemplateSplitters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSplitterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateSplitters
     * const templateSplitters = await prisma.templateSplitter.findMany()
     * 
     * // Get first 10 TemplateSplitters
     * const templateSplitters = await prisma.templateSplitter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateSplitterWithIdOnly = await prisma.templateSplitter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateSplitterFindManyArgs>(args?: SelectSubset<T, TemplateSplitterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateSplitterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TemplateSplitter.
     * @param {TemplateSplitterCreateArgs} args - Arguments to create a TemplateSplitter.
     * @example
     * // Create one TemplateSplitter
     * const TemplateSplitter = await prisma.templateSplitter.create({
     *   data: {
     *     // ... data to create a TemplateSplitter
     *   }
     * })
     * 
     */
    create<T extends TemplateSplitterCreateArgs>(args: SelectSubset<T, TemplateSplitterCreateArgs<ExtArgs>>): Prisma__TemplateSplitterClient<$Result.GetResult<Prisma.$TemplateSplitterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TemplateSplitters.
     * @param {TemplateSplitterCreateManyArgs} args - Arguments to create many TemplateSplitters.
     * @example
     * // Create many TemplateSplitters
     * const templateSplitter = await prisma.templateSplitter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateSplitterCreateManyArgs>(args?: SelectSubset<T, TemplateSplitterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateSplitters and returns the data saved in the database.
     * @param {TemplateSplitterCreateManyAndReturnArgs} args - Arguments to create many TemplateSplitters.
     * @example
     * // Create many TemplateSplitters
     * const templateSplitter = await prisma.templateSplitter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateSplitters and only return the `id`
     * const templateSplitterWithIdOnly = await prisma.templateSplitter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateSplitterCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateSplitterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateSplitterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TemplateSplitter.
     * @param {TemplateSplitterDeleteArgs} args - Arguments to delete one TemplateSplitter.
     * @example
     * // Delete one TemplateSplitter
     * const TemplateSplitter = await prisma.templateSplitter.delete({
     *   where: {
     *     // ... filter to delete one TemplateSplitter
     *   }
     * })
     * 
     */
    delete<T extends TemplateSplitterDeleteArgs>(args: SelectSubset<T, TemplateSplitterDeleteArgs<ExtArgs>>): Prisma__TemplateSplitterClient<$Result.GetResult<Prisma.$TemplateSplitterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TemplateSplitter.
     * @param {TemplateSplitterUpdateArgs} args - Arguments to update one TemplateSplitter.
     * @example
     * // Update one TemplateSplitter
     * const templateSplitter = await prisma.templateSplitter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateSplitterUpdateArgs>(args: SelectSubset<T, TemplateSplitterUpdateArgs<ExtArgs>>): Prisma__TemplateSplitterClient<$Result.GetResult<Prisma.$TemplateSplitterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TemplateSplitters.
     * @param {TemplateSplitterDeleteManyArgs} args - Arguments to filter TemplateSplitters to delete.
     * @example
     * // Delete a few TemplateSplitters
     * const { count } = await prisma.templateSplitter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateSplitterDeleteManyArgs>(args?: SelectSubset<T, TemplateSplitterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateSplitters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSplitterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateSplitters
     * const templateSplitter = await prisma.templateSplitter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateSplitterUpdateManyArgs>(args: SelectSubset<T, TemplateSplitterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateSplitter.
     * @param {TemplateSplitterUpsertArgs} args - Arguments to update or create a TemplateSplitter.
     * @example
     * // Update or create a TemplateSplitter
     * const templateSplitter = await prisma.templateSplitter.upsert({
     *   create: {
     *     // ... data to create a TemplateSplitter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateSplitter we want to update
     *   }
     * })
     */
    upsert<T extends TemplateSplitterUpsertArgs>(args: SelectSubset<T, TemplateSplitterUpsertArgs<ExtArgs>>): Prisma__TemplateSplitterClient<$Result.GetResult<Prisma.$TemplateSplitterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TemplateSplitters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSplitterCountArgs} args - Arguments to filter TemplateSplitters to count.
     * @example
     * // Count the number of TemplateSplitters
     * const count = await prisma.templateSplitter.count({
     *   where: {
     *     // ... the filter for the TemplateSplitters we want to count
     *   }
     * })
    **/
    count<T extends TemplateSplitterCountArgs>(
      args?: Subset<T, TemplateSplitterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateSplitterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateSplitter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSplitterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateSplitterAggregateArgs>(args: Subset<T, TemplateSplitterAggregateArgs>): Prisma.PrismaPromise<GetTemplateSplitterAggregateType<T>>

    /**
     * Group by TemplateSplitter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSplitterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateSplitterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateSplitterGroupByArgs['orderBy'] }
        : { orderBy?: TemplateSplitterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateSplitterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateSplitterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateSplitter model
   */
  readonly fields: TemplateSplitterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateSplitter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateSplitterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateSplitter model
   */ 
  interface TemplateSplitterFieldRefs {
    readonly id: FieldRef<"TemplateSplitter", 'String'>
    readonly name: FieldRef<"TemplateSplitter", 'String'>
    readonly type: FieldRef<"TemplateSplitter", 'String'>
    readonly mode: FieldRef<"TemplateSplitter", 'String'>
    readonly inputs: FieldRef<"TemplateSplitter", 'Int'>
    readonly outputs: FieldRef<"TemplateSplitter", 'Int'>
    readonly attenuation: FieldRef<"TemplateSplitter", 'Json'>
    readonly description: FieldRef<"TemplateSplitter", 'String'>
    readonly createdAt: FieldRef<"TemplateSplitter", 'DateTime'>
    readonly updatedAt: FieldRef<"TemplateSplitter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TemplateSplitter findUnique
   */
  export type TemplateSplitterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSplitter
     */
    select?: TemplateSplitterSelect<ExtArgs> | null
    /**
     * Filter, which TemplateSplitter to fetch.
     */
    where: TemplateSplitterWhereUniqueInput
  }

  /**
   * TemplateSplitter findUniqueOrThrow
   */
  export type TemplateSplitterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSplitter
     */
    select?: TemplateSplitterSelect<ExtArgs> | null
    /**
     * Filter, which TemplateSplitter to fetch.
     */
    where: TemplateSplitterWhereUniqueInput
  }

  /**
   * TemplateSplitter findFirst
   */
  export type TemplateSplitterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSplitter
     */
    select?: TemplateSplitterSelect<ExtArgs> | null
    /**
     * Filter, which TemplateSplitter to fetch.
     */
    where?: TemplateSplitterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateSplitters to fetch.
     */
    orderBy?: TemplateSplitterOrderByWithRelationInput | TemplateSplitterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateSplitters.
     */
    cursor?: TemplateSplitterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateSplitters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateSplitters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateSplitters.
     */
    distinct?: TemplateSplitterScalarFieldEnum | TemplateSplitterScalarFieldEnum[]
  }

  /**
   * TemplateSplitter findFirstOrThrow
   */
  export type TemplateSplitterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSplitter
     */
    select?: TemplateSplitterSelect<ExtArgs> | null
    /**
     * Filter, which TemplateSplitter to fetch.
     */
    where?: TemplateSplitterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateSplitters to fetch.
     */
    orderBy?: TemplateSplitterOrderByWithRelationInput | TemplateSplitterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateSplitters.
     */
    cursor?: TemplateSplitterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateSplitters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateSplitters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateSplitters.
     */
    distinct?: TemplateSplitterScalarFieldEnum | TemplateSplitterScalarFieldEnum[]
  }

  /**
   * TemplateSplitter findMany
   */
  export type TemplateSplitterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSplitter
     */
    select?: TemplateSplitterSelect<ExtArgs> | null
    /**
     * Filter, which TemplateSplitters to fetch.
     */
    where?: TemplateSplitterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateSplitters to fetch.
     */
    orderBy?: TemplateSplitterOrderByWithRelationInput | TemplateSplitterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateSplitters.
     */
    cursor?: TemplateSplitterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateSplitters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateSplitters.
     */
    skip?: number
    distinct?: TemplateSplitterScalarFieldEnum | TemplateSplitterScalarFieldEnum[]
  }

  /**
   * TemplateSplitter create
   */
  export type TemplateSplitterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSplitter
     */
    select?: TemplateSplitterSelect<ExtArgs> | null
    /**
     * The data needed to create a TemplateSplitter.
     */
    data: XOR<TemplateSplitterCreateInput, TemplateSplitterUncheckedCreateInput>
  }

  /**
   * TemplateSplitter createMany
   */
  export type TemplateSplitterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateSplitters.
     */
    data: TemplateSplitterCreateManyInput | TemplateSplitterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateSplitter createManyAndReturn
   */
  export type TemplateSplitterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSplitter
     */
    select?: TemplateSplitterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TemplateSplitters.
     */
    data: TemplateSplitterCreateManyInput | TemplateSplitterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateSplitter update
   */
  export type TemplateSplitterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSplitter
     */
    select?: TemplateSplitterSelect<ExtArgs> | null
    /**
     * The data needed to update a TemplateSplitter.
     */
    data: XOR<TemplateSplitterUpdateInput, TemplateSplitterUncheckedUpdateInput>
    /**
     * Choose, which TemplateSplitter to update.
     */
    where: TemplateSplitterWhereUniqueInput
  }

  /**
   * TemplateSplitter updateMany
   */
  export type TemplateSplitterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateSplitters.
     */
    data: XOR<TemplateSplitterUpdateManyMutationInput, TemplateSplitterUncheckedUpdateManyInput>
    /**
     * Filter which TemplateSplitters to update
     */
    where?: TemplateSplitterWhereInput
  }

  /**
   * TemplateSplitter upsert
   */
  export type TemplateSplitterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSplitter
     */
    select?: TemplateSplitterSelect<ExtArgs> | null
    /**
     * The filter to search for the TemplateSplitter to update in case it exists.
     */
    where: TemplateSplitterWhereUniqueInput
    /**
     * In case the TemplateSplitter found by the `where` argument doesn't exist, create a new TemplateSplitter with this data.
     */
    create: XOR<TemplateSplitterCreateInput, TemplateSplitterUncheckedCreateInput>
    /**
     * In case the TemplateSplitter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateSplitterUpdateInput, TemplateSplitterUncheckedUpdateInput>
  }

  /**
   * TemplateSplitter delete
   */
  export type TemplateSplitterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSplitter
     */
    select?: TemplateSplitterSelect<ExtArgs> | null
    /**
     * Filter which TemplateSplitter to delete.
     */
    where: TemplateSplitterWhereUniqueInput
  }

  /**
   * TemplateSplitter deleteMany
   */
  export type TemplateSplitterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateSplitters to delete
     */
    where?: TemplateSplitterWhereInput
  }

  /**
   * TemplateSplitter without action
   */
  export type TemplateSplitterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSplitter
     */
    select?: TemplateSplitterSelect<ExtArgs> | null
  }


  /**
   * Model CatalogCable
   */

  export type AggregateCatalogCable = {
    _count: CatalogCableCountAggregateOutputType | null
    _avg: CatalogCableAvgAggregateOutputType | null
    _sum: CatalogCableSumAggregateOutputType | null
    _min: CatalogCableMinAggregateOutputType | null
    _max: CatalogCableMaxAggregateOutputType | null
  }

  export type CatalogCableAvgAggregateOutputType = {
    fiberCount: number | null
    looseTubeCount: number | null
    fibersPerTube: number | null
    attenuation: number | null
  }

  export type CatalogCableSumAggregateOutputType = {
    fiberCount: number | null
    looseTubeCount: number | null
    fibersPerTube: number | null
    attenuation: number | null
  }

  export type CatalogCableMinAggregateOutputType = {
    id: string | null
    name: string | null
    brand: string | null
    model: string | null
    defaultLevel: string | null
    fiberCount: number | null
    looseTubeCount: number | null
    fibersPerTube: number | null
    attenuation: number | null
    fiberProfile: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CatalogCableMaxAggregateOutputType = {
    id: string | null
    name: string | null
    brand: string | null
    model: string | null
    defaultLevel: string | null
    fiberCount: number | null
    looseTubeCount: number | null
    fibersPerTube: number | null
    attenuation: number | null
    fiberProfile: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CatalogCableCountAggregateOutputType = {
    id: number
    name: number
    brand: number
    model: number
    defaultLevel: number
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation: number
    fiberProfile: number
    description: number
    deployedSpec: number
    plannedSpec: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type CatalogCableAvgAggregateInputType = {
    fiberCount?: true
    looseTubeCount?: true
    fibersPerTube?: true
    attenuation?: true
  }

  export type CatalogCableSumAggregateInputType = {
    fiberCount?: true
    looseTubeCount?: true
    fibersPerTube?: true
    attenuation?: true
  }

  export type CatalogCableMinAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    model?: true
    defaultLevel?: true
    fiberCount?: true
    looseTubeCount?: true
    fibersPerTube?: true
    attenuation?: true
    fiberProfile?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CatalogCableMaxAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    model?: true
    defaultLevel?: true
    fiberCount?: true
    looseTubeCount?: true
    fibersPerTube?: true
    attenuation?: true
    fiberProfile?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CatalogCableCountAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    model?: true
    defaultLevel?: true
    fiberCount?: true
    looseTubeCount?: true
    fibersPerTube?: true
    attenuation?: true
    fiberProfile?: true
    description?: true
    deployedSpec?: true
    plannedSpec?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type CatalogCableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogCable to aggregate.
     */
    where?: CatalogCableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogCables to fetch.
     */
    orderBy?: CatalogCableOrderByWithRelationInput | CatalogCableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogCableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogCables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogCables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogCables
    **/
    _count?: true | CatalogCableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogCableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogCableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogCableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogCableMaxAggregateInputType
  }

  export type GetCatalogCableAggregateType<T extends CatalogCableAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogCable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogCable[P]>
      : GetScalarType<T[P], AggregateCatalogCable[P]>
  }




  export type CatalogCableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogCableWhereInput
    orderBy?: CatalogCableOrderByWithAggregationInput | CatalogCableOrderByWithAggregationInput[]
    by: CatalogCableScalarFieldEnum[] | CatalogCableScalarFieldEnum
    having?: CatalogCableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogCableCountAggregateInputType | true
    _avg?: CatalogCableAvgAggregateInputType
    _sum?: CatalogCableSumAggregateInputType
    _min?: CatalogCableMinAggregateInputType
    _max?: CatalogCableMaxAggregateInputType
  }

  export type CatalogCableGroupByOutputType = {
    id: string
    name: string
    brand: string | null
    model: string | null
    defaultLevel: string | null
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation: number | null
    fiberProfile: string | null
    description: string | null
    deployedSpec: JsonValue | null
    plannedSpec: JsonValue | null
    createdAt: Date
    updatedAt: Date
    companyId: string | null
    _count: CatalogCableCountAggregateOutputType | null
    _avg: CatalogCableAvgAggregateOutputType | null
    _sum: CatalogCableSumAggregateOutputType | null
    _min: CatalogCableMinAggregateOutputType | null
    _max: CatalogCableMaxAggregateOutputType | null
  }

  type GetCatalogCableGroupByPayload<T extends CatalogCableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogCableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogCableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogCableGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogCableGroupByOutputType[P]>
        }
      >
    >


  export type CatalogCableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand?: boolean
    model?: boolean
    defaultLevel?: boolean
    fiberCount?: boolean
    looseTubeCount?: boolean
    fibersPerTube?: boolean
    attenuation?: boolean
    fiberProfile?: boolean
    description?: boolean
    deployedSpec?: boolean
    plannedSpec?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CatalogCable$companyArgs<ExtArgs>
  }, ExtArgs["result"]["catalogCable"]>

  export type CatalogCableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand?: boolean
    model?: boolean
    defaultLevel?: boolean
    fiberCount?: boolean
    looseTubeCount?: boolean
    fibersPerTube?: boolean
    attenuation?: boolean
    fiberProfile?: boolean
    description?: boolean
    deployedSpec?: boolean
    plannedSpec?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CatalogCable$companyArgs<ExtArgs>
  }, ExtArgs["result"]["catalogCable"]>

  export type CatalogCableSelectScalar = {
    id?: boolean
    name?: boolean
    brand?: boolean
    model?: boolean
    defaultLevel?: boolean
    fiberCount?: boolean
    looseTubeCount?: boolean
    fibersPerTube?: boolean
    attenuation?: boolean
    fiberProfile?: boolean
    description?: boolean
    deployedSpec?: boolean
    plannedSpec?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type CatalogCableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CatalogCable$companyArgs<ExtArgs>
  }
  export type CatalogCableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CatalogCable$companyArgs<ExtArgs>
  }

  export type $CatalogCablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogCable"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      brand: string | null
      model: string | null
      defaultLevel: string | null
      fiberCount: number
      looseTubeCount: number
      fibersPerTube: number
      attenuation: number | null
      fiberProfile: string | null
      description: string | null
      deployedSpec: Prisma.JsonValue | null
      plannedSpec: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      companyId: string | null
    }, ExtArgs["result"]["catalogCable"]>
    composites: {}
  }

  type CatalogCableGetPayload<S extends boolean | null | undefined | CatalogCableDefaultArgs> = $Result.GetResult<Prisma.$CatalogCablePayload, S>

  type CatalogCableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogCableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogCableCountAggregateInputType | true
    }

  export interface CatalogCableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogCable'], meta: { name: 'CatalogCable' } }
    /**
     * Find zero or one CatalogCable that matches the filter.
     * @param {CatalogCableFindUniqueArgs} args - Arguments to find a CatalogCable
     * @example
     * // Get one CatalogCable
     * const catalogCable = await prisma.catalogCable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogCableFindUniqueArgs>(args: SelectSubset<T, CatalogCableFindUniqueArgs<ExtArgs>>): Prisma__CatalogCableClient<$Result.GetResult<Prisma.$CatalogCablePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatalogCable that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogCableFindUniqueOrThrowArgs} args - Arguments to find a CatalogCable
     * @example
     * // Get one CatalogCable
     * const catalogCable = await prisma.catalogCable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogCableFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogCableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogCableClient<$Result.GetResult<Prisma.$CatalogCablePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatalogCable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCableFindFirstArgs} args - Arguments to find a CatalogCable
     * @example
     * // Get one CatalogCable
     * const catalogCable = await prisma.catalogCable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogCableFindFirstArgs>(args?: SelectSubset<T, CatalogCableFindFirstArgs<ExtArgs>>): Prisma__CatalogCableClient<$Result.GetResult<Prisma.$CatalogCablePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatalogCable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCableFindFirstOrThrowArgs} args - Arguments to find a CatalogCable
     * @example
     * // Get one CatalogCable
     * const catalogCable = await prisma.catalogCable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogCableFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogCableFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogCableClient<$Result.GetResult<Prisma.$CatalogCablePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatalogCables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogCables
     * const catalogCables = await prisma.catalogCable.findMany()
     * 
     * // Get first 10 CatalogCables
     * const catalogCables = await prisma.catalogCable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogCableWithIdOnly = await prisma.catalogCable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogCableFindManyArgs>(args?: SelectSubset<T, CatalogCableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogCablePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatalogCable.
     * @param {CatalogCableCreateArgs} args - Arguments to create a CatalogCable.
     * @example
     * // Create one CatalogCable
     * const CatalogCable = await prisma.catalogCable.create({
     *   data: {
     *     // ... data to create a CatalogCable
     *   }
     * })
     * 
     */
    create<T extends CatalogCableCreateArgs>(args: SelectSubset<T, CatalogCableCreateArgs<ExtArgs>>): Prisma__CatalogCableClient<$Result.GetResult<Prisma.$CatalogCablePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatalogCables.
     * @param {CatalogCableCreateManyArgs} args - Arguments to create many CatalogCables.
     * @example
     * // Create many CatalogCables
     * const catalogCable = await prisma.catalogCable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogCableCreateManyArgs>(args?: SelectSubset<T, CatalogCableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogCables and returns the data saved in the database.
     * @param {CatalogCableCreateManyAndReturnArgs} args - Arguments to create many CatalogCables.
     * @example
     * // Create many CatalogCables
     * const catalogCable = await prisma.catalogCable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogCables and only return the `id`
     * const catalogCableWithIdOnly = await prisma.catalogCable.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatalogCableCreateManyAndReturnArgs>(args?: SelectSubset<T, CatalogCableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogCablePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CatalogCable.
     * @param {CatalogCableDeleteArgs} args - Arguments to delete one CatalogCable.
     * @example
     * // Delete one CatalogCable
     * const CatalogCable = await prisma.catalogCable.delete({
     *   where: {
     *     // ... filter to delete one CatalogCable
     *   }
     * })
     * 
     */
    delete<T extends CatalogCableDeleteArgs>(args: SelectSubset<T, CatalogCableDeleteArgs<ExtArgs>>): Prisma__CatalogCableClient<$Result.GetResult<Prisma.$CatalogCablePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatalogCable.
     * @param {CatalogCableUpdateArgs} args - Arguments to update one CatalogCable.
     * @example
     * // Update one CatalogCable
     * const catalogCable = await prisma.catalogCable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogCableUpdateArgs>(args: SelectSubset<T, CatalogCableUpdateArgs<ExtArgs>>): Prisma__CatalogCableClient<$Result.GetResult<Prisma.$CatalogCablePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatalogCables.
     * @param {CatalogCableDeleteManyArgs} args - Arguments to filter CatalogCables to delete.
     * @example
     * // Delete a few CatalogCables
     * const { count } = await prisma.catalogCable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogCableDeleteManyArgs>(args?: SelectSubset<T, CatalogCableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogCables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogCables
     * const catalogCable = await prisma.catalogCable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogCableUpdateManyArgs>(args: SelectSubset<T, CatalogCableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogCable.
     * @param {CatalogCableUpsertArgs} args - Arguments to update or create a CatalogCable.
     * @example
     * // Update or create a CatalogCable
     * const catalogCable = await prisma.catalogCable.upsert({
     *   create: {
     *     // ... data to create a CatalogCable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogCable we want to update
     *   }
     * })
     */
    upsert<T extends CatalogCableUpsertArgs>(args: SelectSubset<T, CatalogCableUpsertArgs<ExtArgs>>): Prisma__CatalogCableClient<$Result.GetResult<Prisma.$CatalogCablePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatalogCables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCableCountArgs} args - Arguments to filter CatalogCables to count.
     * @example
     * // Count the number of CatalogCables
     * const count = await prisma.catalogCable.count({
     *   where: {
     *     // ... the filter for the CatalogCables we want to count
     *   }
     * })
    **/
    count<T extends CatalogCableCountArgs>(
      args?: Subset<T, CatalogCableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogCableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogCable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogCableAggregateArgs>(args: Subset<T, CatalogCableAggregateArgs>): Prisma.PrismaPromise<GetCatalogCableAggregateType<T>>

    /**
     * Group by CatalogCable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogCableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogCableGroupByArgs['orderBy'] }
        : { orderBy?: CatalogCableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogCableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogCableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogCable model
   */
  readonly fields: CatalogCableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogCable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogCableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CatalogCable$companyArgs<ExtArgs> = {}>(args?: Subset<T, CatalogCable$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatalogCable model
   */ 
  interface CatalogCableFieldRefs {
    readonly id: FieldRef<"CatalogCable", 'String'>
    readonly name: FieldRef<"CatalogCable", 'String'>
    readonly brand: FieldRef<"CatalogCable", 'String'>
    readonly model: FieldRef<"CatalogCable", 'String'>
    readonly defaultLevel: FieldRef<"CatalogCable", 'String'>
    readonly fiberCount: FieldRef<"CatalogCable", 'Int'>
    readonly looseTubeCount: FieldRef<"CatalogCable", 'Int'>
    readonly fibersPerTube: FieldRef<"CatalogCable", 'Int'>
    readonly attenuation: FieldRef<"CatalogCable", 'Float'>
    readonly fiberProfile: FieldRef<"CatalogCable", 'String'>
    readonly description: FieldRef<"CatalogCable", 'String'>
    readonly deployedSpec: FieldRef<"CatalogCable", 'Json'>
    readonly plannedSpec: FieldRef<"CatalogCable", 'Json'>
    readonly createdAt: FieldRef<"CatalogCable", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogCable", 'DateTime'>
    readonly companyId: FieldRef<"CatalogCable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CatalogCable findUnique
   */
  export type CatalogCableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCable
     */
    select?: CatalogCableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCableInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCable to fetch.
     */
    where: CatalogCableWhereUniqueInput
  }

  /**
   * CatalogCable findUniqueOrThrow
   */
  export type CatalogCableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCable
     */
    select?: CatalogCableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCableInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCable to fetch.
     */
    where: CatalogCableWhereUniqueInput
  }

  /**
   * CatalogCable findFirst
   */
  export type CatalogCableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCable
     */
    select?: CatalogCableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCableInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCable to fetch.
     */
    where?: CatalogCableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogCables to fetch.
     */
    orderBy?: CatalogCableOrderByWithRelationInput | CatalogCableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogCables.
     */
    cursor?: CatalogCableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogCables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogCables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogCables.
     */
    distinct?: CatalogCableScalarFieldEnum | CatalogCableScalarFieldEnum[]
  }

  /**
   * CatalogCable findFirstOrThrow
   */
  export type CatalogCableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCable
     */
    select?: CatalogCableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCableInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCable to fetch.
     */
    where?: CatalogCableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogCables to fetch.
     */
    orderBy?: CatalogCableOrderByWithRelationInput | CatalogCableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogCables.
     */
    cursor?: CatalogCableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogCables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogCables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogCables.
     */
    distinct?: CatalogCableScalarFieldEnum | CatalogCableScalarFieldEnum[]
  }

  /**
   * CatalogCable findMany
   */
  export type CatalogCableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCable
     */
    select?: CatalogCableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCableInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCables to fetch.
     */
    where?: CatalogCableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogCables to fetch.
     */
    orderBy?: CatalogCableOrderByWithRelationInput | CatalogCableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogCables.
     */
    cursor?: CatalogCableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogCables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogCables.
     */
    skip?: number
    distinct?: CatalogCableScalarFieldEnum | CatalogCableScalarFieldEnum[]
  }

  /**
   * CatalogCable create
   */
  export type CatalogCableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCable
     */
    select?: CatalogCableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCableInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogCable.
     */
    data: XOR<CatalogCableCreateInput, CatalogCableUncheckedCreateInput>
  }

  /**
   * CatalogCable createMany
   */
  export type CatalogCableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogCables.
     */
    data: CatalogCableCreateManyInput | CatalogCableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogCable createManyAndReturn
   */
  export type CatalogCableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCable
     */
    select?: CatalogCableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CatalogCables.
     */
    data: CatalogCableCreateManyInput | CatalogCableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatalogCable update
   */
  export type CatalogCableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCable
     */
    select?: CatalogCableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCableInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogCable.
     */
    data: XOR<CatalogCableUpdateInput, CatalogCableUncheckedUpdateInput>
    /**
     * Choose, which CatalogCable to update.
     */
    where: CatalogCableWhereUniqueInput
  }

  /**
   * CatalogCable updateMany
   */
  export type CatalogCableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogCables.
     */
    data: XOR<CatalogCableUpdateManyMutationInput, CatalogCableUncheckedUpdateManyInput>
    /**
     * Filter which CatalogCables to update
     */
    where?: CatalogCableWhereInput
  }

  /**
   * CatalogCable upsert
   */
  export type CatalogCableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCable
     */
    select?: CatalogCableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCableInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogCable to update in case it exists.
     */
    where: CatalogCableWhereUniqueInput
    /**
     * In case the CatalogCable found by the `where` argument doesn't exist, create a new CatalogCable with this data.
     */
    create: XOR<CatalogCableCreateInput, CatalogCableUncheckedCreateInput>
    /**
     * In case the CatalogCable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogCableUpdateInput, CatalogCableUncheckedUpdateInput>
  }

  /**
   * CatalogCable delete
   */
  export type CatalogCableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCable
     */
    select?: CatalogCableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCableInclude<ExtArgs> | null
    /**
     * Filter which CatalogCable to delete.
     */
    where: CatalogCableWhereUniqueInput
  }

  /**
   * CatalogCable deleteMany
   */
  export type CatalogCableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogCables to delete
     */
    where?: CatalogCableWhereInput
  }

  /**
   * CatalogCable.company
   */
  export type CatalogCable$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * CatalogCable without action
   */
  export type CatalogCableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCable
     */
    select?: CatalogCableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCableInclude<ExtArgs> | null
  }


  /**
   * Model TemplateCable
   */

  export type AggregateTemplateCable = {
    _count: TemplateCableCountAggregateOutputType | null
    _avg: TemplateCableAvgAggregateOutputType | null
    _sum: TemplateCableSumAggregateOutputType | null
    _min: TemplateCableMinAggregateOutputType | null
    _max: TemplateCableMaxAggregateOutputType | null
  }

  export type TemplateCableAvgAggregateOutputType = {
    fiberCount: number | null
    looseTubeCount: number | null
    fibersPerTube: number | null
    attenuation: number | null
  }

  export type TemplateCableSumAggregateOutputType = {
    fiberCount: number | null
    looseTubeCount: number | null
    fibersPerTube: number | null
    attenuation: number | null
  }

  export type TemplateCableMinAggregateOutputType = {
    id: string | null
    name: string | null
    brand: string | null
    model: string | null
    defaultLevel: string | null
    fiberCount: number | null
    looseTubeCount: number | null
    fibersPerTube: number | null
    attenuation: number | null
    fiberProfile: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateCableMaxAggregateOutputType = {
    id: string | null
    name: string | null
    brand: string | null
    model: string | null
    defaultLevel: string | null
    fiberCount: number | null
    looseTubeCount: number | null
    fibersPerTube: number | null
    attenuation: number | null
    fiberProfile: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateCableCountAggregateOutputType = {
    id: number
    name: number
    brand: number
    model: number
    defaultLevel: number
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation: number
    fiberProfile: number
    description: number
    deployedSpec: number
    plannedSpec: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateCableAvgAggregateInputType = {
    fiberCount?: true
    looseTubeCount?: true
    fibersPerTube?: true
    attenuation?: true
  }

  export type TemplateCableSumAggregateInputType = {
    fiberCount?: true
    looseTubeCount?: true
    fibersPerTube?: true
    attenuation?: true
  }

  export type TemplateCableMinAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    model?: true
    defaultLevel?: true
    fiberCount?: true
    looseTubeCount?: true
    fibersPerTube?: true
    attenuation?: true
    fiberProfile?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateCableMaxAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    model?: true
    defaultLevel?: true
    fiberCount?: true
    looseTubeCount?: true
    fibersPerTube?: true
    attenuation?: true
    fiberProfile?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateCableCountAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    model?: true
    defaultLevel?: true
    fiberCount?: true
    looseTubeCount?: true
    fibersPerTube?: true
    attenuation?: true
    fiberProfile?: true
    description?: true
    deployedSpec?: true
    plannedSpec?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateCableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateCable to aggregate.
     */
    where?: TemplateCableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateCables to fetch.
     */
    orderBy?: TemplateCableOrderByWithRelationInput | TemplateCableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateCableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateCables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateCables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateCables
    **/
    _count?: true | TemplateCableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateCableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateCableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateCableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateCableMaxAggregateInputType
  }

  export type GetTemplateCableAggregateType<T extends TemplateCableAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateCable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateCable[P]>
      : GetScalarType<T[P], AggregateTemplateCable[P]>
  }




  export type TemplateCableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateCableWhereInput
    orderBy?: TemplateCableOrderByWithAggregationInput | TemplateCableOrderByWithAggregationInput[]
    by: TemplateCableScalarFieldEnum[] | TemplateCableScalarFieldEnum
    having?: TemplateCableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCableCountAggregateInputType | true
    _avg?: TemplateCableAvgAggregateInputType
    _sum?: TemplateCableSumAggregateInputType
    _min?: TemplateCableMinAggregateInputType
    _max?: TemplateCableMaxAggregateInputType
  }

  export type TemplateCableGroupByOutputType = {
    id: string
    name: string
    brand: string | null
    model: string | null
    defaultLevel: string | null
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation: number | null
    fiberProfile: string | null
    description: string | null
    deployedSpec: JsonValue | null
    plannedSpec: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TemplateCableCountAggregateOutputType | null
    _avg: TemplateCableAvgAggregateOutputType | null
    _sum: TemplateCableSumAggregateOutputType | null
    _min: TemplateCableMinAggregateOutputType | null
    _max: TemplateCableMaxAggregateOutputType | null
  }

  type GetTemplateCableGroupByPayload<T extends TemplateCableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateCableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateCableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateCableGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateCableGroupByOutputType[P]>
        }
      >
    >


  export type TemplateCableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand?: boolean
    model?: boolean
    defaultLevel?: boolean
    fiberCount?: boolean
    looseTubeCount?: boolean
    fibersPerTube?: boolean
    attenuation?: boolean
    fiberProfile?: boolean
    description?: boolean
    deployedSpec?: boolean
    plannedSpec?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templateCable"]>

  export type TemplateCableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand?: boolean
    model?: boolean
    defaultLevel?: boolean
    fiberCount?: boolean
    looseTubeCount?: boolean
    fibersPerTube?: boolean
    attenuation?: boolean
    fiberProfile?: boolean
    description?: boolean
    deployedSpec?: boolean
    plannedSpec?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templateCable"]>

  export type TemplateCableSelectScalar = {
    id?: boolean
    name?: boolean
    brand?: boolean
    model?: boolean
    defaultLevel?: boolean
    fiberCount?: boolean
    looseTubeCount?: boolean
    fibersPerTube?: boolean
    attenuation?: boolean
    fiberProfile?: boolean
    description?: boolean
    deployedSpec?: boolean
    plannedSpec?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TemplateCablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateCable"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      brand: string | null
      model: string | null
      defaultLevel: string | null
      fiberCount: number
      looseTubeCount: number
      fibersPerTube: number
      attenuation: number | null
      fiberProfile: string | null
      description: string | null
      deployedSpec: Prisma.JsonValue | null
      plannedSpec: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["templateCable"]>
    composites: {}
  }

  type TemplateCableGetPayload<S extends boolean | null | undefined | TemplateCableDefaultArgs> = $Result.GetResult<Prisma.$TemplateCablePayload, S>

  type TemplateCableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateCableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateCableCountAggregateInputType | true
    }

  export interface TemplateCableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateCable'], meta: { name: 'TemplateCable' } }
    /**
     * Find zero or one TemplateCable that matches the filter.
     * @param {TemplateCableFindUniqueArgs} args - Arguments to find a TemplateCable
     * @example
     * // Get one TemplateCable
     * const templateCable = await prisma.templateCable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateCableFindUniqueArgs>(args: SelectSubset<T, TemplateCableFindUniqueArgs<ExtArgs>>): Prisma__TemplateCableClient<$Result.GetResult<Prisma.$TemplateCablePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TemplateCable that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TemplateCableFindUniqueOrThrowArgs} args - Arguments to find a TemplateCable
     * @example
     * // Get one TemplateCable
     * const templateCable = await prisma.templateCable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateCableFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateCableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateCableClient<$Result.GetResult<Prisma.$TemplateCablePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TemplateCable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCableFindFirstArgs} args - Arguments to find a TemplateCable
     * @example
     * // Get one TemplateCable
     * const templateCable = await prisma.templateCable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateCableFindFirstArgs>(args?: SelectSubset<T, TemplateCableFindFirstArgs<ExtArgs>>): Prisma__TemplateCableClient<$Result.GetResult<Prisma.$TemplateCablePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TemplateCable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCableFindFirstOrThrowArgs} args - Arguments to find a TemplateCable
     * @example
     * // Get one TemplateCable
     * const templateCable = await prisma.templateCable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateCableFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateCableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateCableClient<$Result.GetResult<Prisma.$TemplateCablePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TemplateCables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateCables
     * const templateCables = await prisma.templateCable.findMany()
     * 
     * // Get first 10 TemplateCables
     * const templateCables = await prisma.templateCable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateCableWithIdOnly = await prisma.templateCable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateCableFindManyArgs>(args?: SelectSubset<T, TemplateCableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateCablePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TemplateCable.
     * @param {TemplateCableCreateArgs} args - Arguments to create a TemplateCable.
     * @example
     * // Create one TemplateCable
     * const TemplateCable = await prisma.templateCable.create({
     *   data: {
     *     // ... data to create a TemplateCable
     *   }
     * })
     * 
     */
    create<T extends TemplateCableCreateArgs>(args: SelectSubset<T, TemplateCableCreateArgs<ExtArgs>>): Prisma__TemplateCableClient<$Result.GetResult<Prisma.$TemplateCablePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TemplateCables.
     * @param {TemplateCableCreateManyArgs} args - Arguments to create many TemplateCables.
     * @example
     * // Create many TemplateCables
     * const templateCable = await prisma.templateCable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateCableCreateManyArgs>(args?: SelectSubset<T, TemplateCableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateCables and returns the data saved in the database.
     * @param {TemplateCableCreateManyAndReturnArgs} args - Arguments to create many TemplateCables.
     * @example
     * // Create many TemplateCables
     * const templateCable = await prisma.templateCable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateCables and only return the `id`
     * const templateCableWithIdOnly = await prisma.templateCable.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateCableCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateCableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateCablePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TemplateCable.
     * @param {TemplateCableDeleteArgs} args - Arguments to delete one TemplateCable.
     * @example
     * // Delete one TemplateCable
     * const TemplateCable = await prisma.templateCable.delete({
     *   where: {
     *     // ... filter to delete one TemplateCable
     *   }
     * })
     * 
     */
    delete<T extends TemplateCableDeleteArgs>(args: SelectSubset<T, TemplateCableDeleteArgs<ExtArgs>>): Prisma__TemplateCableClient<$Result.GetResult<Prisma.$TemplateCablePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TemplateCable.
     * @param {TemplateCableUpdateArgs} args - Arguments to update one TemplateCable.
     * @example
     * // Update one TemplateCable
     * const templateCable = await prisma.templateCable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateCableUpdateArgs>(args: SelectSubset<T, TemplateCableUpdateArgs<ExtArgs>>): Prisma__TemplateCableClient<$Result.GetResult<Prisma.$TemplateCablePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TemplateCables.
     * @param {TemplateCableDeleteManyArgs} args - Arguments to filter TemplateCables to delete.
     * @example
     * // Delete a few TemplateCables
     * const { count } = await prisma.templateCable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateCableDeleteManyArgs>(args?: SelectSubset<T, TemplateCableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateCables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateCables
     * const templateCable = await prisma.templateCable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateCableUpdateManyArgs>(args: SelectSubset<T, TemplateCableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateCable.
     * @param {TemplateCableUpsertArgs} args - Arguments to update or create a TemplateCable.
     * @example
     * // Update or create a TemplateCable
     * const templateCable = await prisma.templateCable.upsert({
     *   create: {
     *     // ... data to create a TemplateCable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateCable we want to update
     *   }
     * })
     */
    upsert<T extends TemplateCableUpsertArgs>(args: SelectSubset<T, TemplateCableUpsertArgs<ExtArgs>>): Prisma__TemplateCableClient<$Result.GetResult<Prisma.$TemplateCablePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TemplateCables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCableCountArgs} args - Arguments to filter TemplateCables to count.
     * @example
     * // Count the number of TemplateCables
     * const count = await prisma.templateCable.count({
     *   where: {
     *     // ... the filter for the TemplateCables we want to count
     *   }
     * })
    **/
    count<T extends TemplateCableCountArgs>(
      args?: Subset<T, TemplateCableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateCable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateCableAggregateArgs>(args: Subset<T, TemplateCableAggregateArgs>): Prisma.PrismaPromise<GetTemplateCableAggregateType<T>>

    /**
     * Group by TemplateCable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateCableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateCableGroupByArgs['orderBy'] }
        : { orderBy?: TemplateCableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateCableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateCableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateCable model
   */
  readonly fields: TemplateCableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateCable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateCableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateCable model
   */ 
  interface TemplateCableFieldRefs {
    readonly id: FieldRef<"TemplateCable", 'String'>
    readonly name: FieldRef<"TemplateCable", 'String'>
    readonly brand: FieldRef<"TemplateCable", 'String'>
    readonly model: FieldRef<"TemplateCable", 'String'>
    readonly defaultLevel: FieldRef<"TemplateCable", 'String'>
    readonly fiberCount: FieldRef<"TemplateCable", 'Int'>
    readonly looseTubeCount: FieldRef<"TemplateCable", 'Int'>
    readonly fibersPerTube: FieldRef<"TemplateCable", 'Int'>
    readonly attenuation: FieldRef<"TemplateCable", 'Float'>
    readonly fiberProfile: FieldRef<"TemplateCable", 'String'>
    readonly description: FieldRef<"TemplateCable", 'String'>
    readonly deployedSpec: FieldRef<"TemplateCable", 'Json'>
    readonly plannedSpec: FieldRef<"TemplateCable", 'Json'>
    readonly createdAt: FieldRef<"TemplateCable", 'DateTime'>
    readonly updatedAt: FieldRef<"TemplateCable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TemplateCable findUnique
   */
  export type TemplateCableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCable
     */
    select?: TemplateCableSelect<ExtArgs> | null
    /**
     * Filter, which TemplateCable to fetch.
     */
    where: TemplateCableWhereUniqueInput
  }

  /**
   * TemplateCable findUniqueOrThrow
   */
  export type TemplateCableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCable
     */
    select?: TemplateCableSelect<ExtArgs> | null
    /**
     * Filter, which TemplateCable to fetch.
     */
    where: TemplateCableWhereUniqueInput
  }

  /**
   * TemplateCable findFirst
   */
  export type TemplateCableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCable
     */
    select?: TemplateCableSelect<ExtArgs> | null
    /**
     * Filter, which TemplateCable to fetch.
     */
    where?: TemplateCableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateCables to fetch.
     */
    orderBy?: TemplateCableOrderByWithRelationInput | TemplateCableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateCables.
     */
    cursor?: TemplateCableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateCables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateCables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateCables.
     */
    distinct?: TemplateCableScalarFieldEnum | TemplateCableScalarFieldEnum[]
  }

  /**
   * TemplateCable findFirstOrThrow
   */
  export type TemplateCableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCable
     */
    select?: TemplateCableSelect<ExtArgs> | null
    /**
     * Filter, which TemplateCable to fetch.
     */
    where?: TemplateCableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateCables to fetch.
     */
    orderBy?: TemplateCableOrderByWithRelationInput | TemplateCableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateCables.
     */
    cursor?: TemplateCableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateCables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateCables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateCables.
     */
    distinct?: TemplateCableScalarFieldEnum | TemplateCableScalarFieldEnum[]
  }

  /**
   * TemplateCable findMany
   */
  export type TemplateCableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCable
     */
    select?: TemplateCableSelect<ExtArgs> | null
    /**
     * Filter, which TemplateCables to fetch.
     */
    where?: TemplateCableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateCables to fetch.
     */
    orderBy?: TemplateCableOrderByWithRelationInput | TemplateCableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateCables.
     */
    cursor?: TemplateCableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateCables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateCables.
     */
    skip?: number
    distinct?: TemplateCableScalarFieldEnum | TemplateCableScalarFieldEnum[]
  }

  /**
   * TemplateCable create
   */
  export type TemplateCableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCable
     */
    select?: TemplateCableSelect<ExtArgs> | null
    /**
     * The data needed to create a TemplateCable.
     */
    data: XOR<TemplateCableCreateInput, TemplateCableUncheckedCreateInput>
  }

  /**
   * TemplateCable createMany
   */
  export type TemplateCableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateCables.
     */
    data: TemplateCableCreateManyInput | TemplateCableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateCable createManyAndReturn
   */
  export type TemplateCableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCable
     */
    select?: TemplateCableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TemplateCables.
     */
    data: TemplateCableCreateManyInput | TemplateCableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateCable update
   */
  export type TemplateCableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCable
     */
    select?: TemplateCableSelect<ExtArgs> | null
    /**
     * The data needed to update a TemplateCable.
     */
    data: XOR<TemplateCableUpdateInput, TemplateCableUncheckedUpdateInput>
    /**
     * Choose, which TemplateCable to update.
     */
    where: TemplateCableWhereUniqueInput
  }

  /**
   * TemplateCable updateMany
   */
  export type TemplateCableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateCables.
     */
    data: XOR<TemplateCableUpdateManyMutationInput, TemplateCableUncheckedUpdateManyInput>
    /**
     * Filter which TemplateCables to update
     */
    where?: TemplateCableWhereInput
  }

  /**
   * TemplateCable upsert
   */
  export type TemplateCableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCable
     */
    select?: TemplateCableSelect<ExtArgs> | null
    /**
     * The filter to search for the TemplateCable to update in case it exists.
     */
    where: TemplateCableWhereUniqueInput
    /**
     * In case the TemplateCable found by the `where` argument doesn't exist, create a new TemplateCable with this data.
     */
    create: XOR<TemplateCableCreateInput, TemplateCableUncheckedCreateInput>
    /**
     * In case the TemplateCable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateCableUpdateInput, TemplateCableUncheckedUpdateInput>
  }

  /**
   * TemplateCable delete
   */
  export type TemplateCableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCable
     */
    select?: TemplateCableSelect<ExtArgs> | null
    /**
     * Filter which TemplateCable to delete.
     */
    where: TemplateCableWhereUniqueInput
  }

  /**
   * TemplateCable deleteMany
   */
  export type TemplateCableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateCables to delete
     */
    where?: TemplateCableWhereInput
  }

  /**
   * TemplateCable without action
   */
  export type TemplateCableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCable
     */
    select?: TemplateCableSelect<ExtArgs> | null
  }


  /**
   * Model CatalogBox
   */

  export type AggregateCatalogBox = {
    _count: CatalogBoxCountAggregateOutputType | null
    _avg: CatalogBoxAvgAggregateOutputType | null
    _sum: CatalogBoxSumAggregateOutputType | null
    _min: CatalogBoxMinAggregateOutputType | null
    _max: CatalogBoxMaxAggregateOutputType | null
  }

  export type CatalogBoxAvgAggregateOutputType = {
    reserveLoopLength: number | null
  }

  export type CatalogBoxSumAggregateOutputType = {
    reserveLoopLength: number | null
  }

  export type CatalogBoxMinAggregateOutputType = {
    id: string | null
    name: string | null
    brand: string | null
    model: string | null
    type: string | null
    reserveLoopLength: number | null
    color: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CatalogBoxMaxAggregateOutputType = {
    id: string | null
    name: string | null
    brand: string | null
    model: string | null
    type: string | null
    reserveLoopLength: number | null
    color: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CatalogBoxCountAggregateOutputType = {
    id: number
    name: number
    brand: number
    model: number
    type: number
    reserveLoopLength: number
    color: number
    description: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type CatalogBoxAvgAggregateInputType = {
    reserveLoopLength?: true
  }

  export type CatalogBoxSumAggregateInputType = {
    reserveLoopLength?: true
  }

  export type CatalogBoxMinAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    model?: true
    type?: true
    reserveLoopLength?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CatalogBoxMaxAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    model?: true
    type?: true
    reserveLoopLength?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CatalogBoxCountAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    model?: true
    type?: true
    reserveLoopLength?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type CatalogBoxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogBox to aggregate.
     */
    where?: CatalogBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogBoxes to fetch.
     */
    orderBy?: CatalogBoxOrderByWithRelationInput | CatalogBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogBoxes
    **/
    _count?: true | CatalogBoxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogBoxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogBoxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogBoxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogBoxMaxAggregateInputType
  }

  export type GetCatalogBoxAggregateType<T extends CatalogBoxAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogBox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogBox[P]>
      : GetScalarType<T[P], AggregateCatalogBox[P]>
  }




  export type CatalogBoxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogBoxWhereInput
    orderBy?: CatalogBoxOrderByWithAggregationInput | CatalogBoxOrderByWithAggregationInput[]
    by: CatalogBoxScalarFieldEnum[] | CatalogBoxScalarFieldEnum
    having?: CatalogBoxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogBoxCountAggregateInputType | true
    _avg?: CatalogBoxAvgAggregateInputType
    _sum?: CatalogBoxSumAggregateInputType
    _min?: CatalogBoxMinAggregateInputType
    _max?: CatalogBoxMaxAggregateInputType
  }

  export type CatalogBoxGroupByOutputType = {
    id: string
    name: string
    brand: string | null
    model: string | null
    type: string
    reserveLoopLength: number | null
    color: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string | null
    _count: CatalogBoxCountAggregateOutputType | null
    _avg: CatalogBoxAvgAggregateOutputType | null
    _sum: CatalogBoxSumAggregateOutputType | null
    _min: CatalogBoxMinAggregateOutputType | null
    _max: CatalogBoxMaxAggregateOutputType | null
  }

  type GetCatalogBoxGroupByPayload<T extends CatalogBoxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogBoxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogBoxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogBoxGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogBoxGroupByOutputType[P]>
        }
      >
    >


  export type CatalogBoxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand?: boolean
    model?: boolean
    type?: boolean
    reserveLoopLength?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CatalogBox$companyArgs<ExtArgs>
  }, ExtArgs["result"]["catalogBox"]>

  export type CatalogBoxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand?: boolean
    model?: boolean
    type?: boolean
    reserveLoopLength?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CatalogBox$companyArgs<ExtArgs>
  }, ExtArgs["result"]["catalogBox"]>

  export type CatalogBoxSelectScalar = {
    id?: boolean
    name?: boolean
    brand?: boolean
    model?: boolean
    type?: boolean
    reserveLoopLength?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type CatalogBoxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CatalogBox$companyArgs<ExtArgs>
  }
  export type CatalogBoxIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CatalogBox$companyArgs<ExtArgs>
  }

  export type $CatalogBoxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogBox"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      brand: string | null
      model: string | null
      type: string
      reserveLoopLength: number | null
      color: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string | null
    }, ExtArgs["result"]["catalogBox"]>
    composites: {}
  }

  type CatalogBoxGetPayload<S extends boolean | null | undefined | CatalogBoxDefaultArgs> = $Result.GetResult<Prisma.$CatalogBoxPayload, S>

  type CatalogBoxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogBoxFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogBoxCountAggregateInputType | true
    }

  export interface CatalogBoxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogBox'], meta: { name: 'CatalogBox' } }
    /**
     * Find zero or one CatalogBox that matches the filter.
     * @param {CatalogBoxFindUniqueArgs} args - Arguments to find a CatalogBox
     * @example
     * // Get one CatalogBox
     * const catalogBox = await prisma.catalogBox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogBoxFindUniqueArgs>(args: SelectSubset<T, CatalogBoxFindUniqueArgs<ExtArgs>>): Prisma__CatalogBoxClient<$Result.GetResult<Prisma.$CatalogBoxPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatalogBox that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogBoxFindUniqueOrThrowArgs} args - Arguments to find a CatalogBox
     * @example
     * // Get one CatalogBox
     * const catalogBox = await prisma.catalogBox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogBoxFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogBoxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogBoxClient<$Result.GetResult<Prisma.$CatalogBoxPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatalogBox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBoxFindFirstArgs} args - Arguments to find a CatalogBox
     * @example
     * // Get one CatalogBox
     * const catalogBox = await prisma.catalogBox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogBoxFindFirstArgs>(args?: SelectSubset<T, CatalogBoxFindFirstArgs<ExtArgs>>): Prisma__CatalogBoxClient<$Result.GetResult<Prisma.$CatalogBoxPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatalogBox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBoxFindFirstOrThrowArgs} args - Arguments to find a CatalogBox
     * @example
     * // Get one CatalogBox
     * const catalogBox = await prisma.catalogBox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogBoxFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogBoxFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogBoxClient<$Result.GetResult<Prisma.$CatalogBoxPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatalogBoxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBoxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogBoxes
     * const catalogBoxes = await prisma.catalogBox.findMany()
     * 
     * // Get first 10 CatalogBoxes
     * const catalogBoxes = await prisma.catalogBox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogBoxWithIdOnly = await prisma.catalogBox.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogBoxFindManyArgs>(args?: SelectSubset<T, CatalogBoxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogBoxPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatalogBox.
     * @param {CatalogBoxCreateArgs} args - Arguments to create a CatalogBox.
     * @example
     * // Create one CatalogBox
     * const CatalogBox = await prisma.catalogBox.create({
     *   data: {
     *     // ... data to create a CatalogBox
     *   }
     * })
     * 
     */
    create<T extends CatalogBoxCreateArgs>(args: SelectSubset<T, CatalogBoxCreateArgs<ExtArgs>>): Prisma__CatalogBoxClient<$Result.GetResult<Prisma.$CatalogBoxPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatalogBoxes.
     * @param {CatalogBoxCreateManyArgs} args - Arguments to create many CatalogBoxes.
     * @example
     * // Create many CatalogBoxes
     * const catalogBox = await prisma.catalogBox.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogBoxCreateManyArgs>(args?: SelectSubset<T, CatalogBoxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogBoxes and returns the data saved in the database.
     * @param {CatalogBoxCreateManyAndReturnArgs} args - Arguments to create many CatalogBoxes.
     * @example
     * // Create many CatalogBoxes
     * const catalogBox = await prisma.catalogBox.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogBoxes and only return the `id`
     * const catalogBoxWithIdOnly = await prisma.catalogBox.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatalogBoxCreateManyAndReturnArgs>(args?: SelectSubset<T, CatalogBoxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogBoxPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CatalogBox.
     * @param {CatalogBoxDeleteArgs} args - Arguments to delete one CatalogBox.
     * @example
     * // Delete one CatalogBox
     * const CatalogBox = await prisma.catalogBox.delete({
     *   where: {
     *     // ... filter to delete one CatalogBox
     *   }
     * })
     * 
     */
    delete<T extends CatalogBoxDeleteArgs>(args: SelectSubset<T, CatalogBoxDeleteArgs<ExtArgs>>): Prisma__CatalogBoxClient<$Result.GetResult<Prisma.$CatalogBoxPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatalogBox.
     * @param {CatalogBoxUpdateArgs} args - Arguments to update one CatalogBox.
     * @example
     * // Update one CatalogBox
     * const catalogBox = await prisma.catalogBox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogBoxUpdateArgs>(args: SelectSubset<T, CatalogBoxUpdateArgs<ExtArgs>>): Prisma__CatalogBoxClient<$Result.GetResult<Prisma.$CatalogBoxPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatalogBoxes.
     * @param {CatalogBoxDeleteManyArgs} args - Arguments to filter CatalogBoxes to delete.
     * @example
     * // Delete a few CatalogBoxes
     * const { count } = await prisma.catalogBox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogBoxDeleteManyArgs>(args?: SelectSubset<T, CatalogBoxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogBoxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBoxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogBoxes
     * const catalogBox = await prisma.catalogBox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogBoxUpdateManyArgs>(args: SelectSubset<T, CatalogBoxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogBox.
     * @param {CatalogBoxUpsertArgs} args - Arguments to update or create a CatalogBox.
     * @example
     * // Update or create a CatalogBox
     * const catalogBox = await prisma.catalogBox.upsert({
     *   create: {
     *     // ... data to create a CatalogBox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogBox we want to update
     *   }
     * })
     */
    upsert<T extends CatalogBoxUpsertArgs>(args: SelectSubset<T, CatalogBoxUpsertArgs<ExtArgs>>): Prisma__CatalogBoxClient<$Result.GetResult<Prisma.$CatalogBoxPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatalogBoxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBoxCountArgs} args - Arguments to filter CatalogBoxes to count.
     * @example
     * // Count the number of CatalogBoxes
     * const count = await prisma.catalogBox.count({
     *   where: {
     *     // ... the filter for the CatalogBoxes we want to count
     *   }
     * })
    **/
    count<T extends CatalogBoxCountArgs>(
      args?: Subset<T, CatalogBoxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogBoxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogBox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBoxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogBoxAggregateArgs>(args: Subset<T, CatalogBoxAggregateArgs>): Prisma.PrismaPromise<GetCatalogBoxAggregateType<T>>

    /**
     * Group by CatalogBox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBoxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogBoxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogBoxGroupByArgs['orderBy'] }
        : { orderBy?: CatalogBoxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogBoxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogBoxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogBox model
   */
  readonly fields: CatalogBoxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogBox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogBoxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CatalogBox$companyArgs<ExtArgs> = {}>(args?: Subset<T, CatalogBox$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatalogBox model
   */ 
  interface CatalogBoxFieldRefs {
    readonly id: FieldRef<"CatalogBox", 'String'>
    readonly name: FieldRef<"CatalogBox", 'String'>
    readonly brand: FieldRef<"CatalogBox", 'String'>
    readonly model: FieldRef<"CatalogBox", 'String'>
    readonly type: FieldRef<"CatalogBox", 'String'>
    readonly reserveLoopLength: FieldRef<"CatalogBox", 'Float'>
    readonly color: FieldRef<"CatalogBox", 'String'>
    readonly description: FieldRef<"CatalogBox", 'String'>
    readonly createdAt: FieldRef<"CatalogBox", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogBox", 'DateTime'>
    readonly companyId: FieldRef<"CatalogBox", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CatalogBox findUnique
   */
  export type CatalogBoxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBox
     */
    select?: CatalogBoxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogBoxInclude<ExtArgs> | null
    /**
     * Filter, which CatalogBox to fetch.
     */
    where: CatalogBoxWhereUniqueInput
  }

  /**
   * CatalogBox findUniqueOrThrow
   */
  export type CatalogBoxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBox
     */
    select?: CatalogBoxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogBoxInclude<ExtArgs> | null
    /**
     * Filter, which CatalogBox to fetch.
     */
    where: CatalogBoxWhereUniqueInput
  }

  /**
   * CatalogBox findFirst
   */
  export type CatalogBoxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBox
     */
    select?: CatalogBoxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogBoxInclude<ExtArgs> | null
    /**
     * Filter, which CatalogBox to fetch.
     */
    where?: CatalogBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogBoxes to fetch.
     */
    orderBy?: CatalogBoxOrderByWithRelationInput | CatalogBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogBoxes.
     */
    cursor?: CatalogBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogBoxes.
     */
    distinct?: CatalogBoxScalarFieldEnum | CatalogBoxScalarFieldEnum[]
  }

  /**
   * CatalogBox findFirstOrThrow
   */
  export type CatalogBoxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBox
     */
    select?: CatalogBoxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogBoxInclude<ExtArgs> | null
    /**
     * Filter, which CatalogBox to fetch.
     */
    where?: CatalogBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogBoxes to fetch.
     */
    orderBy?: CatalogBoxOrderByWithRelationInput | CatalogBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogBoxes.
     */
    cursor?: CatalogBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogBoxes.
     */
    distinct?: CatalogBoxScalarFieldEnum | CatalogBoxScalarFieldEnum[]
  }

  /**
   * CatalogBox findMany
   */
  export type CatalogBoxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBox
     */
    select?: CatalogBoxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogBoxInclude<ExtArgs> | null
    /**
     * Filter, which CatalogBoxes to fetch.
     */
    where?: CatalogBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogBoxes to fetch.
     */
    orderBy?: CatalogBoxOrderByWithRelationInput | CatalogBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogBoxes.
     */
    cursor?: CatalogBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogBoxes.
     */
    skip?: number
    distinct?: CatalogBoxScalarFieldEnum | CatalogBoxScalarFieldEnum[]
  }

  /**
   * CatalogBox create
   */
  export type CatalogBoxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBox
     */
    select?: CatalogBoxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogBoxInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogBox.
     */
    data: XOR<CatalogBoxCreateInput, CatalogBoxUncheckedCreateInput>
  }

  /**
   * CatalogBox createMany
   */
  export type CatalogBoxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogBoxes.
     */
    data: CatalogBoxCreateManyInput | CatalogBoxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogBox createManyAndReturn
   */
  export type CatalogBoxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBox
     */
    select?: CatalogBoxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CatalogBoxes.
     */
    data: CatalogBoxCreateManyInput | CatalogBoxCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogBoxIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatalogBox update
   */
  export type CatalogBoxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBox
     */
    select?: CatalogBoxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogBoxInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogBox.
     */
    data: XOR<CatalogBoxUpdateInput, CatalogBoxUncheckedUpdateInput>
    /**
     * Choose, which CatalogBox to update.
     */
    where: CatalogBoxWhereUniqueInput
  }

  /**
   * CatalogBox updateMany
   */
  export type CatalogBoxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogBoxes.
     */
    data: XOR<CatalogBoxUpdateManyMutationInput, CatalogBoxUncheckedUpdateManyInput>
    /**
     * Filter which CatalogBoxes to update
     */
    where?: CatalogBoxWhereInput
  }

  /**
   * CatalogBox upsert
   */
  export type CatalogBoxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBox
     */
    select?: CatalogBoxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogBoxInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogBox to update in case it exists.
     */
    where: CatalogBoxWhereUniqueInput
    /**
     * In case the CatalogBox found by the `where` argument doesn't exist, create a new CatalogBox with this data.
     */
    create: XOR<CatalogBoxCreateInput, CatalogBoxUncheckedCreateInput>
    /**
     * In case the CatalogBox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogBoxUpdateInput, CatalogBoxUncheckedUpdateInput>
  }

  /**
   * CatalogBox delete
   */
  export type CatalogBoxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBox
     */
    select?: CatalogBoxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogBoxInclude<ExtArgs> | null
    /**
     * Filter which CatalogBox to delete.
     */
    where: CatalogBoxWhereUniqueInput
  }

  /**
   * CatalogBox deleteMany
   */
  export type CatalogBoxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogBoxes to delete
     */
    where?: CatalogBoxWhereInput
  }

  /**
   * CatalogBox.company
   */
  export type CatalogBox$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * CatalogBox without action
   */
  export type CatalogBoxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBox
     */
    select?: CatalogBoxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogBoxInclude<ExtArgs> | null
  }


  /**
   * Model TemplateBox
   */

  export type AggregateTemplateBox = {
    _count: TemplateBoxCountAggregateOutputType | null
    _avg: TemplateBoxAvgAggregateOutputType | null
    _sum: TemplateBoxSumAggregateOutputType | null
    _min: TemplateBoxMinAggregateOutputType | null
    _max: TemplateBoxMaxAggregateOutputType | null
  }

  export type TemplateBoxAvgAggregateOutputType = {
    reserveLoopLength: number | null
  }

  export type TemplateBoxSumAggregateOutputType = {
    reserveLoopLength: number | null
  }

  export type TemplateBoxMinAggregateOutputType = {
    id: string | null
    name: string | null
    brand: string | null
    model: string | null
    type: string | null
    reserveLoopLength: number | null
    color: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateBoxMaxAggregateOutputType = {
    id: string | null
    name: string | null
    brand: string | null
    model: string | null
    type: string | null
    reserveLoopLength: number | null
    color: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateBoxCountAggregateOutputType = {
    id: number
    name: number
    brand: number
    model: number
    type: number
    reserveLoopLength: number
    color: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateBoxAvgAggregateInputType = {
    reserveLoopLength?: true
  }

  export type TemplateBoxSumAggregateInputType = {
    reserveLoopLength?: true
  }

  export type TemplateBoxMinAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    model?: true
    type?: true
    reserveLoopLength?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateBoxMaxAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    model?: true
    type?: true
    reserveLoopLength?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateBoxCountAggregateInputType = {
    id?: true
    name?: true
    brand?: true
    model?: true
    type?: true
    reserveLoopLength?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateBoxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateBox to aggregate.
     */
    where?: TemplateBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateBoxes to fetch.
     */
    orderBy?: TemplateBoxOrderByWithRelationInput | TemplateBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateBoxes
    **/
    _count?: true | TemplateBoxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateBoxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateBoxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateBoxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateBoxMaxAggregateInputType
  }

  export type GetTemplateBoxAggregateType<T extends TemplateBoxAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateBox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateBox[P]>
      : GetScalarType<T[P], AggregateTemplateBox[P]>
  }




  export type TemplateBoxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateBoxWhereInput
    orderBy?: TemplateBoxOrderByWithAggregationInput | TemplateBoxOrderByWithAggregationInput[]
    by: TemplateBoxScalarFieldEnum[] | TemplateBoxScalarFieldEnum
    having?: TemplateBoxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateBoxCountAggregateInputType | true
    _avg?: TemplateBoxAvgAggregateInputType
    _sum?: TemplateBoxSumAggregateInputType
    _min?: TemplateBoxMinAggregateInputType
    _max?: TemplateBoxMaxAggregateInputType
  }

  export type TemplateBoxGroupByOutputType = {
    id: string
    name: string
    brand: string | null
    model: string | null
    type: string
    reserveLoopLength: number | null
    color: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TemplateBoxCountAggregateOutputType | null
    _avg: TemplateBoxAvgAggregateOutputType | null
    _sum: TemplateBoxSumAggregateOutputType | null
    _min: TemplateBoxMinAggregateOutputType | null
    _max: TemplateBoxMaxAggregateOutputType | null
  }

  type GetTemplateBoxGroupByPayload<T extends TemplateBoxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateBoxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateBoxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateBoxGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateBoxGroupByOutputType[P]>
        }
      >
    >


  export type TemplateBoxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand?: boolean
    model?: boolean
    type?: boolean
    reserveLoopLength?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templateBox"]>

  export type TemplateBoxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand?: boolean
    model?: boolean
    type?: boolean
    reserveLoopLength?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templateBox"]>

  export type TemplateBoxSelectScalar = {
    id?: boolean
    name?: boolean
    brand?: boolean
    model?: boolean
    type?: boolean
    reserveLoopLength?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TemplateBoxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateBox"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      brand: string | null
      model: string | null
      type: string
      reserveLoopLength: number | null
      color: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["templateBox"]>
    composites: {}
  }

  type TemplateBoxGetPayload<S extends boolean | null | undefined | TemplateBoxDefaultArgs> = $Result.GetResult<Prisma.$TemplateBoxPayload, S>

  type TemplateBoxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateBoxFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateBoxCountAggregateInputType | true
    }

  export interface TemplateBoxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateBox'], meta: { name: 'TemplateBox' } }
    /**
     * Find zero or one TemplateBox that matches the filter.
     * @param {TemplateBoxFindUniqueArgs} args - Arguments to find a TemplateBox
     * @example
     * // Get one TemplateBox
     * const templateBox = await prisma.templateBox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateBoxFindUniqueArgs>(args: SelectSubset<T, TemplateBoxFindUniqueArgs<ExtArgs>>): Prisma__TemplateBoxClient<$Result.GetResult<Prisma.$TemplateBoxPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TemplateBox that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TemplateBoxFindUniqueOrThrowArgs} args - Arguments to find a TemplateBox
     * @example
     * // Get one TemplateBox
     * const templateBox = await prisma.templateBox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateBoxFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateBoxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateBoxClient<$Result.GetResult<Prisma.$TemplateBoxPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TemplateBox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateBoxFindFirstArgs} args - Arguments to find a TemplateBox
     * @example
     * // Get one TemplateBox
     * const templateBox = await prisma.templateBox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateBoxFindFirstArgs>(args?: SelectSubset<T, TemplateBoxFindFirstArgs<ExtArgs>>): Prisma__TemplateBoxClient<$Result.GetResult<Prisma.$TemplateBoxPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TemplateBox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateBoxFindFirstOrThrowArgs} args - Arguments to find a TemplateBox
     * @example
     * // Get one TemplateBox
     * const templateBox = await prisma.templateBox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateBoxFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateBoxFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateBoxClient<$Result.GetResult<Prisma.$TemplateBoxPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TemplateBoxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateBoxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateBoxes
     * const templateBoxes = await prisma.templateBox.findMany()
     * 
     * // Get first 10 TemplateBoxes
     * const templateBoxes = await prisma.templateBox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateBoxWithIdOnly = await prisma.templateBox.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateBoxFindManyArgs>(args?: SelectSubset<T, TemplateBoxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateBoxPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TemplateBox.
     * @param {TemplateBoxCreateArgs} args - Arguments to create a TemplateBox.
     * @example
     * // Create one TemplateBox
     * const TemplateBox = await prisma.templateBox.create({
     *   data: {
     *     // ... data to create a TemplateBox
     *   }
     * })
     * 
     */
    create<T extends TemplateBoxCreateArgs>(args: SelectSubset<T, TemplateBoxCreateArgs<ExtArgs>>): Prisma__TemplateBoxClient<$Result.GetResult<Prisma.$TemplateBoxPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TemplateBoxes.
     * @param {TemplateBoxCreateManyArgs} args - Arguments to create many TemplateBoxes.
     * @example
     * // Create many TemplateBoxes
     * const templateBox = await prisma.templateBox.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateBoxCreateManyArgs>(args?: SelectSubset<T, TemplateBoxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateBoxes and returns the data saved in the database.
     * @param {TemplateBoxCreateManyAndReturnArgs} args - Arguments to create many TemplateBoxes.
     * @example
     * // Create many TemplateBoxes
     * const templateBox = await prisma.templateBox.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateBoxes and only return the `id`
     * const templateBoxWithIdOnly = await prisma.templateBox.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateBoxCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateBoxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateBoxPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TemplateBox.
     * @param {TemplateBoxDeleteArgs} args - Arguments to delete one TemplateBox.
     * @example
     * // Delete one TemplateBox
     * const TemplateBox = await prisma.templateBox.delete({
     *   where: {
     *     // ... filter to delete one TemplateBox
     *   }
     * })
     * 
     */
    delete<T extends TemplateBoxDeleteArgs>(args: SelectSubset<T, TemplateBoxDeleteArgs<ExtArgs>>): Prisma__TemplateBoxClient<$Result.GetResult<Prisma.$TemplateBoxPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TemplateBox.
     * @param {TemplateBoxUpdateArgs} args - Arguments to update one TemplateBox.
     * @example
     * // Update one TemplateBox
     * const templateBox = await prisma.templateBox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateBoxUpdateArgs>(args: SelectSubset<T, TemplateBoxUpdateArgs<ExtArgs>>): Prisma__TemplateBoxClient<$Result.GetResult<Prisma.$TemplateBoxPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TemplateBoxes.
     * @param {TemplateBoxDeleteManyArgs} args - Arguments to filter TemplateBoxes to delete.
     * @example
     * // Delete a few TemplateBoxes
     * const { count } = await prisma.templateBox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateBoxDeleteManyArgs>(args?: SelectSubset<T, TemplateBoxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateBoxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateBoxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateBoxes
     * const templateBox = await prisma.templateBox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateBoxUpdateManyArgs>(args: SelectSubset<T, TemplateBoxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateBox.
     * @param {TemplateBoxUpsertArgs} args - Arguments to update or create a TemplateBox.
     * @example
     * // Update or create a TemplateBox
     * const templateBox = await prisma.templateBox.upsert({
     *   create: {
     *     // ... data to create a TemplateBox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateBox we want to update
     *   }
     * })
     */
    upsert<T extends TemplateBoxUpsertArgs>(args: SelectSubset<T, TemplateBoxUpsertArgs<ExtArgs>>): Prisma__TemplateBoxClient<$Result.GetResult<Prisma.$TemplateBoxPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TemplateBoxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateBoxCountArgs} args - Arguments to filter TemplateBoxes to count.
     * @example
     * // Count the number of TemplateBoxes
     * const count = await prisma.templateBox.count({
     *   where: {
     *     // ... the filter for the TemplateBoxes we want to count
     *   }
     * })
    **/
    count<T extends TemplateBoxCountArgs>(
      args?: Subset<T, TemplateBoxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateBoxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateBox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateBoxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateBoxAggregateArgs>(args: Subset<T, TemplateBoxAggregateArgs>): Prisma.PrismaPromise<GetTemplateBoxAggregateType<T>>

    /**
     * Group by TemplateBox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateBoxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateBoxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateBoxGroupByArgs['orderBy'] }
        : { orderBy?: TemplateBoxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateBoxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateBoxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateBox model
   */
  readonly fields: TemplateBoxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateBox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateBoxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateBox model
   */ 
  interface TemplateBoxFieldRefs {
    readonly id: FieldRef<"TemplateBox", 'String'>
    readonly name: FieldRef<"TemplateBox", 'String'>
    readonly brand: FieldRef<"TemplateBox", 'String'>
    readonly model: FieldRef<"TemplateBox", 'String'>
    readonly type: FieldRef<"TemplateBox", 'String'>
    readonly reserveLoopLength: FieldRef<"TemplateBox", 'Float'>
    readonly color: FieldRef<"TemplateBox", 'String'>
    readonly description: FieldRef<"TemplateBox", 'String'>
    readonly createdAt: FieldRef<"TemplateBox", 'DateTime'>
    readonly updatedAt: FieldRef<"TemplateBox", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TemplateBox findUnique
   */
  export type TemplateBoxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateBox
     */
    select?: TemplateBoxSelect<ExtArgs> | null
    /**
     * Filter, which TemplateBox to fetch.
     */
    where: TemplateBoxWhereUniqueInput
  }

  /**
   * TemplateBox findUniqueOrThrow
   */
  export type TemplateBoxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateBox
     */
    select?: TemplateBoxSelect<ExtArgs> | null
    /**
     * Filter, which TemplateBox to fetch.
     */
    where: TemplateBoxWhereUniqueInput
  }

  /**
   * TemplateBox findFirst
   */
  export type TemplateBoxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateBox
     */
    select?: TemplateBoxSelect<ExtArgs> | null
    /**
     * Filter, which TemplateBox to fetch.
     */
    where?: TemplateBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateBoxes to fetch.
     */
    orderBy?: TemplateBoxOrderByWithRelationInput | TemplateBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateBoxes.
     */
    cursor?: TemplateBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateBoxes.
     */
    distinct?: TemplateBoxScalarFieldEnum | TemplateBoxScalarFieldEnum[]
  }

  /**
   * TemplateBox findFirstOrThrow
   */
  export type TemplateBoxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateBox
     */
    select?: TemplateBoxSelect<ExtArgs> | null
    /**
     * Filter, which TemplateBox to fetch.
     */
    where?: TemplateBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateBoxes to fetch.
     */
    orderBy?: TemplateBoxOrderByWithRelationInput | TemplateBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateBoxes.
     */
    cursor?: TemplateBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateBoxes.
     */
    distinct?: TemplateBoxScalarFieldEnum | TemplateBoxScalarFieldEnum[]
  }

  /**
   * TemplateBox findMany
   */
  export type TemplateBoxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateBox
     */
    select?: TemplateBoxSelect<ExtArgs> | null
    /**
     * Filter, which TemplateBoxes to fetch.
     */
    where?: TemplateBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateBoxes to fetch.
     */
    orderBy?: TemplateBoxOrderByWithRelationInput | TemplateBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateBoxes.
     */
    cursor?: TemplateBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateBoxes.
     */
    skip?: number
    distinct?: TemplateBoxScalarFieldEnum | TemplateBoxScalarFieldEnum[]
  }

  /**
   * TemplateBox create
   */
  export type TemplateBoxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateBox
     */
    select?: TemplateBoxSelect<ExtArgs> | null
    /**
     * The data needed to create a TemplateBox.
     */
    data: XOR<TemplateBoxCreateInput, TemplateBoxUncheckedCreateInput>
  }

  /**
   * TemplateBox createMany
   */
  export type TemplateBoxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateBoxes.
     */
    data: TemplateBoxCreateManyInput | TemplateBoxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateBox createManyAndReturn
   */
  export type TemplateBoxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateBox
     */
    select?: TemplateBoxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TemplateBoxes.
     */
    data: TemplateBoxCreateManyInput | TemplateBoxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateBox update
   */
  export type TemplateBoxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateBox
     */
    select?: TemplateBoxSelect<ExtArgs> | null
    /**
     * The data needed to update a TemplateBox.
     */
    data: XOR<TemplateBoxUpdateInput, TemplateBoxUncheckedUpdateInput>
    /**
     * Choose, which TemplateBox to update.
     */
    where: TemplateBoxWhereUniqueInput
  }

  /**
   * TemplateBox updateMany
   */
  export type TemplateBoxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateBoxes.
     */
    data: XOR<TemplateBoxUpdateManyMutationInput, TemplateBoxUncheckedUpdateManyInput>
    /**
     * Filter which TemplateBoxes to update
     */
    where?: TemplateBoxWhereInput
  }

  /**
   * TemplateBox upsert
   */
  export type TemplateBoxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateBox
     */
    select?: TemplateBoxSelect<ExtArgs> | null
    /**
     * The filter to search for the TemplateBox to update in case it exists.
     */
    where: TemplateBoxWhereUniqueInput
    /**
     * In case the TemplateBox found by the `where` argument doesn't exist, create a new TemplateBox with this data.
     */
    create: XOR<TemplateBoxCreateInput, TemplateBoxUncheckedCreateInput>
    /**
     * In case the TemplateBox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateBoxUpdateInput, TemplateBoxUncheckedUpdateInput>
  }

  /**
   * TemplateBox delete
   */
  export type TemplateBoxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateBox
     */
    select?: TemplateBoxSelect<ExtArgs> | null
    /**
     * Filter which TemplateBox to delete.
     */
    where: TemplateBoxWhereUniqueInput
  }

  /**
   * TemplateBox deleteMany
   */
  export type TemplateBoxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateBoxes to delete
     */
    where?: TemplateBoxWhereInput
  }

  /**
   * TemplateBox without action
   */
  export type TemplateBoxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateBox
     */
    select?: TemplateBoxSelect<ExtArgs> | null
  }


  /**
   * Model CatalogPole
   */

  export type AggregateCatalogPole = {
    _count: CatalogPoleCountAggregateOutputType | null
    _avg: CatalogPoleAvgAggregateOutputType | null
    _sum: CatalogPoleSumAggregateOutputType | null
    _min: CatalogPoleMinAggregateOutputType | null
    _max: CatalogPoleMaxAggregateOutputType | null
  }

  export type CatalogPoleAvgAggregateOutputType = {
    height: number | null
    strength: number | null
  }

  export type CatalogPoleSumAggregateOutputType = {
    height: number | null
    strength: number | null
  }

  export type CatalogPoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    height: number | null
    strength: number | null
    shape: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CatalogPoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    height: number | null
    strength: number | null
    shape: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CatalogPoleCountAggregateOutputType = {
    id: number
    name: number
    type: number
    height: number
    strength: number
    shape: number
    description: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type CatalogPoleAvgAggregateInputType = {
    height?: true
    strength?: true
  }

  export type CatalogPoleSumAggregateInputType = {
    height?: true
    strength?: true
  }

  export type CatalogPoleMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    height?: true
    strength?: true
    shape?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CatalogPoleMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    height?: true
    strength?: true
    shape?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CatalogPoleCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    height?: true
    strength?: true
    shape?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type CatalogPoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogPole to aggregate.
     */
    where?: CatalogPoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPoles to fetch.
     */
    orderBy?: CatalogPoleOrderByWithRelationInput | CatalogPoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogPoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogPoles
    **/
    _count?: true | CatalogPoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogPoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogPoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogPoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogPoleMaxAggregateInputType
  }

  export type GetCatalogPoleAggregateType<T extends CatalogPoleAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogPole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogPole[P]>
      : GetScalarType<T[P], AggregateCatalogPole[P]>
  }




  export type CatalogPoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogPoleWhereInput
    orderBy?: CatalogPoleOrderByWithAggregationInput | CatalogPoleOrderByWithAggregationInput[]
    by: CatalogPoleScalarFieldEnum[] | CatalogPoleScalarFieldEnum
    having?: CatalogPoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogPoleCountAggregateInputType | true
    _avg?: CatalogPoleAvgAggregateInputType
    _sum?: CatalogPoleSumAggregateInputType
    _min?: CatalogPoleMinAggregateInputType
    _max?: CatalogPoleMaxAggregateInputType
  }

  export type CatalogPoleGroupByOutputType = {
    id: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string | null
    _count: CatalogPoleCountAggregateOutputType | null
    _avg: CatalogPoleAvgAggregateOutputType | null
    _sum: CatalogPoleSumAggregateOutputType | null
    _min: CatalogPoleMinAggregateOutputType | null
    _max: CatalogPoleMaxAggregateOutputType | null
  }

  type GetCatalogPoleGroupByPayload<T extends CatalogPoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogPoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogPoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogPoleGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogPoleGroupByOutputType[P]>
        }
      >
    >


  export type CatalogPoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    height?: boolean
    strength?: boolean
    shape?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    instances?: boolean | CatalogPole$instancesArgs<ExtArgs>
    company?: boolean | CatalogPole$companyArgs<ExtArgs>
    _count?: boolean | CatalogPoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogPole"]>

  export type CatalogPoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    height?: boolean
    strength?: boolean
    shape?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CatalogPole$companyArgs<ExtArgs>
  }, ExtArgs["result"]["catalogPole"]>

  export type CatalogPoleSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    height?: boolean
    strength?: boolean
    shape?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type CatalogPoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instances?: boolean | CatalogPole$instancesArgs<ExtArgs>
    company?: boolean | CatalogPole$companyArgs<ExtArgs>
    _count?: boolean | CatalogPoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CatalogPoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CatalogPole$companyArgs<ExtArgs>
  }

  export type $CatalogPolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogPole"
    objects: {
      instances: Prisma.$PolePayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      height: number
      strength: number
      shape: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string | null
    }, ExtArgs["result"]["catalogPole"]>
    composites: {}
  }

  type CatalogPoleGetPayload<S extends boolean | null | undefined | CatalogPoleDefaultArgs> = $Result.GetResult<Prisma.$CatalogPolePayload, S>

  type CatalogPoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogPoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogPoleCountAggregateInputType | true
    }

  export interface CatalogPoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogPole'], meta: { name: 'CatalogPole' } }
    /**
     * Find zero or one CatalogPole that matches the filter.
     * @param {CatalogPoleFindUniqueArgs} args - Arguments to find a CatalogPole
     * @example
     * // Get one CatalogPole
     * const catalogPole = await prisma.catalogPole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogPoleFindUniqueArgs>(args: SelectSubset<T, CatalogPoleFindUniqueArgs<ExtArgs>>): Prisma__CatalogPoleClient<$Result.GetResult<Prisma.$CatalogPolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatalogPole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogPoleFindUniqueOrThrowArgs} args - Arguments to find a CatalogPole
     * @example
     * // Get one CatalogPole
     * const catalogPole = await prisma.catalogPole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogPoleFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogPoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogPoleClient<$Result.GetResult<Prisma.$CatalogPolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatalogPole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPoleFindFirstArgs} args - Arguments to find a CatalogPole
     * @example
     * // Get one CatalogPole
     * const catalogPole = await prisma.catalogPole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogPoleFindFirstArgs>(args?: SelectSubset<T, CatalogPoleFindFirstArgs<ExtArgs>>): Prisma__CatalogPoleClient<$Result.GetResult<Prisma.$CatalogPolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatalogPole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPoleFindFirstOrThrowArgs} args - Arguments to find a CatalogPole
     * @example
     * // Get one CatalogPole
     * const catalogPole = await prisma.catalogPole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogPoleFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogPoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogPoleClient<$Result.GetResult<Prisma.$CatalogPolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatalogPoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogPoles
     * const catalogPoles = await prisma.catalogPole.findMany()
     * 
     * // Get first 10 CatalogPoles
     * const catalogPoles = await prisma.catalogPole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogPoleWithIdOnly = await prisma.catalogPole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogPoleFindManyArgs>(args?: SelectSubset<T, CatalogPoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatalogPole.
     * @param {CatalogPoleCreateArgs} args - Arguments to create a CatalogPole.
     * @example
     * // Create one CatalogPole
     * const CatalogPole = await prisma.catalogPole.create({
     *   data: {
     *     // ... data to create a CatalogPole
     *   }
     * })
     * 
     */
    create<T extends CatalogPoleCreateArgs>(args: SelectSubset<T, CatalogPoleCreateArgs<ExtArgs>>): Prisma__CatalogPoleClient<$Result.GetResult<Prisma.$CatalogPolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatalogPoles.
     * @param {CatalogPoleCreateManyArgs} args - Arguments to create many CatalogPoles.
     * @example
     * // Create many CatalogPoles
     * const catalogPole = await prisma.catalogPole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogPoleCreateManyArgs>(args?: SelectSubset<T, CatalogPoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogPoles and returns the data saved in the database.
     * @param {CatalogPoleCreateManyAndReturnArgs} args - Arguments to create many CatalogPoles.
     * @example
     * // Create many CatalogPoles
     * const catalogPole = await prisma.catalogPole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogPoles and only return the `id`
     * const catalogPoleWithIdOnly = await prisma.catalogPole.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatalogPoleCreateManyAndReturnArgs>(args?: SelectSubset<T, CatalogPoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CatalogPole.
     * @param {CatalogPoleDeleteArgs} args - Arguments to delete one CatalogPole.
     * @example
     * // Delete one CatalogPole
     * const CatalogPole = await prisma.catalogPole.delete({
     *   where: {
     *     // ... filter to delete one CatalogPole
     *   }
     * })
     * 
     */
    delete<T extends CatalogPoleDeleteArgs>(args: SelectSubset<T, CatalogPoleDeleteArgs<ExtArgs>>): Prisma__CatalogPoleClient<$Result.GetResult<Prisma.$CatalogPolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatalogPole.
     * @param {CatalogPoleUpdateArgs} args - Arguments to update one CatalogPole.
     * @example
     * // Update one CatalogPole
     * const catalogPole = await prisma.catalogPole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogPoleUpdateArgs>(args: SelectSubset<T, CatalogPoleUpdateArgs<ExtArgs>>): Prisma__CatalogPoleClient<$Result.GetResult<Prisma.$CatalogPolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatalogPoles.
     * @param {CatalogPoleDeleteManyArgs} args - Arguments to filter CatalogPoles to delete.
     * @example
     * // Delete a few CatalogPoles
     * const { count } = await prisma.catalogPole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogPoleDeleteManyArgs>(args?: SelectSubset<T, CatalogPoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogPoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogPoles
     * const catalogPole = await prisma.catalogPole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogPoleUpdateManyArgs>(args: SelectSubset<T, CatalogPoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogPole.
     * @param {CatalogPoleUpsertArgs} args - Arguments to update or create a CatalogPole.
     * @example
     * // Update or create a CatalogPole
     * const catalogPole = await prisma.catalogPole.upsert({
     *   create: {
     *     // ... data to create a CatalogPole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogPole we want to update
     *   }
     * })
     */
    upsert<T extends CatalogPoleUpsertArgs>(args: SelectSubset<T, CatalogPoleUpsertArgs<ExtArgs>>): Prisma__CatalogPoleClient<$Result.GetResult<Prisma.$CatalogPolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatalogPoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPoleCountArgs} args - Arguments to filter CatalogPoles to count.
     * @example
     * // Count the number of CatalogPoles
     * const count = await prisma.catalogPole.count({
     *   where: {
     *     // ... the filter for the CatalogPoles we want to count
     *   }
     * })
    **/
    count<T extends CatalogPoleCountArgs>(
      args?: Subset<T, CatalogPoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogPoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogPole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogPoleAggregateArgs>(args: Subset<T, CatalogPoleAggregateArgs>): Prisma.PrismaPromise<GetCatalogPoleAggregateType<T>>

    /**
     * Group by CatalogPole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogPoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogPoleGroupByArgs['orderBy'] }
        : { orderBy?: CatalogPoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogPoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogPoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogPole model
   */
  readonly fields: CatalogPoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogPole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogPoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instances<T extends CatalogPole$instancesArgs<ExtArgs> = {}>(args?: Subset<T, CatalogPole$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CatalogPole$companyArgs<ExtArgs> = {}>(args?: Subset<T, CatalogPole$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatalogPole model
   */ 
  interface CatalogPoleFieldRefs {
    readonly id: FieldRef<"CatalogPole", 'String'>
    readonly name: FieldRef<"CatalogPole", 'String'>
    readonly type: FieldRef<"CatalogPole", 'String'>
    readonly height: FieldRef<"CatalogPole", 'Float'>
    readonly strength: FieldRef<"CatalogPole", 'Float'>
    readonly shape: FieldRef<"CatalogPole", 'String'>
    readonly description: FieldRef<"CatalogPole", 'String'>
    readonly createdAt: FieldRef<"CatalogPole", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogPole", 'DateTime'>
    readonly companyId: FieldRef<"CatalogPole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CatalogPole findUnique
   */
  export type CatalogPoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleInclude<ExtArgs> | null
    /**
     * Filter, which CatalogPole to fetch.
     */
    where: CatalogPoleWhereUniqueInput
  }

  /**
   * CatalogPole findUniqueOrThrow
   */
  export type CatalogPoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleInclude<ExtArgs> | null
    /**
     * Filter, which CatalogPole to fetch.
     */
    where: CatalogPoleWhereUniqueInput
  }

  /**
   * CatalogPole findFirst
   */
  export type CatalogPoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleInclude<ExtArgs> | null
    /**
     * Filter, which CatalogPole to fetch.
     */
    where?: CatalogPoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPoles to fetch.
     */
    orderBy?: CatalogPoleOrderByWithRelationInput | CatalogPoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogPoles.
     */
    cursor?: CatalogPoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogPoles.
     */
    distinct?: CatalogPoleScalarFieldEnum | CatalogPoleScalarFieldEnum[]
  }

  /**
   * CatalogPole findFirstOrThrow
   */
  export type CatalogPoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleInclude<ExtArgs> | null
    /**
     * Filter, which CatalogPole to fetch.
     */
    where?: CatalogPoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPoles to fetch.
     */
    orderBy?: CatalogPoleOrderByWithRelationInput | CatalogPoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogPoles.
     */
    cursor?: CatalogPoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogPoles.
     */
    distinct?: CatalogPoleScalarFieldEnum | CatalogPoleScalarFieldEnum[]
  }

  /**
   * CatalogPole findMany
   */
  export type CatalogPoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleInclude<ExtArgs> | null
    /**
     * Filter, which CatalogPoles to fetch.
     */
    where?: CatalogPoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPoles to fetch.
     */
    orderBy?: CatalogPoleOrderByWithRelationInput | CatalogPoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogPoles.
     */
    cursor?: CatalogPoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPoles.
     */
    skip?: number
    distinct?: CatalogPoleScalarFieldEnum | CatalogPoleScalarFieldEnum[]
  }

  /**
   * CatalogPole create
   */
  export type CatalogPoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogPole.
     */
    data: XOR<CatalogPoleCreateInput, CatalogPoleUncheckedCreateInput>
  }

  /**
   * CatalogPole createMany
   */
  export type CatalogPoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogPoles.
     */
    data: CatalogPoleCreateManyInput | CatalogPoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogPole createManyAndReturn
   */
  export type CatalogPoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CatalogPoles.
     */
    data: CatalogPoleCreateManyInput | CatalogPoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatalogPole update
   */
  export type CatalogPoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogPole.
     */
    data: XOR<CatalogPoleUpdateInput, CatalogPoleUncheckedUpdateInput>
    /**
     * Choose, which CatalogPole to update.
     */
    where: CatalogPoleWhereUniqueInput
  }

  /**
   * CatalogPole updateMany
   */
  export type CatalogPoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogPoles.
     */
    data: XOR<CatalogPoleUpdateManyMutationInput, CatalogPoleUncheckedUpdateManyInput>
    /**
     * Filter which CatalogPoles to update
     */
    where?: CatalogPoleWhereInput
  }

  /**
   * CatalogPole upsert
   */
  export type CatalogPoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogPole to update in case it exists.
     */
    where: CatalogPoleWhereUniqueInput
    /**
     * In case the CatalogPole found by the `where` argument doesn't exist, create a new CatalogPole with this data.
     */
    create: XOR<CatalogPoleCreateInput, CatalogPoleUncheckedCreateInput>
    /**
     * In case the CatalogPole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogPoleUpdateInput, CatalogPoleUncheckedUpdateInput>
  }

  /**
   * CatalogPole delete
   */
  export type CatalogPoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleInclude<ExtArgs> | null
    /**
     * Filter which CatalogPole to delete.
     */
    where: CatalogPoleWhereUniqueInput
  }

  /**
   * CatalogPole deleteMany
   */
  export type CatalogPoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogPoles to delete
     */
    where?: CatalogPoleWhereInput
  }

  /**
   * CatalogPole.instances
   */
  export type CatalogPole$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
    where?: PoleWhereInput
    orderBy?: PoleOrderByWithRelationInput | PoleOrderByWithRelationInput[]
    cursor?: PoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PoleScalarFieldEnum | PoleScalarFieldEnum[]
  }

  /**
   * CatalogPole.company
   */
  export type CatalogPole$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * CatalogPole without action
   */
  export type CatalogPoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleInclude<ExtArgs> | null
  }


  /**
   * Model TemplatePole
   */

  export type AggregateTemplatePole = {
    _count: TemplatePoleCountAggregateOutputType | null
    _avg: TemplatePoleAvgAggregateOutputType | null
    _sum: TemplatePoleSumAggregateOutputType | null
    _min: TemplatePoleMinAggregateOutputType | null
    _max: TemplatePoleMaxAggregateOutputType | null
  }

  export type TemplatePoleAvgAggregateOutputType = {
    height: number | null
    strength: number | null
  }

  export type TemplatePoleSumAggregateOutputType = {
    height: number | null
    strength: number | null
  }

  export type TemplatePoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    height: number | null
    strength: number | null
    shape: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplatePoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    height: number | null
    strength: number | null
    shape: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplatePoleCountAggregateOutputType = {
    id: number
    name: number
    type: number
    height: number
    strength: number
    shape: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplatePoleAvgAggregateInputType = {
    height?: true
    strength?: true
  }

  export type TemplatePoleSumAggregateInputType = {
    height?: true
    strength?: true
  }

  export type TemplatePoleMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    height?: true
    strength?: true
    shape?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplatePoleMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    height?: true
    strength?: true
    shape?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplatePoleCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    height?: true
    strength?: true
    shape?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplatePoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplatePole to aggregate.
     */
    where?: TemplatePoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatePoles to fetch.
     */
    orderBy?: TemplatePoleOrderByWithRelationInput | TemplatePoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplatePoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatePoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatePoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplatePoles
    **/
    _count?: true | TemplatePoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplatePoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplatePoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplatePoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplatePoleMaxAggregateInputType
  }

  export type GetTemplatePoleAggregateType<T extends TemplatePoleAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplatePole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplatePole[P]>
      : GetScalarType<T[P], AggregateTemplatePole[P]>
  }




  export type TemplatePoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplatePoleWhereInput
    orderBy?: TemplatePoleOrderByWithAggregationInput | TemplatePoleOrderByWithAggregationInput[]
    by: TemplatePoleScalarFieldEnum[] | TemplatePoleScalarFieldEnum
    having?: TemplatePoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplatePoleCountAggregateInputType | true
    _avg?: TemplatePoleAvgAggregateInputType
    _sum?: TemplatePoleSumAggregateInputType
    _min?: TemplatePoleMinAggregateInputType
    _max?: TemplatePoleMaxAggregateInputType
  }

  export type TemplatePoleGroupByOutputType = {
    id: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TemplatePoleCountAggregateOutputType | null
    _avg: TemplatePoleAvgAggregateOutputType | null
    _sum: TemplatePoleSumAggregateOutputType | null
    _min: TemplatePoleMinAggregateOutputType | null
    _max: TemplatePoleMaxAggregateOutputType | null
  }

  type GetTemplatePoleGroupByPayload<T extends TemplatePoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplatePoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplatePoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplatePoleGroupByOutputType[P]>
            : GetScalarType<T[P], TemplatePoleGroupByOutputType[P]>
        }
      >
    >


  export type TemplatePoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    height?: boolean
    strength?: boolean
    shape?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templatePole"]>

  export type TemplatePoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    height?: boolean
    strength?: boolean
    shape?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templatePole"]>

  export type TemplatePoleSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    height?: boolean
    strength?: boolean
    shape?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TemplatePolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplatePole"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      height: number
      strength: number
      shape: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["templatePole"]>
    composites: {}
  }

  type TemplatePoleGetPayload<S extends boolean | null | undefined | TemplatePoleDefaultArgs> = $Result.GetResult<Prisma.$TemplatePolePayload, S>

  type TemplatePoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplatePoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplatePoleCountAggregateInputType | true
    }

  export interface TemplatePoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplatePole'], meta: { name: 'TemplatePole' } }
    /**
     * Find zero or one TemplatePole that matches the filter.
     * @param {TemplatePoleFindUniqueArgs} args - Arguments to find a TemplatePole
     * @example
     * // Get one TemplatePole
     * const templatePole = await prisma.templatePole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplatePoleFindUniqueArgs>(args: SelectSubset<T, TemplatePoleFindUniqueArgs<ExtArgs>>): Prisma__TemplatePoleClient<$Result.GetResult<Prisma.$TemplatePolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TemplatePole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TemplatePoleFindUniqueOrThrowArgs} args - Arguments to find a TemplatePole
     * @example
     * // Get one TemplatePole
     * const templatePole = await prisma.templatePole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplatePoleFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplatePoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplatePoleClient<$Result.GetResult<Prisma.$TemplatePolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TemplatePole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePoleFindFirstArgs} args - Arguments to find a TemplatePole
     * @example
     * // Get one TemplatePole
     * const templatePole = await prisma.templatePole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplatePoleFindFirstArgs>(args?: SelectSubset<T, TemplatePoleFindFirstArgs<ExtArgs>>): Prisma__TemplatePoleClient<$Result.GetResult<Prisma.$TemplatePolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TemplatePole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePoleFindFirstOrThrowArgs} args - Arguments to find a TemplatePole
     * @example
     * // Get one TemplatePole
     * const templatePole = await prisma.templatePole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplatePoleFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplatePoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplatePoleClient<$Result.GetResult<Prisma.$TemplatePolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TemplatePoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplatePoles
     * const templatePoles = await prisma.templatePole.findMany()
     * 
     * // Get first 10 TemplatePoles
     * const templatePoles = await prisma.templatePole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templatePoleWithIdOnly = await prisma.templatePole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplatePoleFindManyArgs>(args?: SelectSubset<T, TemplatePoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TemplatePole.
     * @param {TemplatePoleCreateArgs} args - Arguments to create a TemplatePole.
     * @example
     * // Create one TemplatePole
     * const TemplatePole = await prisma.templatePole.create({
     *   data: {
     *     // ... data to create a TemplatePole
     *   }
     * })
     * 
     */
    create<T extends TemplatePoleCreateArgs>(args: SelectSubset<T, TemplatePoleCreateArgs<ExtArgs>>): Prisma__TemplatePoleClient<$Result.GetResult<Prisma.$TemplatePolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TemplatePoles.
     * @param {TemplatePoleCreateManyArgs} args - Arguments to create many TemplatePoles.
     * @example
     * // Create many TemplatePoles
     * const templatePole = await prisma.templatePole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplatePoleCreateManyArgs>(args?: SelectSubset<T, TemplatePoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplatePoles and returns the data saved in the database.
     * @param {TemplatePoleCreateManyAndReturnArgs} args - Arguments to create many TemplatePoles.
     * @example
     * // Create many TemplatePoles
     * const templatePole = await prisma.templatePole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplatePoles and only return the `id`
     * const templatePoleWithIdOnly = await prisma.templatePole.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplatePoleCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplatePoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TemplatePole.
     * @param {TemplatePoleDeleteArgs} args - Arguments to delete one TemplatePole.
     * @example
     * // Delete one TemplatePole
     * const TemplatePole = await prisma.templatePole.delete({
     *   where: {
     *     // ... filter to delete one TemplatePole
     *   }
     * })
     * 
     */
    delete<T extends TemplatePoleDeleteArgs>(args: SelectSubset<T, TemplatePoleDeleteArgs<ExtArgs>>): Prisma__TemplatePoleClient<$Result.GetResult<Prisma.$TemplatePolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TemplatePole.
     * @param {TemplatePoleUpdateArgs} args - Arguments to update one TemplatePole.
     * @example
     * // Update one TemplatePole
     * const templatePole = await prisma.templatePole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplatePoleUpdateArgs>(args: SelectSubset<T, TemplatePoleUpdateArgs<ExtArgs>>): Prisma__TemplatePoleClient<$Result.GetResult<Prisma.$TemplatePolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TemplatePoles.
     * @param {TemplatePoleDeleteManyArgs} args - Arguments to filter TemplatePoles to delete.
     * @example
     * // Delete a few TemplatePoles
     * const { count } = await prisma.templatePole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplatePoleDeleteManyArgs>(args?: SelectSubset<T, TemplatePoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplatePoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplatePoles
     * const templatePole = await prisma.templatePole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplatePoleUpdateManyArgs>(args: SelectSubset<T, TemplatePoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplatePole.
     * @param {TemplatePoleUpsertArgs} args - Arguments to update or create a TemplatePole.
     * @example
     * // Update or create a TemplatePole
     * const templatePole = await prisma.templatePole.upsert({
     *   create: {
     *     // ... data to create a TemplatePole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplatePole we want to update
     *   }
     * })
     */
    upsert<T extends TemplatePoleUpsertArgs>(args: SelectSubset<T, TemplatePoleUpsertArgs<ExtArgs>>): Prisma__TemplatePoleClient<$Result.GetResult<Prisma.$TemplatePolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TemplatePoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePoleCountArgs} args - Arguments to filter TemplatePoles to count.
     * @example
     * // Count the number of TemplatePoles
     * const count = await prisma.templatePole.count({
     *   where: {
     *     // ... the filter for the TemplatePoles we want to count
     *   }
     * })
    **/
    count<T extends TemplatePoleCountArgs>(
      args?: Subset<T, TemplatePoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplatePoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplatePole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplatePoleAggregateArgs>(args: Subset<T, TemplatePoleAggregateArgs>): Prisma.PrismaPromise<GetTemplatePoleAggregateType<T>>

    /**
     * Group by TemplatePole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplatePoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplatePoleGroupByArgs['orderBy'] }
        : { orderBy?: TemplatePoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplatePoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplatePoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplatePole model
   */
  readonly fields: TemplatePoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplatePole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplatePoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplatePole model
   */ 
  interface TemplatePoleFieldRefs {
    readonly id: FieldRef<"TemplatePole", 'String'>
    readonly name: FieldRef<"TemplatePole", 'String'>
    readonly type: FieldRef<"TemplatePole", 'String'>
    readonly height: FieldRef<"TemplatePole", 'Float'>
    readonly strength: FieldRef<"TemplatePole", 'Float'>
    readonly shape: FieldRef<"TemplatePole", 'String'>
    readonly description: FieldRef<"TemplatePole", 'String'>
    readonly createdAt: FieldRef<"TemplatePole", 'DateTime'>
    readonly updatedAt: FieldRef<"TemplatePole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TemplatePole findUnique
   */
  export type TemplatePoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePole
     */
    select?: TemplatePoleSelect<ExtArgs> | null
    /**
     * Filter, which TemplatePole to fetch.
     */
    where: TemplatePoleWhereUniqueInput
  }

  /**
   * TemplatePole findUniqueOrThrow
   */
  export type TemplatePoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePole
     */
    select?: TemplatePoleSelect<ExtArgs> | null
    /**
     * Filter, which TemplatePole to fetch.
     */
    where: TemplatePoleWhereUniqueInput
  }

  /**
   * TemplatePole findFirst
   */
  export type TemplatePoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePole
     */
    select?: TemplatePoleSelect<ExtArgs> | null
    /**
     * Filter, which TemplatePole to fetch.
     */
    where?: TemplatePoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatePoles to fetch.
     */
    orderBy?: TemplatePoleOrderByWithRelationInput | TemplatePoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplatePoles.
     */
    cursor?: TemplatePoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatePoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatePoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplatePoles.
     */
    distinct?: TemplatePoleScalarFieldEnum | TemplatePoleScalarFieldEnum[]
  }

  /**
   * TemplatePole findFirstOrThrow
   */
  export type TemplatePoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePole
     */
    select?: TemplatePoleSelect<ExtArgs> | null
    /**
     * Filter, which TemplatePole to fetch.
     */
    where?: TemplatePoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatePoles to fetch.
     */
    orderBy?: TemplatePoleOrderByWithRelationInput | TemplatePoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplatePoles.
     */
    cursor?: TemplatePoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatePoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatePoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplatePoles.
     */
    distinct?: TemplatePoleScalarFieldEnum | TemplatePoleScalarFieldEnum[]
  }

  /**
   * TemplatePole findMany
   */
  export type TemplatePoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePole
     */
    select?: TemplatePoleSelect<ExtArgs> | null
    /**
     * Filter, which TemplatePoles to fetch.
     */
    where?: TemplatePoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatePoles to fetch.
     */
    orderBy?: TemplatePoleOrderByWithRelationInput | TemplatePoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplatePoles.
     */
    cursor?: TemplatePoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatePoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatePoles.
     */
    skip?: number
    distinct?: TemplatePoleScalarFieldEnum | TemplatePoleScalarFieldEnum[]
  }

  /**
   * TemplatePole create
   */
  export type TemplatePoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePole
     */
    select?: TemplatePoleSelect<ExtArgs> | null
    /**
     * The data needed to create a TemplatePole.
     */
    data: XOR<TemplatePoleCreateInput, TemplatePoleUncheckedCreateInput>
  }

  /**
   * TemplatePole createMany
   */
  export type TemplatePoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplatePoles.
     */
    data: TemplatePoleCreateManyInput | TemplatePoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplatePole createManyAndReturn
   */
  export type TemplatePoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePole
     */
    select?: TemplatePoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TemplatePoles.
     */
    data: TemplatePoleCreateManyInput | TemplatePoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplatePole update
   */
  export type TemplatePoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePole
     */
    select?: TemplatePoleSelect<ExtArgs> | null
    /**
     * The data needed to update a TemplatePole.
     */
    data: XOR<TemplatePoleUpdateInput, TemplatePoleUncheckedUpdateInput>
    /**
     * Choose, which TemplatePole to update.
     */
    where: TemplatePoleWhereUniqueInput
  }

  /**
   * TemplatePole updateMany
   */
  export type TemplatePoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplatePoles.
     */
    data: XOR<TemplatePoleUpdateManyMutationInput, TemplatePoleUncheckedUpdateManyInput>
    /**
     * Filter which TemplatePoles to update
     */
    where?: TemplatePoleWhereInput
  }

  /**
   * TemplatePole upsert
   */
  export type TemplatePoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePole
     */
    select?: TemplatePoleSelect<ExtArgs> | null
    /**
     * The filter to search for the TemplatePole to update in case it exists.
     */
    where: TemplatePoleWhereUniqueInput
    /**
     * In case the TemplatePole found by the `where` argument doesn't exist, create a new TemplatePole with this data.
     */
    create: XOR<TemplatePoleCreateInput, TemplatePoleUncheckedCreateInput>
    /**
     * In case the TemplatePole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplatePoleUpdateInput, TemplatePoleUncheckedUpdateInput>
  }

  /**
   * TemplatePole delete
   */
  export type TemplatePoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePole
     */
    select?: TemplatePoleSelect<ExtArgs> | null
    /**
     * Filter which TemplatePole to delete.
     */
    where: TemplatePoleWhereUniqueInput
  }

  /**
   * TemplatePole deleteMany
   */
  export type TemplatePoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplatePoles to delete
     */
    where?: TemplatePoleWhereInput
  }

  /**
   * TemplatePole without action
   */
  export type TemplatePoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePole
     */
    select?: TemplatePoleSelect<ExtArgs> | null
  }


  /**
   * Model Pole
   */

  export type AggregatePole = {
    _count: PoleCountAggregateOutputType | null
    _avg: PoleAvgAggregateOutputType | null
    _sum: PoleSumAggregateOutputType | null
    _min: PoleMinAggregateOutputType | null
    _max: PoleMaxAggregateOutputType | null
  }

  export type PoleAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type PoleSumAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type PoleMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    status: $Enums.EquipmentStatus | null
    lat: number | null
    lng: number | null
    catalogId: string | null
    companyId: string | null
  }

  export type PoleMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    status: $Enums.EquipmentStatus | null
    lat: number | null
    lng: number | null
    catalogId: string | null
    companyId: string | null
  }

  export type PoleCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    status: number
    lat: number
    lng: number
    catalogId: number
    companyId: number
    _all: number
  }


  export type PoleAvgAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type PoleSumAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type PoleMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    status?: true
    lat?: true
    lng?: true
    catalogId?: true
    companyId?: true
  }

  export type PoleMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    status?: true
    lat?: true
    lng?: true
    catalogId?: true
    companyId?: true
  }

  export type PoleCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    status?: true
    lat?: true
    lng?: true
    catalogId?: true
    companyId?: true
    _all?: true
  }

  export type PoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pole to aggregate.
     */
    where?: PoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Poles to fetch.
     */
    orderBy?: PoleOrderByWithRelationInput | PoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Poles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Poles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Poles
    **/
    _count?: true | PoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PoleMaxAggregateInputType
  }

  export type GetPoleAggregateType<T extends PoleAggregateArgs> = {
        [P in keyof T & keyof AggregatePole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePole[P]>
      : GetScalarType<T[P], AggregatePole[P]>
  }




  export type PoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoleWhereInput
    orderBy?: PoleOrderByWithAggregationInput | PoleOrderByWithAggregationInput[]
    by: PoleScalarFieldEnum[] | PoleScalarFieldEnum
    having?: PoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PoleCountAggregateInputType | true
    _avg?: PoleAvgAggregateInputType
    _sum?: PoleSumAggregateInputType
    _min?: PoleMinAggregateInputType
    _max?: PoleMaxAggregateInputType
  }

  export type PoleGroupByOutputType = {
    id: string
    projectId: string
    name: string
    status: $Enums.EquipmentStatus
    lat: number
    lng: number
    catalogId: string | null
    companyId: string | null
    _count: PoleCountAggregateOutputType | null
    _avg: PoleAvgAggregateOutputType | null
    _sum: PoleSumAggregateOutputType | null
    _min: PoleMinAggregateOutputType | null
    _max: PoleMaxAggregateOutputType | null
  }

  type GetPoleGroupByPayload<T extends PoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PoleGroupByOutputType[P]>
            : GetScalarType<T[P], PoleGroupByOutputType[P]>
        }
      >
    >


  export type PoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    status?: boolean
    lat?: boolean
    lng?: boolean
    catalogId?: boolean
    companyId?: boolean
    company?: boolean | Pole$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    catalog?: boolean | Pole$catalogArgs<ExtArgs>
  }, ExtArgs["result"]["pole"]>

  export type PoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    status?: boolean
    lat?: boolean
    lng?: boolean
    catalogId?: boolean
    companyId?: boolean
    company?: boolean | Pole$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    catalog?: boolean | Pole$catalogArgs<ExtArgs>
  }, ExtArgs["result"]["pole"]>

  export type PoleSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    status?: boolean
    lat?: boolean
    lng?: boolean
    catalogId?: boolean
    companyId?: boolean
  }

  export type PoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Pole$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    catalog?: boolean | Pole$catalogArgs<ExtArgs>
  }
  export type PoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Pole$companyArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    catalog?: boolean | Pole$catalogArgs<ExtArgs>
  }

  export type $PolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pole"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs>
      catalog: Prisma.$CatalogPolePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      status: $Enums.EquipmentStatus
      lat: number
      lng: number
      catalogId: string | null
      companyId: string | null
    }, ExtArgs["result"]["pole"]>
    composites: {}
  }

  type PoleGetPayload<S extends boolean | null | undefined | PoleDefaultArgs> = $Result.GetResult<Prisma.$PolePayload, S>

  type PoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PoleCountAggregateInputType | true
    }

  export interface PoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pole'], meta: { name: 'Pole' } }
    /**
     * Find zero or one Pole that matches the filter.
     * @param {PoleFindUniqueArgs} args - Arguments to find a Pole
     * @example
     * // Get one Pole
     * const pole = await prisma.pole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PoleFindUniqueArgs>(args: SelectSubset<T, PoleFindUniqueArgs<ExtArgs>>): Prisma__PoleClient<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PoleFindUniqueOrThrowArgs} args - Arguments to find a Pole
     * @example
     * // Get one Pole
     * const pole = await prisma.pole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PoleFindUniqueOrThrowArgs>(args: SelectSubset<T, PoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PoleClient<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleFindFirstArgs} args - Arguments to find a Pole
     * @example
     * // Get one Pole
     * const pole = await prisma.pole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PoleFindFirstArgs>(args?: SelectSubset<T, PoleFindFirstArgs<ExtArgs>>): Prisma__PoleClient<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleFindFirstOrThrowArgs} args - Arguments to find a Pole
     * @example
     * // Get one Pole
     * const pole = await prisma.pole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PoleFindFirstOrThrowArgs>(args?: SelectSubset<T, PoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PoleClient<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Poles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Poles
     * const poles = await prisma.pole.findMany()
     * 
     * // Get first 10 Poles
     * const poles = await prisma.pole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poleWithIdOnly = await prisma.pole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PoleFindManyArgs>(args?: SelectSubset<T, PoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pole.
     * @param {PoleCreateArgs} args - Arguments to create a Pole.
     * @example
     * // Create one Pole
     * const Pole = await prisma.pole.create({
     *   data: {
     *     // ... data to create a Pole
     *   }
     * })
     * 
     */
    create<T extends PoleCreateArgs>(args: SelectSubset<T, PoleCreateArgs<ExtArgs>>): Prisma__PoleClient<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Poles.
     * @param {PoleCreateManyArgs} args - Arguments to create many Poles.
     * @example
     * // Create many Poles
     * const pole = await prisma.pole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PoleCreateManyArgs>(args?: SelectSubset<T, PoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Poles and returns the data saved in the database.
     * @param {PoleCreateManyAndReturnArgs} args - Arguments to create many Poles.
     * @example
     * // Create many Poles
     * const pole = await prisma.pole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Poles and only return the `id`
     * const poleWithIdOnly = await prisma.pole.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PoleCreateManyAndReturnArgs>(args?: SelectSubset<T, PoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pole.
     * @param {PoleDeleteArgs} args - Arguments to delete one Pole.
     * @example
     * // Delete one Pole
     * const Pole = await prisma.pole.delete({
     *   where: {
     *     // ... filter to delete one Pole
     *   }
     * })
     * 
     */
    delete<T extends PoleDeleteArgs>(args: SelectSubset<T, PoleDeleteArgs<ExtArgs>>): Prisma__PoleClient<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pole.
     * @param {PoleUpdateArgs} args - Arguments to update one Pole.
     * @example
     * // Update one Pole
     * const pole = await prisma.pole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PoleUpdateArgs>(args: SelectSubset<T, PoleUpdateArgs<ExtArgs>>): Prisma__PoleClient<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Poles.
     * @param {PoleDeleteManyArgs} args - Arguments to filter Poles to delete.
     * @example
     * // Delete a few Poles
     * const { count } = await prisma.pole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PoleDeleteManyArgs>(args?: SelectSubset<T, PoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Poles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Poles
     * const pole = await prisma.pole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PoleUpdateManyArgs>(args: SelectSubset<T, PoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pole.
     * @param {PoleUpsertArgs} args - Arguments to update or create a Pole.
     * @example
     * // Update or create a Pole
     * const pole = await prisma.pole.upsert({
     *   create: {
     *     // ... data to create a Pole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pole we want to update
     *   }
     * })
     */
    upsert<T extends PoleUpsertArgs>(args: SelectSubset<T, PoleUpsertArgs<ExtArgs>>): Prisma__PoleClient<$Result.GetResult<Prisma.$PolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Poles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleCountArgs} args - Arguments to filter Poles to count.
     * @example
     * // Count the number of Poles
     * const count = await prisma.pole.count({
     *   where: {
     *     // ... the filter for the Poles we want to count
     *   }
     * })
    **/
    count<T extends PoleCountArgs>(
      args?: Subset<T, PoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PoleAggregateArgs>(args: Subset<T, PoleAggregateArgs>): Prisma.PrismaPromise<GetPoleAggregateType<T>>

    /**
     * Group by Pole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PoleGroupByArgs['orderBy'] }
        : { orderBy?: PoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pole model
   */
  readonly fields: PoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends Pole$companyArgs<ExtArgs> = {}>(args?: Subset<T, Pole$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    catalog<T extends Pole$catalogArgs<ExtArgs> = {}>(args?: Subset<T, Pole$catalogArgs<ExtArgs>>): Prisma__CatalogPoleClient<$Result.GetResult<Prisma.$CatalogPolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pole model
   */ 
  interface PoleFieldRefs {
    readonly id: FieldRef<"Pole", 'String'>
    readonly projectId: FieldRef<"Pole", 'String'>
    readonly name: FieldRef<"Pole", 'String'>
    readonly status: FieldRef<"Pole", 'EquipmentStatus'>
    readonly lat: FieldRef<"Pole", 'Float'>
    readonly lng: FieldRef<"Pole", 'Float'>
    readonly catalogId: FieldRef<"Pole", 'String'>
    readonly companyId: FieldRef<"Pole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pole findUnique
   */
  export type PoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
    /**
     * Filter, which Pole to fetch.
     */
    where: PoleWhereUniqueInput
  }

  /**
   * Pole findUniqueOrThrow
   */
  export type PoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
    /**
     * Filter, which Pole to fetch.
     */
    where: PoleWhereUniqueInput
  }

  /**
   * Pole findFirst
   */
  export type PoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
    /**
     * Filter, which Pole to fetch.
     */
    where?: PoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Poles to fetch.
     */
    orderBy?: PoleOrderByWithRelationInput | PoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Poles.
     */
    cursor?: PoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Poles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Poles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Poles.
     */
    distinct?: PoleScalarFieldEnum | PoleScalarFieldEnum[]
  }

  /**
   * Pole findFirstOrThrow
   */
  export type PoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
    /**
     * Filter, which Pole to fetch.
     */
    where?: PoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Poles to fetch.
     */
    orderBy?: PoleOrderByWithRelationInput | PoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Poles.
     */
    cursor?: PoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Poles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Poles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Poles.
     */
    distinct?: PoleScalarFieldEnum | PoleScalarFieldEnum[]
  }

  /**
   * Pole findMany
   */
  export type PoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
    /**
     * Filter, which Poles to fetch.
     */
    where?: PoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Poles to fetch.
     */
    orderBy?: PoleOrderByWithRelationInput | PoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Poles.
     */
    cursor?: PoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Poles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Poles.
     */
    skip?: number
    distinct?: PoleScalarFieldEnum | PoleScalarFieldEnum[]
  }

  /**
   * Pole create
   */
  export type PoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Pole.
     */
    data: XOR<PoleCreateInput, PoleUncheckedCreateInput>
  }

  /**
   * Pole createMany
   */
  export type PoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Poles.
     */
    data: PoleCreateManyInput | PoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pole createManyAndReturn
   */
  export type PoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Poles.
     */
    data: PoleCreateManyInput | PoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pole update
   */
  export type PoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Pole.
     */
    data: XOR<PoleUpdateInput, PoleUncheckedUpdateInput>
    /**
     * Choose, which Pole to update.
     */
    where: PoleWhereUniqueInput
  }

  /**
   * Pole updateMany
   */
  export type PoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Poles.
     */
    data: XOR<PoleUpdateManyMutationInput, PoleUncheckedUpdateManyInput>
    /**
     * Filter which Poles to update
     */
    where?: PoleWhereInput
  }

  /**
   * Pole upsert
   */
  export type PoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Pole to update in case it exists.
     */
    where: PoleWhereUniqueInput
    /**
     * In case the Pole found by the `where` argument doesn't exist, create a new Pole with this data.
     */
    create: XOR<PoleCreateInput, PoleUncheckedCreateInput>
    /**
     * In case the Pole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PoleUpdateInput, PoleUncheckedUpdateInput>
  }

  /**
   * Pole delete
   */
  export type PoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
    /**
     * Filter which Pole to delete.
     */
    where: PoleWhereUniqueInput
  }

  /**
   * Pole deleteMany
   */
  export type PoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Poles to delete
     */
    where?: PoleWhereInput
  }

  /**
   * Pole.company
   */
  export type Pole$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Pole.catalog
   */
  export type Pole$catalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPole
     */
    select?: CatalogPoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogPoleInclude<ExtArgs> | null
    where?: CatalogPoleWhereInput
  }

  /**
   * Pole without action
   */
  export type PoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pole
     */
    select?: PoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleInclude<ExtArgs> | null
  }


  /**
   * Model CatalogFusion
   */

  export type AggregateCatalogFusion = {
    _count: CatalogFusionCountAggregateOutputType | null
    _avg: CatalogFusionAvgAggregateOutputType | null
    _sum: CatalogFusionSumAggregateOutputType | null
    _min: CatalogFusionMinAggregateOutputType | null
    _max: CatalogFusionMaxAggregateOutputType | null
  }

  export type CatalogFusionAvgAggregateOutputType = {
    attenuation: number | null
  }

  export type CatalogFusionSumAggregateOutputType = {
    attenuation: number | null
  }

  export type CatalogFusionMinAggregateOutputType = {
    id: string | null
    name: string | null
    attenuation: number | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CatalogFusionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    attenuation: number | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CatalogFusionCountAggregateOutputType = {
    id: number
    name: number
    attenuation: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type CatalogFusionAvgAggregateInputType = {
    attenuation?: true
  }

  export type CatalogFusionSumAggregateInputType = {
    attenuation?: true
  }

  export type CatalogFusionMinAggregateInputType = {
    id?: true
    name?: true
    attenuation?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CatalogFusionMaxAggregateInputType = {
    id?: true
    name?: true
    attenuation?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CatalogFusionCountAggregateInputType = {
    id?: true
    name?: true
    attenuation?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type CatalogFusionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogFusion to aggregate.
     */
    where?: CatalogFusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogFusions to fetch.
     */
    orderBy?: CatalogFusionOrderByWithRelationInput | CatalogFusionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogFusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogFusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogFusions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogFusions
    **/
    _count?: true | CatalogFusionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogFusionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogFusionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogFusionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogFusionMaxAggregateInputType
  }

  export type GetCatalogFusionAggregateType<T extends CatalogFusionAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogFusion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogFusion[P]>
      : GetScalarType<T[P], AggregateCatalogFusion[P]>
  }




  export type CatalogFusionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogFusionWhereInput
    orderBy?: CatalogFusionOrderByWithAggregationInput | CatalogFusionOrderByWithAggregationInput[]
    by: CatalogFusionScalarFieldEnum[] | CatalogFusionScalarFieldEnum
    having?: CatalogFusionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogFusionCountAggregateInputType | true
    _avg?: CatalogFusionAvgAggregateInputType
    _sum?: CatalogFusionSumAggregateInputType
    _min?: CatalogFusionMinAggregateInputType
    _max?: CatalogFusionMaxAggregateInputType
  }

  export type CatalogFusionGroupByOutputType = {
    id: string
    name: string
    attenuation: number
    createdAt: Date
    updatedAt: Date
    companyId: string | null
    _count: CatalogFusionCountAggregateOutputType | null
    _avg: CatalogFusionAvgAggregateOutputType | null
    _sum: CatalogFusionSumAggregateOutputType | null
    _min: CatalogFusionMinAggregateOutputType | null
    _max: CatalogFusionMaxAggregateOutputType | null
  }

  type GetCatalogFusionGroupByPayload<T extends CatalogFusionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogFusionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogFusionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogFusionGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogFusionGroupByOutputType[P]>
        }
      >
    >


  export type CatalogFusionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    attenuation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CatalogFusion$companyArgs<ExtArgs>
  }, ExtArgs["result"]["catalogFusion"]>

  export type CatalogFusionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    attenuation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CatalogFusion$companyArgs<ExtArgs>
  }, ExtArgs["result"]["catalogFusion"]>

  export type CatalogFusionSelectScalar = {
    id?: boolean
    name?: boolean
    attenuation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type CatalogFusionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CatalogFusion$companyArgs<ExtArgs>
  }
  export type CatalogFusionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CatalogFusion$companyArgs<ExtArgs>
  }

  export type $CatalogFusionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogFusion"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      attenuation: number
      createdAt: Date
      updatedAt: Date
      companyId: string | null
    }, ExtArgs["result"]["catalogFusion"]>
    composites: {}
  }

  type CatalogFusionGetPayload<S extends boolean | null | undefined | CatalogFusionDefaultArgs> = $Result.GetResult<Prisma.$CatalogFusionPayload, S>

  type CatalogFusionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogFusionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogFusionCountAggregateInputType | true
    }

  export interface CatalogFusionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogFusion'], meta: { name: 'CatalogFusion' } }
    /**
     * Find zero or one CatalogFusion that matches the filter.
     * @param {CatalogFusionFindUniqueArgs} args - Arguments to find a CatalogFusion
     * @example
     * // Get one CatalogFusion
     * const catalogFusion = await prisma.catalogFusion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogFusionFindUniqueArgs>(args: SelectSubset<T, CatalogFusionFindUniqueArgs<ExtArgs>>): Prisma__CatalogFusionClient<$Result.GetResult<Prisma.$CatalogFusionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatalogFusion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogFusionFindUniqueOrThrowArgs} args - Arguments to find a CatalogFusion
     * @example
     * // Get one CatalogFusion
     * const catalogFusion = await prisma.catalogFusion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogFusionFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogFusionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogFusionClient<$Result.GetResult<Prisma.$CatalogFusionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatalogFusion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFusionFindFirstArgs} args - Arguments to find a CatalogFusion
     * @example
     * // Get one CatalogFusion
     * const catalogFusion = await prisma.catalogFusion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogFusionFindFirstArgs>(args?: SelectSubset<T, CatalogFusionFindFirstArgs<ExtArgs>>): Prisma__CatalogFusionClient<$Result.GetResult<Prisma.$CatalogFusionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatalogFusion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFusionFindFirstOrThrowArgs} args - Arguments to find a CatalogFusion
     * @example
     * // Get one CatalogFusion
     * const catalogFusion = await prisma.catalogFusion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogFusionFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogFusionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogFusionClient<$Result.GetResult<Prisma.$CatalogFusionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatalogFusions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFusionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogFusions
     * const catalogFusions = await prisma.catalogFusion.findMany()
     * 
     * // Get first 10 CatalogFusions
     * const catalogFusions = await prisma.catalogFusion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogFusionWithIdOnly = await prisma.catalogFusion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogFusionFindManyArgs>(args?: SelectSubset<T, CatalogFusionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogFusionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatalogFusion.
     * @param {CatalogFusionCreateArgs} args - Arguments to create a CatalogFusion.
     * @example
     * // Create one CatalogFusion
     * const CatalogFusion = await prisma.catalogFusion.create({
     *   data: {
     *     // ... data to create a CatalogFusion
     *   }
     * })
     * 
     */
    create<T extends CatalogFusionCreateArgs>(args: SelectSubset<T, CatalogFusionCreateArgs<ExtArgs>>): Prisma__CatalogFusionClient<$Result.GetResult<Prisma.$CatalogFusionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatalogFusions.
     * @param {CatalogFusionCreateManyArgs} args - Arguments to create many CatalogFusions.
     * @example
     * // Create many CatalogFusions
     * const catalogFusion = await prisma.catalogFusion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogFusionCreateManyArgs>(args?: SelectSubset<T, CatalogFusionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogFusions and returns the data saved in the database.
     * @param {CatalogFusionCreateManyAndReturnArgs} args - Arguments to create many CatalogFusions.
     * @example
     * // Create many CatalogFusions
     * const catalogFusion = await prisma.catalogFusion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogFusions and only return the `id`
     * const catalogFusionWithIdOnly = await prisma.catalogFusion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatalogFusionCreateManyAndReturnArgs>(args?: SelectSubset<T, CatalogFusionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogFusionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CatalogFusion.
     * @param {CatalogFusionDeleteArgs} args - Arguments to delete one CatalogFusion.
     * @example
     * // Delete one CatalogFusion
     * const CatalogFusion = await prisma.catalogFusion.delete({
     *   where: {
     *     // ... filter to delete one CatalogFusion
     *   }
     * })
     * 
     */
    delete<T extends CatalogFusionDeleteArgs>(args: SelectSubset<T, CatalogFusionDeleteArgs<ExtArgs>>): Prisma__CatalogFusionClient<$Result.GetResult<Prisma.$CatalogFusionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatalogFusion.
     * @param {CatalogFusionUpdateArgs} args - Arguments to update one CatalogFusion.
     * @example
     * // Update one CatalogFusion
     * const catalogFusion = await prisma.catalogFusion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogFusionUpdateArgs>(args: SelectSubset<T, CatalogFusionUpdateArgs<ExtArgs>>): Prisma__CatalogFusionClient<$Result.GetResult<Prisma.$CatalogFusionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatalogFusions.
     * @param {CatalogFusionDeleteManyArgs} args - Arguments to filter CatalogFusions to delete.
     * @example
     * // Delete a few CatalogFusions
     * const { count } = await prisma.catalogFusion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogFusionDeleteManyArgs>(args?: SelectSubset<T, CatalogFusionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogFusions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFusionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogFusions
     * const catalogFusion = await prisma.catalogFusion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogFusionUpdateManyArgs>(args: SelectSubset<T, CatalogFusionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogFusion.
     * @param {CatalogFusionUpsertArgs} args - Arguments to update or create a CatalogFusion.
     * @example
     * // Update or create a CatalogFusion
     * const catalogFusion = await prisma.catalogFusion.upsert({
     *   create: {
     *     // ... data to create a CatalogFusion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogFusion we want to update
     *   }
     * })
     */
    upsert<T extends CatalogFusionUpsertArgs>(args: SelectSubset<T, CatalogFusionUpsertArgs<ExtArgs>>): Prisma__CatalogFusionClient<$Result.GetResult<Prisma.$CatalogFusionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatalogFusions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFusionCountArgs} args - Arguments to filter CatalogFusions to count.
     * @example
     * // Count the number of CatalogFusions
     * const count = await prisma.catalogFusion.count({
     *   where: {
     *     // ... the filter for the CatalogFusions we want to count
     *   }
     * })
    **/
    count<T extends CatalogFusionCountArgs>(
      args?: Subset<T, CatalogFusionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogFusionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogFusion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFusionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogFusionAggregateArgs>(args: Subset<T, CatalogFusionAggregateArgs>): Prisma.PrismaPromise<GetCatalogFusionAggregateType<T>>

    /**
     * Group by CatalogFusion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFusionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogFusionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogFusionGroupByArgs['orderBy'] }
        : { orderBy?: CatalogFusionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogFusionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogFusionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogFusion model
   */
  readonly fields: CatalogFusionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogFusion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogFusionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CatalogFusion$companyArgs<ExtArgs> = {}>(args?: Subset<T, CatalogFusion$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatalogFusion model
   */ 
  interface CatalogFusionFieldRefs {
    readonly id: FieldRef<"CatalogFusion", 'String'>
    readonly name: FieldRef<"CatalogFusion", 'String'>
    readonly attenuation: FieldRef<"CatalogFusion", 'Float'>
    readonly createdAt: FieldRef<"CatalogFusion", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogFusion", 'DateTime'>
    readonly companyId: FieldRef<"CatalogFusion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CatalogFusion findUnique
   */
  export type CatalogFusionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogFusion
     */
    select?: CatalogFusionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogFusionInclude<ExtArgs> | null
    /**
     * Filter, which CatalogFusion to fetch.
     */
    where: CatalogFusionWhereUniqueInput
  }

  /**
   * CatalogFusion findUniqueOrThrow
   */
  export type CatalogFusionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogFusion
     */
    select?: CatalogFusionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogFusionInclude<ExtArgs> | null
    /**
     * Filter, which CatalogFusion to fetch.
     */
    where: CatalogFusionWhereUniqueInput
  }

  /**
   * CatalogFusion findFirst
   */
  export type CatalogFusionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogFusion
     */
    select?: CatalogFusionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogFusionInclude<ExtArgs> | null
    /**
     * Filter, which CatalogFusion to fetch.
     */
    where?: CatalogFusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogFusions to fetch.
     */
    orderBy?: CatalogFusionOrderByWithRelationInput | CatalogFusionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogFusions.
     */
    cursor?: CatalogFusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogFusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogFusions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogFusions.
     */
    distinct?: CatalogFusionScalarFieldEnum | CatalogFusionScalarFieldEnum[]
  }

  /**
   * CatalogFusion findFirstOrThrow
   */
  export type CatalogFusionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogFusion
     */
    select?: CatalogFusionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogFusionInclude<ExtArgs> | null
    /**
     * Filter, which CatalogFusion to fetch.
     */
    where?: CatalogFusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogFusions to fetch.
     */
    orderBy?: CatalogFusionOrderByWithRelationInput | CatalogFusionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogFusions.
     */
    cursor?: CatalogFusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogFusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogFusions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogFusions.
     */
    distinct?: CatalogFusionScalarFieldEnum | CatalogFusionScalarFieldEnum[]
  }

  /**
   * CatalogFusion findMany
   */
  export type CatalogFusionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogFusion
     */
    select?: CatalogFusionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogFusionInclude<ExtArgs> | null
    /**
     * Filter, which CatalogFusions to fetch.
     */
    where?: CatalogFusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogFusions to fetch.
     */
    orderBy?: CatalogFusionOrderByWithRelationInput | CatalogFusionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogFusions.
     */
    cursor?: CatalogFusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogFusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogFusions.
     */
    skip?: number
    distinct?: CatalogFusionScalarFieldEnum | CatalogFusionScalarFieldEnum[]
  }

  /**
   * CatalogFusion create
   */
  export type CatalogFusionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogFusion
     */
    select?: CatalogFusionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogFusionInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogFusion.
     */
    data: XOR<CatalogFusionCreateInput, CatalogFusionUncheckedCreateInput>
  }

  /**
   * CatalogFusion createMany
   */
  export type CatalogFusionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogFusions.
     */
    data: CatalogFusionCreateManyInput | CatalogFusionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogFusion createManyAndReturn
   */
  export type CatalogFusionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogFusion
     */
    select?: CatalogFusionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CatalogFusions.
     */
    data: CatalogFusionCreateManyInput | CatalogFusionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogFusionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatalogFusion update
   */
  export type CatalogFusionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogFusion
     */
    select?: CatalogFusionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogFusionInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogFusion.
     */
    data: XOR<CatalogFusionUpdateInput, CatalogFusionUncheckedUpdateInput>
    /**
     * Choose, which CatalogFusion to update.
     */
    where: CatalogFusionWhereUniqueInput
  }

  /**
   * CatalogFusion updateMany
   */
  export type CatalogFusionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogFusions.
     */
    data: XOR<CatalogFusionUpdateManyMutationInput, CatalogFusionUncheckedUpdateManyInput>
    /**
     * Filter which CatalogFusions to update
     */
    where?: CatalogFusionWhereInput
  }

  /**
   * CatalogFusion upsert
   */
  export type CatalogFusionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogFusion
     */
    select?: CatalogFusionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogFusionInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogFusion to update in case it exists.
     */
    where: CatalogFusionWhereUniqueInput
    /**
     * In case the CatalogFusion found by the `where` argument doesn't exist, create a new CatalogFusion with this data.
     */
    create: XOR<CatalogFusionCreateInput, CatalogFusionUncheckedCreateInput>
    /**
     * In case the CatalogFusion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogFusionUpdateInput, CatalogFusionUncheckedUpdateInput>
  }

  /**
   * CatalogFusion delete
   */
  export type CatalogFusionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogFusion
     */
    select?: CatalogFusionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogFusionInclude<ExtArgs> | null
    /**
     * Filter which CatalogFusion to delete.
     */
    where: CatalogFusionWhereUniqueInput
  }

  /**
   * CatalogFusion deleteMany
   */
  export type CatalogFusionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogFusions to delete
     */
    where?: CatalogFusionWhereInput
  }

  /**
   * CatalogFusion.company
   */
  export type CatalogFusion$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * CatalogFusion without action
   */
  export type CatalogFusionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogFusion
     */
    select?: CatalogFusionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogFusionInclude<ExtArgs> | null
  }


  /**
   * Model TemplateFusion
   */

  export type AggregateTemplateFusion = {
    _count: TemplateFusionCountAggregateOutputType | null
    _avg: TemplateFusionAvgAggregateOutputType | null
    _sum: TemplateFusionSumAggregateOutputType | null
    _min: TemplateFusionMinAggregateOutputType | null
    _max: TemplateFusionMaxAggregateOutputType | null
  }

  export type TemplateFusionAvgAggregateOutputType = {
    attenuation: number | null
  }

  export type TemplateFusionSumAggregateOutputType = {
    attenuation: number | null
  }

  export type TemplateFusionMinAggregateOutputType = {
    id: string | null
    name: string | null
    attenuation: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateFusionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    attenuation: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateFusionCountAggregateOutputType = {
    id: number
    name: number
    attenuation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateFusionAvgAggregateInputType = {
    attenuation?: true
  }

  export type TemplateFusionSumAggregateInputType = {
    attenuation?: true
  }

  export type TemplateFusionMinAggregateInputType = {
    id?: true
    name?: true
    attenuation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateFusionMaxAggregateInputType = {
    id?: true
    name?: true
    attenuation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateFusionCountAggregateInputType = {
    id?: true
    name?: true
    attenuation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateFusionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateFusion to aggregate.
     */
    where?: TemplateFusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateFusions to fetch.
     */
    orderBy?: TemplateFusionOrderByWithRelationInput | TemplateFusionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateFusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateFusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateFusions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateFusions
    **/
    _count?: true | TemplateFusionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateFusionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateFusionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateFusionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateFusionMaxAggregateInputType
  }

  export type GetTemplateFusionAggregateType<T extends TemplateFusionAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateFusion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateFusion[P]>
      : GetScalarType<T[P], AggregateTemplateFusion[P]>
  }




  export type TemplateFusionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateFusionWhereInput
    orderBy?: TemplateFusionOrderByWithAggregationInput | TemplateFusionOrderByWithAggregationInput[]
    by: TemplateFusionScalarFieldEnum[] | TemplateFusionScalarFieldEnum
    having?: TemplateFusionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateFusionCountAggregateInputType | true
    _avg?: TemplateFusionAvgAggregateInputType
    _sum?: TemplateFusionSumAggregateInputType
    _min?: TemplateFusionMinAggregateInputType
    _max?: TemplateFusionMaxAggregateInputType
  }

  export type TemplateFusionGroupByOutputType = {
    id: string
    name: string
    attenuation: number
    createdAt: Date
    updatedAt: Date
    _count: TemplateFusionCountAggregateOutputType | null
    _avg: TemplateFusionAvgAggregateOutputType | null
    _sum: TemplateFusionSumAggregateOutputType | null
    _min: TemplateFusionMinAggregateOutputType | null
    _max: TemplateFusionMaxAggregateOutputType | null
  }

  type GetTemplateFusionGroupByPayload<T extends TemplateFusionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateFusionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateFusionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateFusionGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateFusionGroupByOutputType[P]>
        }
      >
    >


  export type TemplateFusionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    attenuation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templateFusion"]>

  export type TemplateFusionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    attenuation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templateFusion"]>

  export type TemplateFusionSelectScalar = {
    id?: boolean
    name?: boolean
    attenuation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TemplateFusionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateFusion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      attenuation: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["templateFusion"]>
    composites: {}
  }

  type TemplateFusionGetPayload<S extends boolean | null | undefined | TemplateFusionDefaultArgs> = $Result.GetResult<Prisma.$TemplateFusionPayload, S>

  type TemplateFusionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateFusionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateFusionCountAggregateInputType | true
    }

  export interface TemplateFusionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateFusion'], meta: { name: 'TemplateFusion' } }
    /**
     * Find zero or one TemplateFusion that matches the filter.
     * @param {TemplateFusionFindUniqueArgs} args - Arguments to find a TemplateFusion
     * @example
     * // Get one TemplateFusion
     * const templateFusion = await prisma.templateFusion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateFusionFindUniqueArgs>(args: SelectSubset<T, TemplateFusionFindUniqueArgs<ExtArgs>>): Prisma__TemplateFusionClient<$Result.GetResult<Prisma.$TemplateFusionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TemplateFusion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TemplateFusionFindUniqueOrThrowArgs} args - Arguments to find a TemplateFusion
     * @example
     * // Get one TemplateFusion
     * const templateFusion = await prisma.templateFusion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateFusionFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateFusionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateFusionClient<$Result.GetResult<Prisma.$TemplateFusionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TemplateFusion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFusionFindFirstArgs} args - Arguments to find a TemplateFusion
     * @example
     * // Get one TemplateFusion
     * const templateFusion = await prisma.templateFusion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateFusionFindFirstArgs>(args?: SelectSubset<T, TemplateFusionFindFirstArgs<ExtArgs>>): Prisma__TemplateFusionClient<$Result.GetResult<Prisma.$TemplateFusionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TemplateFusion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFusionFindFirstOrThrowArgs} args - Arguments to find a TemplateFusion
     * @example
     * // Get one TemplateFusion
     * const templateFusion = await prisma.templateFusion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateFusionFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateFusionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateFusionClient<$Result.GetResult<Prisma.$TemplateFusionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TemplateFusions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFusionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateFusions
     * const templateFusions = await prisma.templateFusion.findMany()
     * 
     * // Get first 10 TemplateFusions
     * const templateFusions = await prisma.templateFusion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateFusionWithIdOnly = await prisma.templateFusion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateFusionFindManyArgs>(args?: SelectSubset<T, TemplateFusionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateFusionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TemplateFusion.
     * @param {TemplateFusionCreateArgs} args - Arguments to create a TemplateFusion.
     * @example
     * // Create one TemplateFusion
     * const TemplateFusion = await prisma.templateFusion.create({
     *   data: {
     *     // ... data to create a TemplateFusion
     *   }
     * })
     * 
     */
    create<T extends TemplateFusionCreateArgs>(args: SelectSubset<T, TemplateFusionCreateArgs<ExtArgs>>): Prisma__TemplateFusionClient<$Result.GetResult<Prisma.$TemplateFusionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TemplateFusions.
     * @param {TemplateFusionCreateManyArgs} args - Arguments to create many TemplateFusions.
     * @example
     * // Create many TemplateFusions
     * const templateFusion = await prisma.templateFusion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateFusionCreateManyArgs>(args?: SelectSubset<T, TemplateFusionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateFusions and returns the data saved in the database.
     * @param {TemplateFusionCreateManyAndReturnArgs} args - Arguments to create many TemplateFusions.
     * @example
     * // Create many TemplateFusions
     * const templateFusion = await prisma.templateFusion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateFusions and only return the `id`
     * const templateFusionWithIdOnly = await prisma.templateFusion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateFusionCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateFusionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateFusionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TemplateFusion.
     * @param {TemplateFusionDeleteArgs} args - Arguments to delete one TemplateFusion.
     * @example
     * // Delete one TemplateFusion
     * const TemplateFusion = await prisma.templateFusion.delete({
     *   where: {
     *     // ... filter to delete one TemplateFusion
     *   }
     * })
     * 
     */
    delete<T extends TemplateFusionDeleteArgs>(args: SelectSubset<T, TemplateFusionDeleteArgs<ExtArgs>>): Prisma__TemplateFusionClient<$Result.GetResult<Prisma.$TemplateFusionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TemplateFusion.
     * @param {TemplateFusionUpdateArgs} args - Arguments to update one TemplateFusion.
     * @example
     * // Update one TemplateFusion
     * const templateFusion = await prisma.templateFusion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateFusionUpdateArgs>(args: SelectSubset<T, TemplateFusionUpdateArgs<ExtArgs>>): Prisma__TemplateFusionClient<$Result.GetResult<Prisma.$TemplateFusionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TemplateFusions.
     * @param {TemplateFusionDeleteManyArgs} args - Arguments to filter TemplateFusions to delete.
     * @example
     * // Delete a few TemplateFusions
     * const { count } = await prisma.templateFusion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateFusionDeleteManyArgs>(args?: SelectSubset<T, TemplateFusionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateFusions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFusionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateFusions
     * const templateFusion = await prisma.templateFusion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateFusionUpdateManyArgs>(args: SelectSubset<T, TemplateFusionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateFusion.
     * @param {TemplateFusionUpsertArgs} args - Arguments to update or create a TemplateFusion.
     * @example
     * // Update or create a TemplateFusion
     * const templateFusion = await prisma.templateFusion.upsert({
     *   create: {
     *     // ... data to create a TemplateFusion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateFusion we want to update
     *   }
     * })
     */
    upsert<T extends TemplateFusionUpsertArgs>(args: SelectSubset<T, TemplateFusionUpsertArgs<ExtArgs>>): Prisma__TemplateFusionClient<$Result.GetResult<Prisma.$TemplateFusionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TemplateFusions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFusionCountArgs} args - Arguments to filter TemplateFusions to count.
     * @example
     * // Count the number of TemplateFusions
     * const count = await prisma.templateFusion.count({
     *   where: {
     *     // ... the filter for the TemplateFusions we want to count
     *   }
     * })
    **/
    count<T extends TemplateFusionCountArgs>(
      args?: Subset<T, TemplateFusionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateFusionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateFusion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFusionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateFusionAggregateArgs>(args: Subset<T, TemplateFusionAggregateArgs>): Prisma.PrismaPromise<GetTemplateFusionAggregateType<T>>

    /**
     * Group by TemplateFusion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFusionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateFusionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateFusionGroupByArgs['orderBy'] }
        : { orderBy?: TemplateFusionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateFusionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateFusionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateFusion model
   */
  readonly fields: TemplateFusionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateFusion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateFusionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateFusion model
   */ 
  interface TemplateFusionFieldRefs {
    readonly id: FieldRef<"TemplateFusion", 'String'>
    readonly name: FieldRef<"TemplateFusion", 'String'>
    readonly attenuation: FieldRef<"TemplateFusion", 'Float'>
    readonly createdAt: FieldRef<"TemplateFusion", 'DateTime'>
    readonly updatedAt: FieldRef<"TemplateFusion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TemplateFusion findUnique
   */
  export type TemplateFusionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateFusion
     */
    select?: TemplateFusionSelect<ExtArgs> | null
    /**
     * Filter, which TemplateFusion to fetch.
     */
    where: TemplateFusionWhereUniqueInput
  }

  /**
   * TemplateFusion findUniqueOrThrow
   */
  export type TemplateFusionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateFusion
     */
    select?: TemplateFusionSelect<ExtArgs> | null
    /**
     * Filter, which TemplateFusion to fetch.
     */
    where: TemplateFusionWhereUniqueInput
  }

  /**
   * TemplateFusion findFirst
   */
  export type TemplateFusionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateFusion
     */
    select?: TemplateFusionSelect<ExtArgs> | null
    /**
     * Filter, which TemplateFusion to fetch.
     */
    where?: TemplateFusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateFusions to fetch.
     */
    orderBy?: TemplateFusionOrderByWithRelationInput | TemplateFusionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateFusions.
     */
    cursor?: TemplateFusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateFusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateFusions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateFusions.
     */
    distinct?: TemplateFusionScalarFieldEnum | TemplateFusionScalarFieldEnum[]
  }

  /**
   * TemplateFusion findFirstOrThrow
   */
  export type TemplateFusionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateFusion
     */
    select?: TemplateFusionSelect<ExtArgs> | null
    /**
     * Filter, which TemplateFusion to fetch.
     */
    where?: TemplateFusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateFusions to fetch.
     */
    orderBy?: TemplateFusionOrderByWithRelationInput | TemplateFusionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateFusions.
     */
    cursor?: TemplateFusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateFusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateFusions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateFusions.
     */
    distinct?: TemplateFusionScalarFieldEnum | TemplateFusionScalarFieldEnum[]
  }

  /**
   * TemplateFusion findMany
   */
  export type TemplateFusionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateFusion
     */
    select?: TemplateFusionSelect<ExtArgs> | null
    /**
     * Filter, which TemplateFusions to fetch.
     */
    where?: TemplateFusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateFusions to fetch.
     */
    orderBy?: TemplateFusionOrderByWithRelationInput | TemplateFusionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateFusions.
     */
    cursor?: TemplateFusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateFusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateFusions.
     */
    skip?: number
    distinct?: TemplateFusionScalarFieldEnum | TemplateFusionScalarFieldEnum[]
  }

  /**
   * TemplateFusion create
   */
  export type TemplateFusionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateFusion
     */
    select?: TemplateFusionSelect<ExtArgs> | null
    /**
     * The data needed to create a TemplateFusion.
     */
    data: XOR<TemplateFusionCreateInput, TemplateFusionUncheckedCreateInput>
  }

  /**
   * TemplateFusion createMany
   */
  export type TemplateFusionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateFusions.
     */
    data: TemplateFusionCreateManyInput | TemplateFusionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateFusion createManyAndReturn
   */
  export type TemplateFusionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateFusion
     */
    select?: TemplateFusionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TemplateFusions.
     */
    data: TemplateFusionCreateManyInput | TemplateFusionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateFusion update
   */
  export type TemplateFusionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateFusion
     */
    select?: TemplateFusionSelect<ExtArgs> | null
    /**
     * The data needed to update a TemplateFusion.
     */
    data: XOR<TemplateFusionUpdateInput, TemplateFusionUncheckedUpdateInput>
    /**
     * Choose, which TemplateFusion to update.
     */
    where: TemplateFusionWhereUniqueInput
  }

  /**
   * TemplateFusion updateMany
   */
  export type TemplateFusionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateFusions.
     */
    data: XOR<TemplateFusionUpdateManyMutationInput, TemplateFusionUncheckedUpdateManyInput>
    /**
     * Filter which TemplateFusions to update
     */
    where?: TemplateFusionWhereInput
  }

  /**
   * TemplateFusion upsert
   */
  export type TemplateFusionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateFusion
     */
    select?: TemplateFusionSelect<ExtArgs> | null
    /**
     * The filter to search for the TemplateFusion to update in case it exists.
     */
    where: TemplateFusionWhereUniqueInput
    /**
     * In case the TemplateFusion found by the `where` argument doesn't exist, create a new TemplateFusion with this data.
     */
    create: XOR<TemplateFusionCreateInput, TemplateFusionUncheckedCreateInput>
    /**
     * In case the TemplateFusion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateFusionUpdateInput, TemplateFusionUncheckedUpdateInput>
  }

  /**
   * TemplateFusion delete
   */
  export type TemplateFusionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateFusion
     */
    select?: TemplateFusionSelect<ExtArgs> | null
    /**
     * Filter which TemplateFusion to delete.
     */
    where: TemplateFusionWhereUniqueInput
  }

  /**
   * TemplateFusion deleteMany
   */
  export type TemplateFusionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateFusions to delete
     */
    where?: TemplateFusionWhereInput
  }

  /**
   * TemplateFusion without action
   */
  export type TemplateFusionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateFusion
     */
    select?: TemplateFusionSelect<ExtArgs> | null
  }


  /**
   * Model CatalogOLT
   */

  export type AggregateCatalogOLT = {
    _count: CatalogOLTCountAggregateOutputType | null
    _avg: CatalogOLTAvgAggregateOutputType | null
    _sum: CatalogOLTSumAggregateOutputType | null
    _min: CatalogOLTMinAggregateOutputType | null
    _max: CatalogOLTMaxAggregateOutputType | null
  }

  export type CatalogOLTAvgAggregateOutputType = {
    outputPower: number | null
    slots: number | null
    portsPerSlot: number | null
  }

  export type CatalogOLTSumAggregateOutputType = {
    outputPower: number | null
    slots: number | null
    portsPerSlot: number | null
  }

  export type CatalogOLTMinAggregateOutputType = {
    id: string | null
    name: string | null
    outputPower: number | null
    slots: number | null
    portsPerSlot: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CatalogOLTMaxAggregateOutputType = {
    id: string | null
    name: string | null
    outputPower: number | null
    slots: number | null
    portsPerSlot: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CatalogOLTCountAggregateOutputType = {
    id: number
    name: number
    outputPower: number
    slots: number
    portsPerSlot: number
    description: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type CatalogOLTAvgAggregateInputType = {
    outputPower?: true
    slots?: true
    portsPerSlot?: true
  }

  export type CatalogOLTSumAggregateInputType = {
    outputPower?: true
    slots?: true
    portsPerSlot?: true
  }

  export type CatalogOLTMinAggregateInputType = {
    id?: true
    name?: true
    outputPower?: true
    slots?: true
    portsPerSlot?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CatalogOLTMaxAggregateInputType = {
    id?: true
    name?: true
    outputPower?: true
    slots?: true
    portsPerSlot?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CatalogOLTCountAggregateInputType = {
    id?: true
    name?: true
    outputPower?: true
    slots?: true
    portsPerSlot?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type CatalogOLTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogOLT to aggregate.
     */
    where?: CatalogOLTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogOLTS to fetch.
     */
    orderBy?: CatalogOLTOrderByWithRelationInput | CatalogOLTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogOLTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogOLTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogOLTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogOLTS
    **/
    _count?: true | CatalogOLTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogOLTAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogOLTSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogOLTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogOLTMaxAggregateInputType
  }

  export type GetCatalogOLTAggregateType<T extends CatalogOLTAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogOLT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogOLT[P]>
      : GetScalarType<T[P], AggregateCatalogOLT[P]>
  }




  export type CatalogOLTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogOLTWhereInput
    orderBy?: CatalogOLTOrderByWithAggregationInput | CatalogOLTOrderByWithAggregationInput[]
    by: CatalogOLTScalarFieldEnum[] | CatalogOLTScalarFieldEnum
    having?: CatalogOLTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogOLTCountAggregateInputType | true
    _avg?: CatalogOLTAvgAggregateInputType
    _sum?: CatalogOLTSumAggregateInputType
    _min?: CatalogOLTMinAggregateInputType
    _max?: CatalogOLTMaxAggregateInputType
  }

  export type CatalogOLTGroupByOutputType = {
    id: string
    name: string
    outputPower: number
    slots: number
    portsPerSlot: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string | null
    _count: CatalogOLTCountAggregateOutputType | null
    _avg: CatalogOLTAvgAggregateOutputType | null
    _sum: CatalogOLTSumAggregateOutputType | null
    _min: CatalogOLTMinAggregateOutputType | null
    _max: CatalogOLTMaxAggregateOutputType | null
  }

  type GetCatalogOLTGroupByPayload<T extends CatalogOLTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogOLTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogOLTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogOLTGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogOLTGroupByOutputType[P]>
        }
      >
    >


  export type CatalogOLTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    outputPower?: boolean
    slots?: boolean
    portsPerSlot?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CatalogOLT$companyArgs<ExtArgs>
  }, ExtArgs["result"]["catalogOLT"]>

  export type CatalogOLTSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    outputPower?: boolean
    slots?: boolean
    portsPerSlot?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CatalogOLT$companyArgs<ExtArgs>
  }, ExtArgs["result"]["catalogOLT"]>

  export type CatalogOLTSelectScalar = {
    id?: boolean
    name?: boolean
    outputPower?: boolean
    slots?: boolean
    portsPerSlot?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type CatalogOLTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CatalogOLT$companyArgs<ExtArgs>
  }
  export type CatalogOLTIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CatalogOLT$companyArgs<ExtArgs>
  }

  export type $CatalogOLTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogOLT"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      outputPower: number
      slots: number
      portsPerSlot: number
      description: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string | null
    }, ExtArgs["result"]["catalogOLT"]>
    composites: {}
  }

  type CatalogOLTGetPayload<S extends boolean | null | undefined | CatalogOLTDefaultArgs> = $Result.GetResult<Prisma.$CatalogOLTPayload, S>

  type CatalogOLTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogOLTFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogOLTCountAggregateInputType | true
    }

  export interface CatalogOLTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogOLT'], meta: { name: 'CatalogOLT' } }
    /**
     * Find zero or one CatalogOLT that matches the filter.
     * @param {CatalogOLTFindUniqueArgs} args - Arguments to find a CatalogOLT
     * @example
     * // Get one CatalogOLT
     * const catalogOLT = await prisma.catalogOLT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogOLTFindUniqueArgs>(args: SelectSubset<T, CatalogOLTFindUniqueArgs<ExtArgs>>): Prisma__CatalogOLTClient<$Result.GetResult<Prisma.$CatalogOLTPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatalogOLT that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogOLTFindUniqueOrThrowArgs} args - Arguments to find a CatalogOLT
     * @example
     * // Get one CatalogOLT
     * const catalogOLT = await prisma.catalogOLT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogOLTFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogOLTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogOLTClient<$Result.GetResult<Prisma.$CatalogOLTPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatalogOLT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogOLTFindFirstArgs} args - Arguments to find a CatalogOLT
     * @example
     * // Get one CatalogOLT
     * const catalogOLT = await prisma.catalogOLT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogOLTFindFirstArgs>(args?: SelectSubset<T, CatalogOLTFindFirstArgs<ExtArgs>>): Prisma__CatalogOLTClient<$Result.GetResult<Prisma.$CatalogOLTPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatalogOLT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogOLTFindFirstOrThrowArgs} args - Arguments to find a CatalogOLT
     * @example
     * // Get one CatalogOLT
     * const catalogOLT = await prisma.catalogOLT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogOLTFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogOLTFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogOLTClient<$Result.GetResult<Prisma.$CatalogOLTPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatalogOLTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogOLTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogOLTS
     * const catalogOLTS = await prisma.catalogOLT.findMany()
     * 
     * // Get first 10 CatalogOLTS
     * const catalogOLTS = await prisma.catalogOLT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogOLTWithIdOnly = await prisma.catalogOLT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogOLTFindManyArgs>(args?: SelectSubset<T, CatalogOLTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogOLTPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatalogOLT.
     * @param {CatalogOLTCreateArgs} args - Arguments to create a CatalogOLT.
     * @example
     * // Create one CatalogOLT
     * const CatalogOLT = await prisma.catalogOLT.create({
     *   data: {
     *     // ... data to create a CatalogOLT
     *   }
     * })
     * 
     */
    create<T extends CatalogOLTCreateArgs>(args: SelectSubset<T, CatalogOLTCreateArgs<ExtArgs>>): Prisma__CatalogOLTClient<$Result.GetResult<Prisma.$CatalogOLTPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatalogOLTS.
     * @param {CatalogOLTCreateManyArgs} args - Arguments to create many CatalogOLTS.
     * @example
     * // Create many CatalogOLTS
     * const catalogOLT = await prisma.catalogOLT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogOLTCreateManyArgs>(args?: SelectSubset<T, CatalogOLTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogOLTS and returns the data saved in the database.
     * @param {CatalogOLTCreateManyAndReturnArgs} args - Arguments to create many CatalogOLTS.
     * @example
     * // Create many CatalogOLTS
     * const catalogOLT = await prisma.catalogOLT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogOLTS and only return the `id`
     * const catalogOLTWithIdOnly = await prisma.catalogOLT.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatalogOLTCreateManyAndReturnArgs>(args?: SelectSubset<T, CatalogOLTCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogOLTPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CatalogOLT.
     * @param {CatalogOLTDeleteArgs} args - Arguments to delete one CatalogOLT.
     * @example
     * // Delete one CatalogOLT
     * const CatalogOLT = await prisma.catalogOLT.delete({
     *   where: {
     *     // ... filter to delete one CatalogOLT
     *   }
     * })
     * 
     */
    delete<T extends CatalogOLTDeleteArgs>(args: SelectSubset<T, CatalogOLTDeleteArgs<ExtArgs>>): Prisma__CatalogOLTClient<$Result.GetResult<Prisma.$CatalogOLTPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatalogOLT.
     * @param {CatalogOLTUpdateArgs} args - Arguments to update one CatalogOLT.
     * @example
     * // Update one CatalogOLT
     * const catalogOLT = await prisma.catalogOLT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogOLTUpdateArgs>(args: SelectSubset<T, CatalogOLTUpdateArgs<ExtArgs>>): Prisma__CatalogOLTClient<$Result.GetResult<Prisma.$CatalogOLTPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatalogOLTS.
     * @param {CatalogOLTDeleteManyArgs} args - Arguments to filter CatalogOLTS to delete.
     * @example
     * // Delete a few CatalogOLTS
     * const { count } = await prisma.catalogOLT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogOLTDeleteManyArgs>(args?: SelectSubset<T, CatalogOLTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogOLTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogOLTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogOLTS
     * const catalogOLT = await prisma.catalogOLT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogOLTUpdateManyArgs>(args: SelectSubset<T, CatalogOLTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogOLT.
     * @param {CatalogOLTUpsertArgs} args - Arguments to update or create a CatalogOLT.
     * @example
     * // Update or create a CatalogOLT
     * const catalogOLT = await prisma.catalogOLT.upsert({
     *   create: {
     *     // ... data to create a CatalogOLT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogOLT we want to update
     *   }
     * })
     */
    upsert<T extends CatalogOLTUpsertArgs>(args: SelectSubset<T, CatalogOLTUpsertArgs<ExtArgs>>): Prisma__CatalogOLTClient<$Result.GetResult<Prisma.$CatalogOLTPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatalogOLTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogOLTCountArgs} args - Arguments to filter CatalogOLTS to count.
     * @example
     * // Count the number of CatalogOLTS
     * const count = await prisma.catalogOLT.count({
     *   where: {
     *     // ... the filter for the CatalogOLTS we want to count
     *   }
     * })
    **/
    count<T extends CatalogOLTCountArgs>(
      args?: Subset<T, CatalogOLTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogOLTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogOLT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogOLTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogOLTAggregateArgs>(args: Subset<T, CatalogOLTAggregateArgs>): Prisma.PrismaPromise<GetCatalogOLTAggregateType<T>>

    /**
     * Group by CatalogOLT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogOLTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogOLTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogOLTGroupByArgs['orderBy'] }
        : { orderBy?: CatalogOLTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogOLTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogOLTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogOLT model
   */
  readonly fields: CatalogOLTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogOLT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogOLTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CatalogOLT$companyArgs<ExtArgs> = {}>(args?: Subset<T, CatalogOLT$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatalogOLT model
   */ 
  interface CatalogOLTFieldRefs {
    readonly id: FieldRef<"CatalogOLT", 'String'>
    readonly name: FieldRef<"CatalogOLT", 'String'>
    readonly outputPower: FieldRef<"CatalogOLT", 'Float'>
    readonly slots: FieldRef<"CatalogOLT", 'Int'>
    readonly portsPerSlot: FieldRef<"CatalogOLT", 'Int'>
    readonly description: FieldRef<"CatalogOLT", 'String'>
    readonly createdAt: FieldRef<"CatalogOLT", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogOLT", 'DateTime'>
    readonly companyId: FieldRef<"CatalogOLT", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CatalogOLT findUnique
   */
  export type CatalogOLTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogOLT
     */
    select?: CatalogOLTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogOLTInclude<ExtArgs> | null
    /**
     * Filter, which CatalogOLT to fetch.
     */
    where: CatalogOLTWhereUniqueInput
  }

  /**
   * CatalogOLT findUniqueOrThrow
   */
  export type CatalogOLTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogOLT
     */
    select?: CatalogOLTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogOLTInclude<ExtArgs> | null
    /**
     * Filter, which CatalogOLT to fetch.
     */
    where: CatalogOLTWhereUniqueInput
  }

  /**
   * CatalogOLT findFirst
   */
  export type CatalogOLTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogOLT
     */
    select?: CatalogOLTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogOLTInclude<ExtArgs> | null
    /**
     * Filter, which CatalogOLT to fetch.
     */
    where?: CatalogOLTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogOLTS to fetch.
     */
    orderBy?: CatalogOLTOrderByWithRelationInput | CatalogOLTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogOLTS.
     */
    cursor?: CatalogOLTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogOLTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogOLTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogOLTS.
     */
    distinct?: CatalogOLTScalarFieldEnum | CatalogOLTScalarFieldEnum[]
  }

  /**
   * CatalogOLT findFirstOrThrow
   */
  export type CatalogOLTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogOLT
     */
    select?: CatalogOLTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogOLTInclude<ExtArgs> | null
    /**
     * Filter, which CatalogOLT to fetch.
     */
    where?: CatalogOLTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogOLTS to fetch.
     */
    orderBy?: CatalogOLTOrderByWithRelationInput | CatalogOLTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogOLTS.
     */
    cursor?: CatalogOLTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogOLTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogOLTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogOLTS.
     */
    distinct?: CatalogOLTScalarFieldEnum | CatalogOLTScalarFieldEnum[]
  }

  /**
   * CatalogOLT findMany
   */
  export type CatalogOLTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogOLT
     */
    select?: CatalogOLTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogOLTInclude<ExtArgs> | null
    /**
     * Filter, which CatalogOLTS to fetch.
     */
    where?: CatalogOLTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogOLTS to fetch.
     */
    orderBy?: CatalogOLTOrderByWithRelationInput | CatalogOLTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogOLTS.
     */
    cursor?: CatalogOLTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogOLTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogOLTS.
     */
    skip?: number
    distinct?: CatalogOLTScalarFieldEnum | CatalogOLTScalarFieldEnum[]
  }

  /**
   * CatalogOLT create
   */
  export type CatalogOLTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogOLT
     */
    select?: CatalogOLTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogOLTInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogOLT.
     */
    data: XOR<CatalogOLTCreateInput, CatalogOLTUncheckedCreateInput>
  }

  /**
   * CatalogOLT createMany
   */
  export type CatalogOLTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogOLTS.
     */
    data: CatalogOLTCreateManyInput | CatalogOLTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogOLT createManyAndReturn
   */
  export type CatalogOLTCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogOLT
     */
    select?: CatalogOLTSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CatalogOLTS.
     */
    data: CatalogOLTCreateManyInput | CatalogOLTCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogOLTIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatalogOLT update
   */
  export type CatalogOLTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogOLT
     */
    select?: CatalogOLTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogOLTInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogOLT.
     */
    data: XOR<CatalogOLTUpdateInput, CatalogOLTUncheckedUpdateInput>
    /**
     * Choose, which CatalogOLT to update.
     */
    where: CatalogOLTWhereUniqueInput
  }

  /**
   * CatalogOLT updateMany
   */
  export type CatalogOLTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogOLTS.
     */
    data: XOR<CatalogOLTUpdateManyMutationInput, CatalogOLTUncheckedUpdateManyInput>
    /**
     * Filter which CatalogOLTS to update
     */
    where?: CatalogOLTWhereInput
  }

  /**
   * CatalogOLT upsert
   */
  export type CatalogOLTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogOLT
     */
    select?: CatalogOLTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogOLTInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogOLT to update in case it exists.
     */
    where: CatalogOLTWhereUniqueInput
    /**
     * In case the CatalogOLT found by the `where` argument doesn't exist, create a new CatalogOLT with this data.
     */
    create: XOR<CatalogOLTCreateInput, CatalogOLTUncheckedCreateInput>
    /**
     * In case the CatalogOLT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogOLTUpdateInput, CatalogOLTUncheckedUpdateInput>
  }

  /**
   * CatalogOLT delete
   */
  export type CatalogOLTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogOLT
     */
    select?: CatalogOLTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogOLTInclude<ExtArgs> | null
    /**
     * Filter which CatalogOLT to delete.
     */
    where: CatalogOLTWhereUniqueInput
  }

  /**
   * CatalogOLT deleteMany
   */
  export type CatalogOLTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogOLTS to delete
     */
    where?: CatalogOLTWhereInput
  }

  /**
   * CatalogOLT.company
   */
  export type CatalogOLT$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * CatalogOLT without action
   */
  export type CatalogOLTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogOLT
     */
    select?: CatalogOLTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogOLTInclude<ExtArgs> | null
  }


  /**
   * Model TemplateOLT
   */

  export type AggregateTemplateOLT = {
    _count: TemplateOLTCountAggregateOutputType | null
    _avg: TemplateOLTAvgAggregateOutputType | null
    _sum: TemplateOLTSumAggregateOutputType | null
    _min: TemplateOLTMinAggregateOutputType | null
    _max: TemplateOLTMaxAggregateOutputType | null
  }

  export type TemplateOLTAvgAggregateOutputType = {
    outputPower: number | null
    slots: number | null
    portsPerSlot: number | null
  }

  export type TemplateOLTSumAggregateOutputType = {
    outputPower: number | null
    slots: number | null
    portsPerSlot: number | null
  }

  export type TemplateOLTMinAggregateOutputType = {
    id: string | null
    name: string | null
    outputPower: number | null
    slots: number | null
    portsPerSlot: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateOLTMaxAggregateOutputType = {
    id: string | null
    name: string | null
    outputPower: number | null
    slots: number | null
    portsPerSlot: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateOLTCountAggregateOutputType = {
    id: number
    name: number
    outputPower: number
    slots: number
    portsPerSlot: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateOLTAvgAggregateInputType = {
    outputPower?: true
    slots?: true
    portsPerSlot?: true
  }

  export type TemplateOLTSumAggregateInputType = {
    outputPower?: true
    slots?: true
    portsPerSlot?: true
  }

  export type TemplateOLTMinAggregateInputType = {
    id?: true
    name?: true
    outputPower?: true
    slots?: true
    portsPerSlot?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateOLTMaxAggregateInputType = {
    id?: true
    name?: true
    outputPower?: true
    slots?: true
    portsPerSlot?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateOLTCountAggregateInputType = {
    id?: true
    name?: true
    outputPower?: true
    slots?: true
    portsPerSlot?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateOLTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateOLT to aggregate.
     */
    where?: TemplateOLTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateOLTS to fetch.
     */
    orderBy?: TemplateOLTOrderByWithRelationInput | TemplateOLTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateOLTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateOLTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateOLTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateOLTS
    **/
    _count?: true | TemplateOLTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateOLTAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateOLTSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateOLTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateOLTMaxAggregateInputType
  }

  export type GetTemplateOLTAggregateType<T extends TemplateOLTAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateOLT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateOLT[P]>
      : GetScalarType<T[P], AggregateTemplateOLT[P]>
  }




  export type TemplateOLTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateOLTWhereInput
    orderBy?: TemplateOLTOrderByWithAggregationInput | TemplateOLTOrderByWithAggregationInput[]
    by: TemplateOLTScalarFieldEnum[] | TemplateOLTScalarFieldEnum
    having?: TemplateOLTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateOLTCountAggregateInputType | true
    _avg?: TemplateOLTAvgAggregateInputType
    _sum?: TemplateOLTSumAggregateInputType
    _min?: TemplateOLTMinAggregateInputType
    _max?: TemplateOLTMaxAggregateInputType
  }

  export type TemplateOLTGroupByOutputType = {
    id: string
    name: string
    outputPower: number
    slots: number
    portsPerSlot: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TemplateOLTCountAggregateOutputType | null
    _avg: TemplateOLTAvgAggregateOutputType | null
    _sum: TemplateOLTSumAggregateOutputType | null
    _min: TemplateOLTMinAggregateOutputType | null
    _max: TemplateOLTMaxAggregateOutputType | null
  }

  type GetTemplateOLTGroupByPayload<T extends TemplateOLTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateOLTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateOLTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateOLTGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateOLTGroupByOutputType[P]>
        }
      >
    >


  export type TemplateOLTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    outputPower?: boolean
    slots?: boolean
    portsPerSlot?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templateOLT"]>

  export type TemplateOLTSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    outputPower?: boolean
    slots?: boolean
    portsPerSlot?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templateOLT"]>

  export type TemplateOLTSelectScalar = {
    id?: boolean
    name?: boolean
    outputPower?: boolean
    slots?: boolean
    portsPerSlot?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TemplateOLTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateOLT"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      outputPower: number
      slots: number
      portsPerSlot: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["templateOLT"]>
    composites: {}
  }

  type TemplateOLTGetPayload<S extends boolean | null | undefined | TemplateOLTDefaultArgs> = $Result.GetResult<Prisma.$TemplateOLTPayload, S>

  type TemplateOLTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateOLTFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateOLTCountAggregateInputType | true
    }

  export interface TemplateOLTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateOLT'], meta: { name: 'TemplateOLT' } }
    /**
     * Find zero or one TemplateOLT that matches the filter.
     * @param {TemplateOLTFindUniqueArgs} args - Arguments to find a TemplateOLT
     * @example
     * // Get one TemplateOLT
     * const templateOLT = await prisma.templateOLT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateOLTFindUniqueArgs>(args: SelectSubset<T, TemplateOLTFindUniqueArgs<ExtArgs>>): Prisma__TemplateOLTClient<$Result.GetResult<Prisma.$TemplateOLTPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TemplateOLT that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TemplateOLTFindUniqueOrThrowArgs} args - Arguments to find a TemplateOLT
     * @example
     * // Get one TemplateOLT
     * const templateOLT = await prisma.templateOLT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateOLTFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateOLTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateOLTClient<$Result.GetResult<Prisma.$TemplateOLTPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TemplateOLT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateOLTFindFirstArgs} args - Arguments to find a TemplateOLT
     * @example
     * // Get one TemplateOLT
     * const templateOLT = await prisma.templateOLT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateOLTFindFirstArgs>(args?: SelectSubset<T, TemplateOLTFindFirstArgs<ExtArgs>>): Prisma__TemplateOLTClient<$Result.GetResult<Prisma.$TemplateOLTPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TemplateOLT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateOLTFindFirstOrThrowArgs} args - Arguments to find a TemplateOLT
     * @example
     * // Get one TemplateOLT
     * const templateOLT = await prisma.templateOLT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateOLTFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateOLTFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateOLTClient<$Result.GetResult<Prisma.$TemplateOLTPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TemplateOLTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateOLTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateOLTS
     * const templateOLTS = await prisma.templateOLT.findMany()
     * 
     * // Get first 10 TemplateOLTS
     * const templateOLTS = await prisma.templateOLT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateOLTWithIdOnly = await prisma.templateOLT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateOLTFindManyArgs>(args?: SelectSubset<T, TemplateOLTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateOLTPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TemplateOLT.
     * @param {TemplateOLTCreateArgs} args - Arguments to create a TemplateOLT.
     * @example
     * // Create one TemplateOLT
     * const TemplateOLT = await prisma.templateOLT.create({
     *   data: {
     *     // ... data to create a TemplateOLT
     *   }
     * })
     * 
     */
    create<T extends TemplateOLTCreateArgs>(args: SelectSubset<T, TemplateOLTCreateArgs<ExtArgs>>): Prisma__TemplateOLTClient<$Result.GetResult<Prisma.$TemplateOLTPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TemplateOLTS.
     * @param {TemplateOLTCreateManyArgs} args - Arguments to create many TemplateOLTS.
     * @example
     * // Create many TemplateOLTS
     * const templateOLT = await prisma.templateOLT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateOLTCreateManyArgs>(args?: SelectSubset<T, TemplateOLTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateOLTS and returns the data saved in the database.
     * @param {TemplateOLTCreateManyAndReturnArgs} args - Arguments to create many TemplateOLTS.
     * @example
     * // Create many TemplateOLTS
     * const templateOLT = await prisma.templateOLT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateOLTS and only return the `id`
     * const templateOLTWithIdOnly = await prisma.templateOLT.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateOLTCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateOLTCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateOLTPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TemplateOLT.
     * @param {TemplateOLTDeleteArgs} args - Arguments to delete one TemplateOLT.
     * @example
     * // Delete one TemplateOLT
     * const TemplateOLT = await prisma.templateOLT.delete({
     *   where: {
     *     // ... filter to delete one TemplateOLT
     *   }
     * })
     * 
     */
    delete<T extends TemplateOLTDeleteArgs>(args: SelectSubset<T, TemplateOLTDeleteArgs<ExtArgs>>): Prisma__TemplateOLTClient<$Result.GetResult<Prisma.$TemplateOLTPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TemplateOLT.
     * @param {TemplateOLTUpdateArgs} args - Arguments to update one TemplateOLT.
     * @example
     * // Update one TemplateOLT
     * const templateOLT = await prisma.templateOLT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateOLTUpdateArgs>(args: SelectSubset<T, TemplateOLTUpdateArgs<ExtArgs>>): Prisma__TemplateOLTClient<$Result.GetResult<Prisma.$TemplateOLTPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TemplateOLTS.
     * @param {TemplateOLTDeleteManyArgs} args - Arguments to filter TemplateOLTS to delete.
     * @example
     * // Delete a few TemplateOLTS
     * const { count } = await prisma.templateOLT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateOLTDeleteManyArgs>(args?: SelectSubset<T, TemplateOLTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateOLTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateOLTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateOLTS
     * const templateOLT = await prisma.templateOLT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateOLTUpdateManyArgs>(args: SelectSubset<T, TemplateOLTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateOLT.
     * @param {TemplateOLTUpsertArgs} args - Arguments to update or create a TemplateOLT.
     * @example
     * // Update or create a TemplateOLT
     * const templateOLT = await prisma.templateOLT.upsert({
     *   create: {
     *     // ... data to create a TemplateOLT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateOLT we want to update
     *   }
     * })
     */
    upsert<T extends TemplateOLTUpsertArgs>(args: SelectSubset<T, TemplateOLTUpsertArgs<ExtArgs>>): Prisma__TemplateOLTClient<$Result.GetResult<Prisma.$TemplateOLTPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TemplateOLTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateOLTCountArgs} args - Arguments to filter TemplateOLTS to count.
     * @example
     * // Count the number of TemplateOLTS
     * const count = await prisma.templateOLT.count({
     *   where: {
     *     // ... the filter for the TemplateOLTS we want to count
     *   }
     * })
    **/
    count<T extends TemplateOLTCountArgs>(
      args?: Subset<T, TemplateOLTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateOLTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateOLT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateOLTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateOLTAggregateArgs>(args: Subset<T, TemplateOLTAggregateArgs>): Prisma.PrismaPromise<GetTemplateOLTAggregateType<T>>

    /**
     * Group by TemplateOLT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateOLTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateOLTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateOLTGroupByArgs['orderBy'] }
        : { orderBy?: TemplateOLTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateOLTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateOLTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateOLT model
   */
  readonly fields: TemplateOLTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateOLT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateOLTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateOLT model
   */ 
  interface TemplateOLTFieldRefs {
    readonly id: FieldRef<"TemplateOLT", 'String'>
    readonly name: FieldRef<"TemplateOLT", 'String'>
    readonly outputPower: FieldRef<"TemplateOLT", 'Float'>
    readonly slots: FieldRef<"TemplateOLT", 'Int'>
    readonly portsPerSlot: FieldRef<"TemplateOLT", 'Int'>
    readonly description: FieldRef<"TemplateOLT", 'String'>
    readonly createdAt: FieldRef<"TemplateOLT", 'DateTime'>
    readonly updatedAt: FieldRef<"TemplateOLT", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TemplateOLT findUnique
   */
  export type TemplateOLTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateOLT
     */
    select?: TemplateOLTSelect<ExtArgs> | null
    /**
     * Filter, which TemplateOLT to fetch.
     */
    where: TemplateOLTWhereUniqueInput
  }

  /**
   * TemplateOLT findUniqueOrThrow
   */
  export type TemplateOLTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateOLT
     */
    select?: TemplateOLTSelect<ExtArgs> | null
    /**
     * Filter, which TemplateOLT to fetch.
     */
    where: TemplateOLTWhereUniqueInput
  }

  /**
   * TemplateOLT findFirst
   */
  export type TemplateOLTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateOLT
     */
    select?: TemplateOLTSelect<ExtArgs> | null
    /**
     * Filter, which TemplateOLT to fetch.
     */
    where?: TemplateOLTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateOLTS to fetch.
     */
    orderBy?: TemplateOLTOrderByWithRelationInput | TemplateOLTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateOLTS.
     */
    cursor?: TemplateOLTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateOLTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateOLTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateOLTS.
     */
    distinct?: TemplateOLTScalarFieldEnum | TemplateOLTScalarFieldEnum[]
  }

  /**
   * TemplateOLT findFirstOrThrow
   */
  export type TemplateOLTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateOLT
     */
    select?: TemplateOLTSelect<ExtArgs> | null
    /**
     * Filter, which TemplateOLT to fetch.
     */
    where?: TemplateOLTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateOLTS to fetch.
     */
    orderBy?: TemplateOLTOrderByWithRelationInput | TemplateOLTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateOLTS.
     */
    cursor?: TemplateOLTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateOLTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateOLTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateOLTS.
     */
    distinct?: TemplateOLTScalarFieldEnum | TemplateOLTScalarFieldEnum[]
  }

  /**
   * TemplateOLT findMany
   */
  export type TemplateOLTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateOLT
     */
    select?: TemplateOLTSelect<ExtArgs> | null
    /**
     * Filter, which TemplateOLTS to fetch.
     */
    where?: TemplateOLTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateOLTS to fetch.
     */
    orderBy?: TemplateOLTOrderByWithRelationInput | TemplateOLTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateOLTS.
     */
    cursor?: TemplateOLTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateOLTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateOLTS.
     */
    skip?: number
    distinct?: TemplateOLTScalarFieldEnum | TemplateOLTScalarFieldEnum[]
  }

  /**
   * TemplateOLT create
   */
  export type TemplateOLTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateOLT
     */
    select?: TemplateOLTSelect<ExtArgs> | null
    /**
     * The data needed to create a TemplateOLT.
     */
    data: XOR<TemplateOLTCreateInput, TemplateOLTUncheckedCreateInput>
  }

  /**
   * TemplateOLT createMany
   */
  export type TemplateOLTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateOLTS.
     */
    data: TemplateOLTCreateManyInput | TemplateOLTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateOLT createManyAndReturn
   */
  export type TemplateOLTCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateOLT
     */
    select?: TemplateOLTSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TemplateOLTS.
     */
    data: TemplateOLTCreateManyInput | TemplateOLTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateOLT update
   */
  export type TemplateOLTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateOLT
     */
    select?: TemplateOLTSelect<ExtArgs> | null
    /**
     * The data needed to update a TemplateOLT.
     */
    data: XOR<TemplateOLTUpdateInput, TemplateOLTUncheckedUpdateInput>
    /**
     * Choose, which TemplateOLT to update.
     */
    where: TemplateOLTWhereUniqueInput
  }

  /**
   * TemplateOLT updateMany
   */
  export type TemplateOLTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateOLTS.
     */
    data: XOR<TemplateOLTUpdateManyMutationInput, TemplateOLTUncheckedUpdateManyInput>
    /**
     * Filter which TemplateOLTS to update
     */
    where?: TemplateOLTWhereInput
  }

  /**
   * TemplateOLT upsert
   */
  export type TemplateOLTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateOLT
     */
    select?: TemplateOLTSelect<ExtArgs> | null
    /**
     * The filter to search for the TemplateOLT to update in case it exists.
     */
    where: TemplateOLTWhereUniqueInput
    /**
     * In case the TemplateOLT found by the `where` argument doesn't exist, create a new TemplateOLT with this data.
     */
    create: XOR<TemplateOLTCreateInput, TemplateOLTUncheckedCreateInput>
    /**
     * In case the TemplateOLT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateOLTUpdateInput, TemplateOLTUncheckedUpdateInput>
  }

  /**
   * TemplateOLT delete
   */
  export type TemplateOLTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateOLT
     */
    select?: TemplateOLTSelect<ExtArgs> | null
    /**
     * Filter which TemplateOLT to delete.
     */
    where: TemplateOLTWhereUniqueInput
  }

  /**
   * TemplateOLT deleteMany
   */
  export type TemplateOLTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateOLTS to delete
     */
    where?: TemplateOLTWhereInput
  }

  /**
   * TemplateOLT without action
   */
  export type TemplateOLTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateOLT
     */
    select?: TemplateOLTSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    passwordHash: 'passwordHash',
    createdAt: 'createdAt',
    companyId: 'companyId',
    role: 'role',
    active: 'active'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    planId: 'planId',
    subscriptionExpiresAt: 'subscriptionExpiresAt',
    status: 'status'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    limits: 'limits',
    createdAt: 'createdAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    centerLat: 'centerLat',
    centerLng: 'centerLng',
    zoom: 'zoom',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const CtoScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    status: 'status',
    lat: 'lat',
    lng: 'lng',
    splitters: 'splitters',
    fusions: 'fusions',
    connections: 'connections',
    inputCableIds: 'inputCableIds',
    layout: 'layout',
    clientCount: 'clientCount',
    catalogId: 'catalogId',
    type: 'type',
    color: 'color',
    reserveLoopLength: 'reserveLoopLength',
    companyId: 'companyId'
  };

  export type CtoScalarFieldEnum = (typeof CtoScalarFieldEnum)[keyof typeof CtoScalarFieldEnum]


  export const PopScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    status: 'status',
    lat: 'lat',
    lng: 'lng',
    olts: 'olts',
    dios: 'dios',
    fusions: 'fusions',
    connections: 'connections',
    inputCableIds: 'inputCableIds',
    layout: 'layout',
    color: 'color',
    size: 'size',
    companyId: 'companyId'
  };

  export type PopScalarFieldEnum = (typeof PopScalarFieldEnum)[keyof typeof PopScalarFieldEnum]


  export const CableScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    status: 'status',
    fiberCount: 'fiberCount',
    looseTubeCount: 'looseTubeCount',
    color: 'color',
    coordinates: 'coordinates',
    fromNodeId: 'fromNodeId',
    toNodeId: 'toNodeId',
    catalogId: 'catalogId',
    companyId: 'companyId'
  };

  export type CableScalarFieldEnum = (typeof CableScalarFieldEnum)[keyof typeof CableScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    details: 'details',
    userId: 'userId',
    companyId: 'companyId',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const CatalogSplitterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    mode: 'mode',
    inputs: 'inputs',
    outputs: 'outputs',
    attenuation: 'attenuation',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type CatalogSplitterScalarFieldEnum = (typeof CatalogSplitterScalarFieldEnum)[keyof typeof CatalogSplitterScalarFieldEnum]


  export const TemplateSplitterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    mode: 'mode',
    inputs: 'inputs',
    outputs: 'outputs',
    attenuation: 'attenuation',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateSplitterScalarFieldEnum = (typeof TemplateSplitterScalarFieldEnum)[keyof typeof TemplateSplitterScalarFieldEnum]


  export const CatalogCableScalarFieldEnum: {
    id: 'id',
    name: 'name',
    brand: 'brand',
    model: 'model',
    defaultLevel: 'defaultLevel',
    fiberCount: 'fiberCount',
    looseTubeCount: 'looseTubeCount',
    fibersPerTube: 'fibersPerTube',
    attenuation: 'attenuation',
    fiberProfile: 'fiberProfile',
    description: 'description',
    deployedSpec: 'deployedSpec',
    plannedSpec: 'plannedSpec',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type CatalogCableScalarFieldEnum = (typeof CatalogCableScalarFieldEnum)[keyof typeof CatalogCableScalarFieldEnum]


  export const TemplateCableScalarFieldEnum: {
    id: 'id',
    name: 'name',
    brand: 'brand',
    model: 'model',
    defaultLevel: 'defaultLevel',
    fiberCount: 'fiberCount',
    looseTubeCount: 'looseTubeCount',
    fibersPerTube: 'fibersPerTube',
    attenuation: 'attenuation',
    fiberProfile: 'fiberProfile',
    description: 'description',
    deployedSpec: 'deployedSpec',
    plannedSpec: 'plannedSpec',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateCableScalarFieldEnum = (typeof TemplateCableScalarFieldEnum)[keyof typeof TemplateCableScalarFieldEnum]


  export const CatalogBoxScalarFieldEnum: {
    id: 'id',
    name: 'name',
    brand: 'brand',
    model: 'model',
    type: 'type',
    reserveLoopLength: 'reserveLoopLength',
    color: 'color',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type CatalogBoxScalarFieldEnum = (typeof CatalogBoxScalarFieldEnum)[keyof typeof CatalogBoxScalarFieldEnum]


  export const TemplateBoxScalarFieldEnum: {
    id: 'id',
    name: 'name',
    brand: 'brand',
    model: 'model',
    type: 'type',
    reserveLoopLength: 'reserveLoopLength',
    color: 'color',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateBoxScalarFieldEnum = (typeof TemplateBoxScalarFieldEnum)[keyof typeof TemplateBoxScalarFieldEnum]


  export const CatalogPoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    height: 'height',
    strength: 'strength',
    shape: 'shape',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type CatalogPoleScalarFieldEnum = (typeof CatalogPoleScalarFieldEnum)[keyof typeof CatalogPoleScalarFieldEnum]


  export const TemplatePoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    height: 'height',
    strength: 'strength',
    shape: 'shape',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplatePoleScalarFieldEnum = (typeof TemplatePoleScalarFieldEnum)[keyof typeof TemplatePoleScalarFieldEnum]


  export const PoleScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    status: 'status',
    lat: 'lat',
    lng: 'lng',
    catalogId: 'catalogId',
    companyId: 'companyId'
  };

  export type PoleScalarFieldEnum = (typeof PoleScalarFieldEnum)[keyof typeof PoleScalarFieldEnum]


  export const CatalogFusionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    attenuation: 'attenuation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type CatalogFusionScalarFieldEnum = (typeof CatalogFusionScalarFieldEnum)[keyof typeof CatalogFusionScalarFieldEnum]


  export const TemplateFusionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    attenuation: 'attenuation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateFusionScalarFieldEnum = (typeof TemplateFusionScalarFieldEnum)[keyof typeof TemplateFusionScalarFieldEnum]


  export const CatalogOLTScalarFieldEnum: {
    id: 'id',
    name: 'name',
    outputPower: 'outputPower',
    slots: 'slots',
    portsPerSlot: 'portsPerSlot',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type CatalogOLTScalarFieldEnum = (typeof CatalogOLTScalarFieldEnum)[keyof typeof CatalogOLTScalarFieldEnum]


  export const TemplateOLTScalarFieldEnum: {
    id: 'id',
    name: 'name',
    outputPower: 'outputPower',
    slots: 'slots',
    portsPerSlot: 'portsPerSlot',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateOLTScalarFieldEnum = (typeof TemplateOLTScalarFieldEnum)[keyof typeof TemplateOLTScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'EquipmentStatus'
   */
  export type EnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus'>
    


  /**
   * Reference to a field of type 'EquipmentStatus[]'
   */
  export type ListEnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    companyId?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    active?: BoolFilter<"User"> | boolean
    projects?: ProjectListRelationFilter
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    role?: SortOrder
    active?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    companyId?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    active?: BoolFilter<"User"> | boolean
    projects?: ProjectListRelationFilter
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    role?: SortOrder
    active?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    companyId?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    active?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    planId?: StringNullableFilter<"Company"> | string | null
    subscriptionExpiresAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    status?: StringFilter<"Company"> | string
    cables?: CableListRelationFilter
    plan?: XOR<PlanNullableRelationFilter, PlanWhereInput> | null
    ctos?: CtoListRelationFilter
    pops?: PopListRelationFilter
    projects?: ProjectListRelationFilter
    users?: UserListRelationFilter
    poles?: PoleListRelationFilter
    catalogCables?: CatalogCableListRelationFilter
    catalogBoxes?: CatalogBoxListRelationFilter
    catalogPoles?: CatalogPoleListRelationFilter
    catalogSplitters?: CatalogSplitterListRelationFilter
    catalogFusions?: CatalogFusionListRelationFilter
    catalogOLTs?: CatalogOLTListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrderInput | SortOrder
    subscriptionExpiresAt?: SortOrderInput | SortOrder
    status?: SortOrder
    cables?: CableOrderByRelationAggregateInput
    plan?: PlanOrderByWithRelationInput
    ctos?: CtoOrderByRelationAggregateInput
    pops?: PopOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    poles?: PoleOrderByRelationAggregateInput
    catalogCables?: CatalogCableOrderByRelationAggregateInput
    catalogBoxes?: CatalogBoxOrderByRelationAggregateInput
    catalogPoles?: CatalogPoleOrderByRelationAggregateInput
    catalogSplitters?: CatalogSplitterOrderByRelationAggregateInput
    catalogFusions?: CatalogFusionOrderByRelationAggregateInput
    catalogOLTs?: CatalogOLTOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    planId?: StringNullableFilter<"Company"> | string | null
    subscriptionExpiresAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    status?: StringFilter<"Company"> | string
    cables?: CableListRelationFilter
    plan?: XOR<PlanNullableRelationFilter, PlanWhereInput> | null
    ctos?: CtoListRelationFilter
    pops?: PopListRelationFilter
    projects?: ProjectListRelationFilter
    users?: UserListRelationFilter
    poles?: PoleListRelationFilter
    catalogCables?: CatalogCableListRelationFilter
    catalogBoxes?: CatalogBoxListRelationFilter
    catalogPoles?: CatalogPoleListRelationFilter
    catalogSplitters?: CatalogSplitterListRelationFilter
    catalogFusions?: CatalogFusionListRelationFilter
    catalogOLTs?: CatalogOLTListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrderInput | SortOrder
    subscriptionExpiresAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    planId?: StringNullableWithAggregatesFilter<"Company"> | string | null
    subscriptionExpiresAt?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
    status?: StringWithAggregatesFilter<"Company"> | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    price?: FloatFilter<"Plan"> | number
    limits?: JsonFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    companies?: CompanyListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    limits?: SortOrder
    createdAt?: SortOrder
    companies?: CompanyOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringFilter<"Plan"> | string
    price?: FloatFilter<"Plan"> | number
    limits?: JsonFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    companies?: CompanyListRelationFilter
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    limits?: SortOrder
    createdAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    price?: FloatWithAggregatesFilter<"Plan"> | number
    limits?: JsonWithAggregatesFilter<"Plan">
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    centerLat?: FloatFilter<"Project"> | number
    centerLng?: FloatFilter<"Project"> | number
    zoom?: IntFilter<"Project"> | number
    settings?: JsonNullableFilter<"Project">
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    companyId?: StringNullableFilter<"Project"> | string | null
    cables?: CableListRelationFilter
    ctos?: CtoListRelationFilter
    pops?: PopListRelationFilter
    poles?: PoleListRelationFilter
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    centerLat?: SortOrder
    centerLng?: SortOrder
    zoom?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    cables?: CableOrderByRelationAggregateInput
    ctos?: CtoOrderByRelationAggregateInput
    pops?: PopOrderByRelationAggregateInput
    poles?: PoleOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    userId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    centerLat?: FloatFilter<"Project"> | number
    centerLng?: FloatFilter<"Project"> | number
    zoom?: IntFilter<"Project"> | number
    settings?: JsonNullableFilter<"Project">
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    companyId?: StringNullableFilter<"Project"> | string | null
    cables?: CableListRelationFilter
    ctos?: CtoListRelationFilter
    pops?: PopListRelationFilter
    poles?: PoleListRelationFilter
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    centerLat?: SortOrder
    centerLng?: SortOrder
    zoom?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    userId?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    centerLat?: FloatWithAggregatesFilter<"Project"> | number
    centerLng?: FloatWithAggregatesFilter<"Project"> | number
    zoom?: IntWithAggregatesFilter<"Project"> | number
    settings?: JsonNullableWithAggregatesFilter<"Project">
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    companyId?: StringNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type CtoWhereInput = {
    AND?: CtoWhereInput | CtoWhereInput[]
    OR?: CtoWhereInput[]
    NOT?: CtoWhereInput | CtoWhereInput[]
    id?: StringFilter<"Cto"> | string
    projectId?: StringFilter<"Cto"> | string
    name?: StringFilter<"Cto"> | string
    status?: EnumEquipmentStatusFilter<"Cto"> | $Enums.EquipmentStatus
    lat?: FloatFilter<"Cto"> | number
    lng?: FloatFilter<"Cto"> | number
    splitters?: JsonNullableFilter<"Cto">
    fusions?: JsonNullableFilter<"Cto">
    connections?: JsonNullableFilter<"Cto">
    inputCableIds?: StringNullableListFilter<"Cto">
    layout?: JsonNullableFilter<"Cto">
    clientCount?: IntFilter<"Cto"> | number
    catalogId?: StringNullableFilter<"Cto"> | string | null
    type?: StringNullableFilter<"Cto"> | string | null
    color?: StringNullableFilter<"Cto"> | string | null
    reserveLoopLength?: FloatNullableFilter<"Cto"> | number | null
    companyId?: StringNullableFilter<"Cto"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type CtoOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    splitters?: SortOrderInput | SortOrder
    fusions?: SortOrderInput | SortOrder
    connections?: SortOrderInput | SortOrder
    inputCableIds?: SortOrder
    layout?: SortOrderInput | SortOrder
    clientCount?: SortOrder
    catalogId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    reserveLoopLength?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type CtoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CtoWhereInput | CtoWhereInput[]
    OR?: CtoWhereInput[]
    NOT?: CtoWhereInput | CtoWhereInput[]
    projectId?: StringFilter<"Cto"> | string
    name?: StringFilter<"Cto"> | string
    status?: EnumEquipmentStatusFilter<"Cto"> | $Enums.EquipmentStatus
    lat?: FloatFilter<"Cto"> | number
    lng?: FloatFilter<"Cto"> | number
    splitters?: JsonNullableFilter<"Cto">
    fusions?: JsonNullableFilter<"Cto">
    connections?: JsonNullableFilter<"Cto">
    inputCableIds?: StringNullableListFilter<"Cto">
    layout?: JsonNullableFilter<"Cto">
    clientCount?: IntFilter<"Cto"> | number
    catalogId?: StringNullableFilter<"Cto"> | string | null
    type?: StringNullableFilter<"Cto"> | string | null
    color?: StringNullableFilter<"Cto"> | string | null
    reserveLoopLength?: FloatNullableFilter<"Cto"> | number | null
    companyId?: StringNullableFilter<"Cto"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type CtoOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    splitters?: SortOrderInput | SortOrder
    fusions?: SortOrderInput | SortOrder
    connections?: SortOrderInput | SortOrder
    inputCableIds?: SortOrder
    layout?: SortOrderInput | SortOrder
    clientCount?: SortOrder
    catalogId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    reserveLoopLength?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: CtoCountOrderByAggregateInput
    _avg?: CtoAvgOrderByAggregateInput
    _max?: CtoMaxOrderByAggregateInput
    _min?: CtoMinOrderByAggregateInput
    _sum?: CtoSumOrderByAggregateInput
  }

  export type CtoScalarWhereWithAggregatesInput = {
    AND?: CtoScalarWhereWithAggregatesInput | CtoScalarWhereWithAggregatesInput[]
    OR?: CtoScalarWhereWithAggregatesInput[]
    NOT?: CtoScalarWhereWithAggregatesInput | CtoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cto"> | string
    projectId?: StringWithAggregatesFilter<"Cto"> | string
    name?: StringWithAggregatesFilter<"Cto"> | string
    status?: EnumEquipmentStatusWithAggregatesFilter<"Cto"> | $Enums.EquipmentStatus
    lat?: FloatWithAggregatesFilter<"Cto"> | number
    lng?: FloatWithAggregatesFilter<"Cto"> | number
    splitters?: JsonNullableWithAggregatesFilter<"Cto">
    fusions?: JsonNullableWithAggregatesFilter<"Cto">
    connections?: JsonNullableWithAggregatesFilter<"Cto">
    inputCableIds?: StringNullableListFilter<"Cto">
    layout?: JsonNullableWithAggregatesFilter<"Cto">
    clientCount?: IntWithAggregatesFilter<"Cto"> | number
    catalogId?: StringNullableWithAggregatesFilter<"Cto"> | string | null
    type?: StringNullableWithAggregatesFilter<"Cto"> | string | null
    color?: StringNullableWithAggregatesFilter<"Cto"> | string | null
    reserveLoopLength?: FloatNullableWithAggregatesFilter<"Cto"> | number | null
    companyId?: StringNullableWithAggregatesFilter<"Cto"> | string | null
  }

  export type PopWhereInput = {
    AND?: PopWhereInput | PopWhereInput[]
    OR?: PopWhereInput[]
    NOT?: PopWhereInput | PopWhereInput[]
    id?: StringFilter<"Pop"> | string
    projectId?: StringFilter<"Pop"> | string
    name?: StringFilter<"Pop"> | string
    status?: EnumEquipmentStatusFilter<"Pop"> | $Enums.EquipmentStatus
    lat?: FloatFilter<"Pop"> | number
    lng?: FloatFilter<"Pop"> | number
    olts?: JsonNullableFilter<"Pop">
    dios?: JsonNullableFilter<"Pop">
    fusions?: JsonNullableFilter<"Pop">
    connections?: JsonNullableFilter<"Pop">
    inputCableIds?: StringNullableListFilter<"Pop">
    layout?: JsonNullableFilter<"Pop">
    color?: StringNullableFilter<"Pop"> | string | null
    size?: IntNullableFilter<"Pop"> | number | null
    companyId?: StringNullableFilter<"Pop"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type PopOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    olts?: SortOrderInput | SortOrder
    dios?: SortOrderInput | SortOrder
    fusions?: SortOrderInput | SortOrder
    connections?: SortOrderInput | SortOrder
    inputCableIds?: SortOrder
    layout?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type PopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PopWhereInput | PopWhereInput[]
    OR?: PopWhereInput[]
    NOT?: PopWhereInput | PopWhereInput[]
    projectId?: StringFilter<"Pop"> | string
    name?: StringFilter<"Pop"> | string
    status?: EnumEquipmentStatusFilter<"Pop"> | $Enums.EquipmentStatus
    lat?: FloatFilter<"Pop"> | number
    lng?: FloatFilter<"Pop"> | number
    olts?: JsonNullableFilter<"Pop">
    dios?: JsonNullableFilter<"Pop">
    fusions?: JsonNullableFilter<"Pop">
    connections?: JsonNullableFilter<"Pop">
    inputCableIds?: StringNullableListFilter<"Pop">
    layout?: JsonNullableFilter<"Pop">
    color?: StringNullableFilter<"Pop"> | string | null
    size?: IntNullableFilter<"Pop"> | number | null
    companyId?: StringNullableFilter<"Pop"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type PopOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    olts?: SortOrderInput | SortOrder
    dios?: SortOrderInput | SortOrder
    fusions?: SortOrderInput | SortOrder
    connections?: SortOrderInput | SortOrder
    inputCableIds?: SortOrder
    layout?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: PopCountOrderByAggregateInput
    _avg?: PopAvgOrderByAggregateInput
    _max?: PopMaxOrderByAggregateInput
    _min?: PopMinOrderByAggregateInput
    _sum?: PopSumOrderByAggregateInput
  }

  export type PopScalarWhereWithAggregatesInput = {
    AND?: PopScalarWhereWithAggregatesInput | PopScalarWhereWithAggregatesInput[]
    OR?: PopScalarWhereWithAggregatesInput[]
    NOT?: PopScalarWhereWithAggregatesInput | PopScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pop"> | string
    projectId?: StringWithAggregatesFilter<"Pop"> | string
    name?: StringWithAggregatesFilter<"Pop"> | string
    status?: EnumEquipmentStatusWithAggregatesFilter<"Pop"> | $Enums.EquipmentStatus
    lat?: FloatWithAggregatesFilter<"Pop"> | number
    lng?: FloatWithAggregatesFilter<"Pop"> | number
    olts?: JsonNullableWithAggregatesFilter<"Pop">
    dios?: JsonNullableWithAggregatesFilter<"Pop">
    fusions?: JsonNullableWithAggregatesFilter<"Pop">
    connections?: JsonNullableWithAggregatesFilter<"Pop">
    inputCableIds?: StringNullableListFilter<"Pop">
    layout?: JsonNullableWithAggregatesFilter<"Pop">
    color?: StringNullableWithAggregatesFilter<"Pop"> | string | null
    size?: IntNullableWithAggregatesFilter<"Pop"> | number | null
    companyId?: StringNullableWithAggregatesFilter<"Pop"> | string | null
  }

  export type CableWhereInput = {
    AND?: CableWhereInput | CableWhereInput[]
    OR?: CableWhereInput[]
    NOT?: CableWhereInput | CableWhereInput[]
    id?: StringFilter<"Cable"> | string
    projectId?: StringFilter<"Cable"> | string
    name?: StringFilter<"Cable"> | string
    status?: StringNullableFilter<"Cable"> | string | null
    fiberCount?: IntFilter<"Cable"> | number
    looseTubeCount?: IntNullableFilter<"Cable"> | number | null
    color?: StringNullableFilter<"Cable"> | string | null
    coordinates?: JsonFilter<"Cable">
    fromNodeId?: StringNullableFilter<"Cable"> | string | null
    toNodeId?: StringNullableFilter<"Cable"> | string | null
    catalogId?: StringNullableFilter<"Cable"> | string | null
    companyId?: StringNullableFilter<"Cable"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type CableOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrderInput | SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    coordinates?: SortOrder
    fromNodeId?: SortOrderInput | SortOrder
    toNodeId?: SortOrderInput | SortOrder
    catalogId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type CableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CableWhereInput | CableWhereInput[]
    OR?: CableWhereInput[]
    NOT?: CableWhereInput | CableWhereInput[]
    projectId?: StringFilter<"Cable"> | string
    name?: StringFilter<"Cable"> | string
    status?: StringNullableFilter<"Cable"> | string | null
    fiberCount?: IntFilter<"Cable"> | number
    looseTubeCount?: IntNullableFilter<"Cable"> | number | null
    color?: StringNullableFilter<"Cable"> | string | null
    coordinates?: JsonFilter<"Cable">
    fromNodeId?: StringNullableFilter<"Cable"> | string | null
    toNodeId?: StringNullableFilter<"Cable"> | string | null
    catalogId?: StringNullableFilter<"Cable"> | string | null
    companyId?: StringNullableFilter<"Cable"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type CableOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrderInput | SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    coordinates?: SortOrder
    fromNodeId?: SortOrderInput | SortOrder
    toNodeId?: SortOrderInput | SortOrder
    catalogId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: CableCountOrderByAggregateInput
    _avg?: CableAvgOrderByAggregateInput
    _max?: CableMaxOrderByAggregateInput
    _min?: CableMinOrderByAggregateInput
    _sum?: CableSumOrderByAggregateInput
  }

  export type CableScalarWhereWithAggregatesInput = {
    AND?: CableScalarWhereWithAggregatesInput | CableScalarWhereWithAggregatesInput[]
    OR?: CableScalarWhereWithAggregatesInput[]
    NOT?: CableScalarWhereWithAggregatesInput | CableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cable"> | string
    projectId?: StringWithAggregatesFilter<"Cable"> | string
    name?: StringWithAggregatesFilter<"Cable"> | string
    status?: StringNullableWithAggregatesFilter<"Cable"> | string | null
    fiberCount?: IntWithAggregatesFilter<"Cable"> | number
    looseTubeCount?: IntNullableWithAggregatesFilter<"Cable"> | number | null
    color?: StringNullableWithAggregatesFilter<"Cable"> | string | null
    coordinates?: JsonWithAggregatesFilter<"Cable">
    fromNodeId?: StringNullableWithAggregatesFilter<"Cable"> | string | null
    toNodeId?: StringNullableWithAggregatesFilter<"Cable"> | string | null
    catalogId?: StringNullableWithAggregatesFilter<"Cable"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"Cable"> | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    userId?: StringNullableFilter<"AuditLog"> | string | null
    companyId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    userId?: StringNullableFilter<"AuditLog"> | string | null
    companyId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type CatalogSplitterWhereInput = {
    AND?: CatalogSplitterWhereInput | CatalogSplitterWhereInput[]
    OR?: CatalogSplitterWhereInput[]
    NOT?: CatalogSplitterWhereInput | CatalogSplitterWhereInput[]
    id?: StringFilter<"CatalogSplitter"> | string
    name?: StringFilter<"CatalogSplitter"> | string
    type?: StringFilter<"CatalogSplitter"> | string
    mode?: StringFilter<"CatalogSplitter"> | string
    inputs?: IntFilter<"CatalogSplitter"> | number
    outputs?: IntFilter<"CatalogSplitter"> | number
    attenuation?: JsonNullableFilter<"CatalogSplitter">
    description?: StringNullableFilter<"CatalogSplitter"> | string | null
    createdAt?: DateTimeFilter<"CatalogSplitter"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogSplitter"> | Date | string
    companyId?: StringNullableFilter<"CatalogSplitter"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }

  export type CatalogSplitterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mode?: SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    attenuation?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CatalogSplitterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogSplitterWhereInput | CatalogSplitterWhereInput[]
    OR?: CatalogSplitterWhereInput[]
    NOT?: CatalogSplitterWhereInput | CatalogSplitterWhereInput[]
    name?: StringFilter<"CatalogSplitter"> | string
    type?: StringFilter<"CatalogSplitter"> | string
    mode?: StringFilter<"CatalogSplitter"> | string
    inputs?: IntFilter<"CatalogSplitter"> | number
    outputs?: IntFilter<"CatalogSplitter"> | number
    attenuation?: JsonNullableFilter<"CatalogSplitter">
    description?: StringNullableFilter<"CatalogSplitter"> | string | null
    createdAt?: DateTimeFilter<"CatalogSplitter"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogSplitter"> | Date | string
    companyId?: StringNullableFilter<"CatalogSplitter"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type CatalogSplitterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mode?: SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    attenuation?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: CatalogSplitterCountOrderByAggregateInput
    _avg?: CatalogSplitterAvgOrderByAggregateInput
    _max?: CatalogSplitterMaxOrderByAggregateInput
    _min?: CatalogSplitterMinOrderByAggregateInput
    _sum?: CatalogSplitterSumOrderByAggregateInput
  }

  export type CatalogSplitterScalarWhereWithAggregatesInput = {
    AND?: CatalogSplitterScalarWhereWithAggregatesInput | CatalogSplitterScalarWhereWithAggregatesInput[]
    OR?: CatalogSplitterScalarWhereWithAggregatesInput[]
    NOT?: CatalogSplitterScalarWhereWithAggregatesInput | CatalogSplitterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogSplitter"> | string
    name?: StringWithAggregatesFilter<"CatalogSplitter"> | string
    type?: StringWithAggregatesFilter<"CatalogSplitter"> | string
    mode?: StringWithAggregatesFilter<"CatalogSplitter"> | string
    inputs?: IntWithAggregatesFilter<"CatalogSplitter"> | number
    outputs?: IntWithAggregatesFilter<"CatalogSplitter"> | number
    attenuation?: JsonNullableWithAggregatesFilter<"CatalogSplitter">
    description?: StringNullableWithAggregatesFilter<"CatalogSplitter"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CatalogSplitter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogSplitter"> | Date | string
    companyId?: StringNullableWithAggregatesFilter<"CatalogSplitter"> | string | null
  }

  export type TemplateSplitterWhereInput = {
    AND?: TemplateSplitterWhereInput | TemplateSplitterWhereInput[]
    OR?: TemplateSplitterWhereInput[]
    NOT?: TemplateSplitterWhereInput | TemplateSplitterWhereInput[]
    id?: StringFilter<"TemplateSplitter"> | string
    name?: StringFilter<"TemplateSplitter"> | string
    type?: StringFilter<"TemplateSplitter"> | string
    mode?: StringFilter<"TemplateSplitter"> | string
    inputs?: IntFilter<"TemplateSplitter"> | number
    outputs?: IntFilter<"TemplateSplitter"> | number
    attenuation?: JsonNullableFilter<"TemplateSplitter">
    description?: StringNullableFilter<"TemplateSplitter"> | string | null
    createdAt?: DateTimeFilter<"TemplateSplitter"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateSplitter"> | Date | string
  }

  export type TemplateSplitterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mode?: SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    attenuation?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSplitterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplateSplitterWhereInput | TemplateSplitterWhereInput[]
    OR?: TemplateSplitterWhereInput[]
    NOT?: TemplateSplitterWhereInput | TemplateSplitterWhereInput[]
    name?: StringFilter<"TemplateSplitter"> | string
    type?: StringFilter<"TemplateSplitter"> | string
    mode?: StringFilter<"TemplateSplitter"> | string
    inputs?: IntFilter<"TemplateSplitter"> | number
    outputs?: IntFilter<"TemplateSplitter"> | number
    attenuation?: JsonNullableFilter<"TemplateSplitter">
    description?: StringNullableFilter<"TemplateSplitter"> | string | null
    createdAt?: DateTimeFilter<"TemplateSplitter"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateSplitter"> | Date | string
  }, "id">

  export type TemplateSplitterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mode?: SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    attenuation?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateSplitterCountOrderByAggregateInput
    _avg?: TemplateSplitterAvgOrderByAggregateInput
    _max?: TemplateSplitterMaxOrderByAggregateInput
    _min?: TemplateSplitterMinOrderByAggregateInput
    _sum?: TemplateSplitterSumOrderByAggregateInput
  }

  export type TemplateSplitterScalarWhereWithAggregatesInput = {
    AND?: TemplateSplitterScalarWhereWithAggregatesInput | TemplateSplitterScalarWhereWithAggregatesInput[]
    OR?: TemplateSplitterScalarWhereWithAggregatesInput[]
    NOT?: TemplateSplitterScalarWhereWithAggregatesInput | TemplateSplitterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TemplateSplitter"> | string
    name?: StringWithAggregatesFilter<"TemplateSplitter"> | string
    type?: StringWithAggregatesFilter<"TemplateSplitter"> | string
    mode?: StringWithAggregatesFilter<"TemplateSplitter"> | string
    inputs?: IntWithAggregatesFilter<"TemplateSplitter"> | number
    outputs?: IntWithAggregatesFilter<"TemplateSplitter"> | number
    attenuation?: JsonNullableWithAggregatesFilter<"TemplateSplitter">
    description?: StringNullableWithAggregatesFilter<"TemplateSplitter"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TemplateSplitter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TemplateSplitter"> | Date | string
  }

  export type CatalogCableWhereInput = {
    AND?: CatalogCableWhereInput | CatalogCableWhereInput[]
    OR?: CatalogCableWhereInput[]
    NOT?: CatalogCableWhereInput | CatalogCableWhereInput[]
    id?: StringFilter<"CatalogCable"> | string
    name?: StringFilter<"CatalogCable"> | string
    brand?: StringNullableFilter<"CatalogCable"> | string | null
    model?: StringNullableFilter<"CatalogCable"> | string | null
    defaultLevel?: StringNullableFilter<"CatalogCable"> | string | null
    fiberCount?: IntFilter<"CatalogCable"> | number
    looseTubeCount?: IntFilter<"CatalogCable"> | number
    fibersPerTube?: IntFilter<"CatalogCable"> | number
    attenuation?: FloatNullableFilter<"CatalogCable"> | number | null
    fiberProfile?: StringNullableFilter<"CatalogCable"> | string | null
    description?: StringNullableFilter<"CatalogCable"> | string | null
    deployedSpec?: JsonNullableFilter<"CatalogCable">
    plannedSpec?: JsonNullableFilter<"CatalogCable">
    createdAt?: DateTimeFilter<"CatalogCable"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogCable"> | Date | string
    companyId?: StringNullableFilter<"CatalogCable"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }

  export type CatalogCableOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    defaultLevel?: SortOrderInput | SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrderInput | SortOrder
    fiberProfile?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    deployedSpec?: SortOrderInput | SortOrder
    plannedSpec?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CatalogCableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogCableWhereInput | CatalogCableWhereInput[]
    OR?: CatalogCableWhereInput[]
    NOT?: CatalogCableWhereInput | CatalogCableWhereInput[]
    name?: StringFilter<"CatalogCable"> | string
    brand?: StringNullableFilter<"CatalogCable"> | string | null
    model?: StringNullableFilter<"CatalogCable"> | string | null
    defaultLevel?: StringNullableFilter<"CatalogCable"> | string | null
    fiberCount?: IntFilter<"CatalogCable"> | number
    looseTubeCount?: IntFilter<"CatalogCable"> | number
    fibersPerTube?: IntFilter<"CatalogCable"> | number
    attenuation?: FloatNullableFilter<"CatalogCable"> | number | null
    fiberProfile?: StringNullableFilter<"CatalogCable"> | string | null
    description?: StringNullableFilter<"CatalogCable"> | string | null
    deployedSpec?: JsonNullableFilter<"CatalogCable">
    plannedSpec?: JsonNullableFilter<"CatalogCable">
    createdAt?: DateTimeFilter<"CatalogCable"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogCable"> | Date | string
    companyId?: StringNullableFilter<"CatalogCable"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type CatalogCableOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    defaultLevel?: SortOrderInput | SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrderInput | SortOrder
    fiberProfile?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    deployedSpec?: SortOrderInput | SortOrder
    plannedSpec?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: CatalogCableCountOrderByAggregateInput
    _avg?: CatalogCableAvgOrderByAggregateInput
    _max?: CatalogCableMaxOrderByAggregateInput
    _min?: CatalogCableMinOrderByAggregateInput
    _sum?: CatalogCableSumOrderByAggregateInput
  }

  export type CatalogCableScalarWhereWithAggregatesInput = {
    AND?: CatalogCableScalarWhereWithAggregatesInput | CatalogCableScalarWhereWithAggregatesInput[]
    OR?: CatalogCableScalarWhereWithAggregatesInput[]
    NOT?: CatalogCableScalarWhereWithAggregatesInput | CatalogCableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogCable"> | string
    name?: StringWithAggregatesFilter<"CatalogCable"> | string
    brand?: StringNullableWithAggregatesFilter<"CatalogCable"> | string | null
    model?: StringNullableWithAggregatesFilter<"CatalogCable"> | string | null
    defaultLevel?: StringNullableWithAggregatesFilter<"CatalogCable"> | string | null
    fiberCount?: IntWithAggregatesFilter<"CatalogCable"> | number
    looseTubeCount?: IntWithAggregatesFilter<"CatalogCable"> | number
    fibersPerTube?: IntWithAggregatesFilter<"CatalogCable"> | number
    attenuation?: FloatNullableWithAggregatesFilter<"CatalogCable"> | number | null
    fiberProfile?: StringNullableWithAggregatesFilter<"CatalogCable"> | string | null
    description?: StringNullableWithAggregatesFilter<"CatalogCable"> | string | null
    deployedSpec?: JsonNullableWithAggregatesFilter<"CatalogCable">
    plannedSpec?: JsonNullableWithAggregatesFilter<"CatalogCable">
    createdAt?: DateTimeWithAggregatesFilter<"CatalogCable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogCable"> | Date | string
    companyId?: StringNullableWithAggregatesFilter<"CatalogCable"> | string | null
  }

  export type TemplateCableWhereInput = {
    AND?: TemplateCableWhereInput | TemplateCableWhereInput[]
    OR?: TemplateCableWhereInput[]
    NOT?: TemplateCableWhereInput | TemplateCableWhereInput[]
    id?: StringFilter<"TemplateCable"> | string
    name?: StringFilter<"TemplateCable"> | string
    brand?: StringNullableFilter<"TemplateCable"> | string | null
    model?: StringNullableFilter<"TemplateCable"> | string | null
    defaultLevel?: StringNullableFilter<"TemplateCable"> | string | null
    fiberCount?: IntFilter<"TemplateCable"> | number
    looseTubeCount?: IntFilter<"TemplateCable"> | number
    fibersPerTube?: IntFilter<"TemplateCable"> | number
    attenuation?: FloatNullableFilter<"TemplateCable"> | number | null
    fiberProfile?: StringNullableFilter<"TemplateCable"> | string | null
    description?: StringNullableFilter<"TemplateCable"> | string | null
    deployedSpec?: JsonNullableFilter<"TemplateCable">
    plannedSpec?: JsonNullableFilter<"TemplateCable">
    createdAt?: DateTimeFilter<"TemplateCable"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateCable"> | Date | string
  }

  export type TemplateCableOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    defaultLevel?: SortOrderInput | SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrderInput | SortOrder
    fiberProfile?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    deployedSpec?: SortOrderInput | SortOrder
    plannedSpec?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateCableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplateCableWhereInput | TemplateCableWhereInput[]
    OR?: TemplateCableWhereInput[]
    NOT?: TemplateCableWhereInput | TemplateCableWhereInput[]
    name?: StringFilter<"TemplateCable"> | string
    brand?: StringNullableFilter<"TemplateCable"> | string | null
    model?: StringNullableFilter<"TemplateCable"> | string | null
    defaultLevel?: StringNullableFilter<"TemplateCable"> | string | null
    fiberCount?: IntFilter<"TemplateCable"> | number
    looseTubeCount?: IntFilter<"TemplateCable"> | number
    fibersPerTube?: IntFilter<"TemplateCable"> | number
    attenuation?: FloatNullableFilter<"TemplateCable"> | number | null
    fiberProfile?: StringNullableFilter<"TemplateCable"> | string | null
    description?: StringNullableFilter<"TemplateCable"> | string | null
    deployedSpec?: JsonNullableFilter<"TemplateCable">
    plannedSpec?: JsonNullableFilter<"TemplateCable">
    createdAt?: DateTimeFilter<"TemplateCable"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateCable"> | Date | string
  }, "id">

  export type TemplateCableOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    defaultLevel?: SortOrderInput | SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrderInput | SortOrder
    fiberProfile?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    deployedSpec?: SortOrderInput | SortOrder
    plannedSpec?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateCableCountOrderByAggregateInput
    _avg?: TemplateCableAvgOrderByAggregateInput
    _max?: TemplateCableMaxOrderByAggregateInput
    _min?: TemplateCableMinOrderByAggregateInput
    _sum?: TemplateCableSumOrderByAggregateInput
  }

  export type TemplateCableScalarWhereWithAggregatesInput = {
    AND?: TemplateCableScalarWhereWithAggregatesInput | TemplateCableScalarWhereWithAggregatesInput[]
    OR?: TemplateCableScalarWhereWithAggregatesInput[]
    NOT?: TemplateCableScalarWhereWithAggregatesInput | TemplateCableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TemplateCable"> | string
    name?: StringWithAggregatesFilter<"TemplateCable"> | string
    brand?: StringNullableWithAggregatesFilter<"TemplateCable"> | string | null
    model?: StringNullableWithAggregatesFilter<"TemplateCable"> | string | null
    defaultLevel?: StringNullableWithAggregatesFilter<"TemplateCable"> | string | null
    fiberCount?: IntWithAggregatesFilter<"TemplateCable"> | number
    looseTubeCount?: IntWithAggregatesFilter<"TemplateCable"> | number
    fibersPerTube?: IntWithAggregatesFilter<"TemplateCable"> | number
    attenuation?: FloatNullableWithAggregatesFilter<"TemplateCable"> | number | null
    fiberProfile?: StringNullableWithAggregatesFilter<"TemplateCable"> | string | null
    description?: StringNullableWithAggregatesFilter<"TemplateCable"> | string | null
    deployedSpec?: JsonNullableWithAggregatesFilter<"TemplateCable">
    plannedSpec?: JsonNullableWithAggregatesFilter<"TemplateCable">
    createdAt?: DateTimeWithAggregatesFilter<"TemplateCable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TemplateCable"> | Date | string
  }

  export type CatalogBoxWhereInput = {
    AND?: CatalogBoxWhereInput | CatalogBoxWhereInput[]
    OR?: CatalogBoxWhereInput[]
    NOT?: CatalogBoxWhereInput | CatalogBoxWhereInput[]
    id?: StringFilter<"CatalogBox"> | string
    name?: StringFilter<"CatalogBox"> | string
    brand?: StringNullableFilter<"CatalogBox"> | string | null
    model?: StringNullableFilter<"CatalogBox"> | string | null
    type?: StringFilter<"CatalogBox"> | string
    reserveLoopLength?: FloatNullableFilter<"CatalogBox"> | number | null
    color?: StringNullableFilter<"CatalogBox"> | string | null
    description?: StringNullableFilter<"CatalogBox"> | string | null
    createdAt?: DateTimeFilter<"CatalogBox"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogBox"> | Date | string
    companyId?: StringNullableFilter<"CatalogBox"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }

  export type CatalogBoxOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    type?: SortOrder
    reserveLoopLength?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CatalogBoxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogBoxWhereInput | CatalogBoxWhereInput[]
    OR?: CatalogBoxWhereInput[]
    NOT?: CatalogBoxWhereInput | CatalogBoxWhereInput[]
    name?: StringFilter<"CatalogBox"> | string
    brand?: StringNullableFilter<"CatalogBox"> | string | null
    model?: StringNullableFilter<"CatalogBox"> | string | null
    type?: StringFilter<"CatalogBox"> | string
    reserveLoopLength?: FloatNullableFilter<"CatalogBox"> | number | null
    color?: StringNullableFilter<"CatalogBox"> | string | null
    description?: StringNullableFilter<"CatalogBox"> | string | null
    createdAt?: DateTimeFilter<"CatalogBox"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogBox"> | Date | string
    companyId?: StringNullableFilter<"CatalogBox"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type CatalogBoxOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    type?: SortOrder
    reserveLoopLength?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: CatalogBoxCountOrderByAggregateInput
    _avg?: CatalogBoxAvgOrderByAggregateInput
    _max?: CatalogBoxMaxOrderByAggregateInput
    _min?: CatalogBoxMinOrderByAggregateInput
    _sum?: CatalogBoxSumOrderByAggregateInput
  }

  export type CatalogBoxScalarWhereWithAggregatesInput = {
    AND?: CatalogBoxScalarWhereWithAggregatesInput | CatalogBoxScalarWhereWithAggregatesInput[]
    OR?: CatalogBoxScalarWhereWithAggregatesInput[]
    NOT?: CatalogBoxScalarWhereWithAggregatesInput | CatalogBoxScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogBox"> | string
    name?: StringWithAggregatesFilter<"CatalogBox"> | string
    brand?: StringNullableWithAggregatesFilter<"CatalogBox"> | string | null
    model?: StringNullableWithAggregatesFilter<"CatalogBox"> | string | null
    type?: StringWithAggregatesFilter<"CatalogBox"> | string
    reserveLoopLength?: FloatNullableWithAggregatesFilter<"CatalogBox"> | number | null
    color?: StringNullableWithAggregatesFilter<"CatalogBox"> | string | null
    description?: StringNullableWithAggregatesFilter<"CatalogBox"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CatalogBox"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogBox"> | Date | string
    companyId?: StringNullableWithAggregatesFilter<"CatalogBox"> | string | null
  }

  export type TemplateBoxWhereInput = {
    AND?: TemplateBoxWhereInput | TemplateBoxWhereInput[]
    OR?: TemplateBoxWhereInput[]
    NOT?: TemplateBoxWhereInput | TemplateBoxWhereInput[]
    id?: StringFilter<"TemplateBox"> | string
    name?: StringFilter<"TemplateBox"> | string
    brand?: StringNullableFilter<"TemplateBox"> | string | null
    model?: StringNullableFilter<"TemplateBox"> | string | null
    type?: StringFilter<"TemplateBox"> | string
    reserveLoopLength?: FloatNullableFilter<"TemplateBox"> | number | null
    color?: StringNullableFilter<"TemplateBox"> | string | null
    description?: StringNullableFilter<"TemplateBox"> | string | null
    createdAt?: DateTimeFilter<"TemplateBox"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateBox"> | Date | string
  }

  export type TemplateBoxOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    type?: SortOrder
    reserveLoopLength?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateBoxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplateBoxWhereInput | TemplateBoxWhereInput[]
    OR?: TemplateBoxWhereInput[]
    NOT?: TemplateBoxWhereInput | TemplateBoxWhereInput[]
    name?: StringFilter<"TemplateBox"> | string
    brand?: StringNullableFilter<"TemplateBox"> | string | null
    model?: StringNullableFilter<"TemplateBox"> | string | null
    type?: StringFilter<"TemplateBox"> | string
    reserveLoopLength?: FloatNullableFilter<"TemplateBox"> | number | null
    color?: StringNullableFilter<"TemplateBox"> | string | null
    description?: StringNullableFilter<"TemplateBox"> | string | null
    createdAt?: DateTimeFilter<"TemplateBox"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateBox"> | Date | string
  }, "id">

  export type TemplateBoxOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    type?: SortOrder
    reserveLoopLength?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateBoxCountOrderByAggregateInput
    _avg?: TemplateBoxAvgOrderByAggregateInput
    _max?: TemplateBoxMaxOrderByAggregateInput
    _min?: TemplateBoxMinOrderByAggregateInput
    _sum?: TemplateBoxSumOrderByAggregateInput
  }

  export type TemplateBoxScalarWhereWithAggregatesInput = {
    AND?: TemplateBoxScalarWhereWithAggregatesInput | TemplateBoxScalarWhereWithAggregatesInput[]
    OR?: TemplateBoxScalarWhereWithAggregatesInput[]
    NOT?: TemplateBoxScalarWhereWithAggregatesInput | TemplateBoxScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TemplateBox"> | string
    name?: StringWithAggregatesFilter<"TemplateBox"> | string
    brand?: StringNullableWithAggregatesFilter<"TemplateBox"> | string | null
    model?: StringNullableWithAggregatesFilter<"TemplateBox"> | string | null
    type?: StringWithAggregatesFilter<"TemplateBox"> | string
    reserveLoopLength?: FloatNullableWithAggregatesFilter<"TemplateBox"> | number | null
    color?: StringNullableWithAggregatesFilter<"TemplateBox"> | string | null
    description?: StringNullableWithAggregatesFilter<"TemplateBox"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TemplateBox"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TemplateBox"> | Date | string
  }

  export type CatalogPoleWhereInput = {
    AND?: CatalogPoleWhereInput | CatalogPoleWhereInput[]
    OR?: CatalogPoleWhereInput[]
    NOT?: CatalogPoleWhereInput | CatalogPoleWhereInput[]
    id?: StringFilter<"CatalogPole"> | string
    name?: StringFilter<"CatalogPole"> | string
    type?: StringFilter<"CatalogPole"> | string
    height?: FloatFilter<"CatalogPole"> | number
    strength?: FloatFilter<"CatalogPole"> | number
    shape?: StringFilter<"CatalogPole"> | string
    description?: StringNullableFilter<"CatalogPole"> | string | null
    createdAt?: DateTimeFilter<"CatalogPole"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogPole"> | Date | string
    companyId?: StringNullableFilter<"CatalogPole"> | string | null
    instances?: PoleListRelationFilter
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }

  export type CatalogPoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    height?: SortOrder
    strength?: SortOrder
    shape?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    instances?: PoleOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type CatalogPoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogPoleWhereInput | CatalogPoleWhereInput[]
    OR?: CatalogPoleWhereInput[]
    NOT?: CatalogPoleWhereInput | CatalogPoleWhereInput[]
    name?: StringFilter<"CatalogPole"> | string
    type?: StringFilter<"CatalogPole"> | string
    height?: FloatFilter<"CatalogPole"> | number
    strength?: FloatFilter<"CatalogPole"> | number
    shape?: StringFilter<"CatalogPole"> | string
    description?: StringNullableFilter<"CatalogPole"> | string | null
    createdAt?: DateTimeFilter<"CatalogPole"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogPole"> | Date | string
    companyId?: StringNullableFilter<"CatalogPole"> | string | null
    instances?: PoleListRelationFilter
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type CatalogPoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    height?: SortOrder
    strength?: SortOrder
    shape?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: CatalogPoleCountOrderByAggregateInput
    _avg?: CatalogPoleAvgOrderByAggregateInput
    _max?: CatalogPoleMaxOrderByAggregateInput
    _min?: CatalogPoleMinOrderByAggregateInput
    _sum?: CatalogPoleSumOrderByAggregateInput
  }

  export type CatalogPoleScalarWhereWithAggregatesInput = {
    AND?: CatalogPoleScalarWhereWithAggregatesInput | CatalogPoleScalarWhereWithAggregatesInput[]
    OR?: CatalogPoleScalarWhereWithAggregatesInput[]
    NOT?: CatalogPoleScalarWhereWithAggregatesInput | CatalogPoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogPole"> | string
    name?: StringWithAggregatesFilter<"CatalogPole"> | string
    type?: StringWithAggregatesFilter<"CatalogPole"> | string
    height?: FloatWithAggregatesFilter<"CatalogPole"> | number
    strength?: FloatWithAggregatesFilter<"CatalogPole"> | number
    shape?: StringWithAggregatesFilter<"CatalogPole"> | string
    description?: StringNullableWithAggregatesFilter<"CatalogPole"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CatalogPole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogPole"> | Date | string
    companyId?: StringNullableWithAggregatesFilter<"CatalogPole"> | string | null
  }

  export type TemplatePoleWhereInput = {
    AND?: TemplatePoleWhereInput | TemplatePoleWhereInput[]
    OR?: TemplatePoleWhereInput[]
    NOT?: TemplatePoleWhereInput | TemplatePoleWhereInput[]
    id?: StringFilter<"TemplatePole"> | string
    name?: StringFilter<"TemplatePole"> | string
    type?: StringFilter<"TemplatePole"> | string
    height?: FloatFilter<"TemplatePole"> | number
    strength?: FloatFilter<"TemplatePole"> | number
    shape?: StringFilter<"TemplatePole"> | string
    description?: StringNullableFilter<"TemplatePole"> | string | null
    createdAt?: DateTimeFilter<"TemplatePole"> | Date | string
    updatedAt?: DateTimeFilter<"TemplatePole"> | Date | string
  }

  export type TemplatePoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    height?: SortOrder
    strength?: SortOrder
    shape?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplatePoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplatePoleWhereInput | TemplatePoleWhereInput[]
    OR?: TemplatePoleWhereInput[]
    NOT?: TemplatePoleWhereInput | TemplatePoleWhereInput[]
    name?: StringFilter<"TemplatePole"> | string
    type?: StringFilter<"TemplatePole"> | string
    height?: FloatFilter<"TemplatePole"> | number
    strength?: FloatFilter<"TemplatePole"> | number
    shape?: StringFilter<"TemplatePole"> | string
    description?: StringNullableFilter<"TemplatePole"> | string | null
    createdAt?: DateTimeFilter<"TemplatePole"> | Date | string
    updatedAt?: DateTimeFilter<"TemplatePole"> | Date | string
  }, "id">

  export type TemplatePoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    height?: SortOrder
    strength?: SortOrder
    shape?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplatePoleCountOrderByAggregateInput
    _avg?: TemplatePoleAvgOrderByAggregateInput
    _max?: TemplatePoleMaxOrderByAggregateInput
    _min?: TemplatePoleMinOrderByAggregateInput
    _sum?: TemplatePoleSumOrderByAggregateInput
  }

  export type TemplatePoleScalarWhereWithAggregatesInput = {
    AND?: TemplatePoleScalarWhereWithAggregatesInput | TemplatePoleScalarWhereWithAggregatesInput[]
    OR?: TemplatePoleScalarWhereWithAggregatesInput[]
    NOT?: TemplatePoleScalarWhereWithAggregatesInput | TemplatePoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TemplatePole"> | string
    name?: StringWithAggregatesFilter<"TemplatePole"> | string
    type?: StringWithAggregatesFilter<"TemplatePole"> | string
    height?: FloatWithAggregatesFilter<"TemplatePole"> | number
    strength?: FloatWithAggregatesFilter<"TemplatePole"> | number
    shape?: StringWithAggregatesFilter<"TemplatePole"> | string
    description?: StringNullableWithAggregatesFilter<"TemplatePole"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TemplatePole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TemplatePole"> | Date | string
  }

  export type PoleWhereInput = {
    AND?: PoleWhereInput | PoleWhereInput[]
    OR?: PoleWhereInput[]
    NOT?: PoleWhereInput | PoleWhereInput[]
    id?: StringFilter<"Pole"> | string
    projectId?: StringFilter<"Pole"> | string
    name?: StringFilter<"Pole"> | string
    status?: EnumEquipmentStatusFilter<"Pole"> | $Enums.EquipmentStatus
    lat?: FloatFilter<"Pole"> | number
    lng?: FloatFilter<"Pole"> | number
    catalogId?: StringNullableFilter<"Pole"> | string | null
    companyId?: StringNullableFilter<"Pole"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    catalog?: XOR<CatalogPoleNullableRelationFilter, CatalogPoleWhereInput> | null
  }

  export type PoleOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    catalogId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    catalog?: CatalogPoleOrderByWithRelationInput
  }

  export type PoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PoleWhereInput | PoleWhereInput[]
    OR?: PoleWhereInput[]
    NOT?: PoleWhereInput | PoleWhereInput[]
    projectId?: StringFilter<"Pole"> | string
    name?: StringFilter<"Pole"> | string
    status?: EnumEquipmentStatusFilter<"Pole"> | $Enums.EquipmentStatus
    lat?: FloatFilter<"Pole"> | number
    lng?: FloatFilter<"Pole"> | number
    catalogId?: StringNullableFilter<"Pole"> | string | null
    companyId?: StringNullableFilter<"Pole"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    catalog?: XOR<CatalogPoleNullableRelationFilter, CatalogPoleWhereInput> | null
  }, "id">

  export type PoleOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    catalogId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: PoleCountOrderByAggregateInput
    _avg?: PoleAvgOrderByAggregateInput
    _max?: PoleMaxOrderByAggregateInput
    _min?: PoleMinOrderByAggregateInput
    _sum?: PoleSumOrderByAggregateInput
  }

  export type PoleScalarWhereWithAggregatesInput = {
    AND?: PoleScalarWhereWithAggregatesInput | PoleScalarWhereWithAggregatesInput[]
    OR?: PoleScalarWhereWithAggregatesInput[]
    NOT?: PoleScalarWhereWithAggregatesInput | PoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pole"> | string
    projectId?: StringWithAggregatesFilter<"Pole"> | string
    name?: StringWithAggregatesFilter<"Pole"> | string
    status?: EnumEquipmentStatusWithAggregatesFilter<"Pole"> | $Enums.EquipmentStatus
    lat?: FloatWithAggregatesFilter<"Pole"> | number
    lng?: FloatWithAggregatesFilter<"Pole"> | number
    catalogId?: StringNullableWithAggregatesFilter<"Pole"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"Pole"> | string | null
  }

  export type CatalogFusionWhereInput = {
    AND?: CatalogFusionWhereInput | CatalogFusionWhereInput[]
    OR?: CatalogFusionWhereInput[]
    NOT?: CatalogFusionWhereInput | CatalogFusionWhereInput[]
    id?: StringFilter<"CatalogFusion"> | string
    name?: StringFilter<"CatalogFusion"> | string
    attenuation?: FloatFilter<"CatalogFusion"> | number
    createdAt?: DateTimeFilter<"CatalogFusion"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogFusion"> | Date | string
    companyId?: StringNullableFilter<"CatalogFusion"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }

  export type CatalogFusionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    attenuation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CatalogFusionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogFusionWhereInput | CatalogFusionWhereInput[]
    OR?: CatalogFusionWhereInput[]
    NOT?: CatalogFusionWhereInput | CatalogFusionWhereInput[]
    name?: StringFilter<"CatalogFusion"> | string
    attenuation?: FloatFilter<"CatalogFusion"> | number
    createdAt?: DateTimeFilter<"CatalogFusion"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogFusion"> | Date | string
    companyId?: StringNullableFilter<"CatalogFusion"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type CatalogFusionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    attenuation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: CatalogFusionCountOrderByAggregateInput
    _avg?: CatalogFusionAvgOrderByAggregateInput
    _max?: CatalogFusionMaxOrderByAggregateInput
    _min?: CatalogFusionMinOrderByAggregateInput
    _sum?: CatalogFusionSumOrderByAggregateInput
  }

  export type CatalogFusionScalarWhereWithAggregatesInput = {
    AND?: CatalogFusionScalarWhereWithAggregatesInput | CatalogFusionScalarWhereWithAggregatesInput[]
    OR?: CatalogFusionScalarWhereWithAggregatesInput[]
    NOT?: CatalogFusionScalarWhereWithAggregatesInput | CatalogFusionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogFusion"> | string
    name?: StringWithAggregatesFilter<"CatalogFusion"> | string
    attenuation?: FloatWithAggregatesFilter<"CatalogFusion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CatalogFusion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogFusion"> | Date | string
    companyId?: StringNullableWithAggregatesFilter<"CatalogFusion"> | string | null
  }

  export type TemplateFusionWhereInput = {
    AND?: TemplateFusionWhereInput | TemplateFusionWhereInput[]
    OR?: TemplateFusionWhereInput[]
    NOT?: TemplateFusionWhereInput | TemplateFusionWhereInput[]
    id?: StringFilter<"TemplateFusion"> | string
    name?: StringFilter<"TemplateFusion"> | string
    attenuation?: FloatFilter<"TemplateFusion"> | number
    createdAt?: DateTimeFilter<"TemplateFusion"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateFusion"> | Date | string
  }

  export type TemplateFusionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    attenuation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateFusionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplateFusionWhereInput | TemplateFusionWhereInput[]
    OR?: TemplateFusionWhereInput[]
    NOT?: TemplateFusionWhereInput | TemplateFusionWhereInput[]
    name?: StringFilter<"TemplateFusion"> | string
    attenuation?: FloatFilter<"TemplateFusion"> | number
    createdAt?: DateTimeFilter<"TemplateFusion"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateFusion"> | Date | string
  }, "id">

  export type TemplateFusionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    attenuation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateFusionCountOrderByAggregateInput
    _avg?: TemplateFusionAvgOrderByAggregateInput
    _max?: TemplateFusionMaxOrderByAggregateInput
    _min?: TemplateFusionMinOrderByAggregateInput
    _sum?: TemplateFusionSumOrderByAggregateInput
  }

  export type TemplateFusionScalarWhereWithAggregatesInput = {
    AND?: TemplateFusionScalarWhereWithAggregatesInput | TemplateFusionScalarWhereWithAggregatesInput[]
    OR?: TemplateFusionScalarWhereWithAggregatesInput[]
    NOT?: TemplateFusionScalarWhereWithAggregatesInput | TemplateFusionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TemplateFusion"> | string
    name?: StringWithAggregatesFilter<"TemplateFusion"> | string
    attenuation?: FloatWithAggregatesFilter<"TemplateFusion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TemplateFusion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TemplateFusion"> | Date | string
  }

  export type CatalogOLTWhereInput = {
    AND?: CatalogOLTWhereInput | CatalogOLTWhereInput[]
    OR?: CatalogOLTWhereInput[]
    NOT?: CatalogOLTWhereInput | CatalogOLTWhereInput[]
    id?: StringFilter<"CatalogOLT"> | string
    name?: StringFilter<"CatalogOLT"> | string
    outputPower?: FloatFilter<"CatalogOLT"> | number
    slots?: IntFilter<"CatalogOLT"> | number
    portsPerSlot?: IntFilter<"CatalogOLT"> | number
    description?: StringNullableFilter<"CatalogOLT"> | string | null
    createdAt?: DateTimeFilter<"CatalogOLT"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogOLT"> | Date | string
    companyId?: StringNullableFilter<"CatalogOLT"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }

  export type CatalogOLTOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CatalogOLTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogOLTWhereInput | CatalogOLTWhereInput[]
    OR?: CatalogOLTWhereInput[]
    NOT?: CatalogOLTWhereInput | CatalogOLTWhereInput[]
    name?: StringFilter<"CatalogOLT"> | string
    outputPower?: FloatFilter<"CatalogOLT"> | number
    slots?: IntFilter<"CatalogOLT"> | number
    portsPerSlot?: IntFilter<"CatalogOLT"> | number
    description?: StringNullableFilter<"CatalogOLT"> | string | null
    createdAt?: DateTimeFilter<"CatalogOLT"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogOLT"> | Date | string
    companyId?: StringNullableFilter<"CatalogOLT"> | string | null
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type CatalogOLTOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: CatalogOLTCountOrderByAggregateInput
    _avg?: CatalogOLTAvgOrderByAggregateInput
    _max?: CatalogOLTMaxOrderByAggregateInput
    _min?: CatalogOLTMinOrderByAggregateInput
    _sum?: CatalogOLTSumOrderByAggregateInput
  }

  export type CatalogOLTScalarWhereWithAggregatesInput = {
    AND?: CatalogOLTScalarWhereWithAggregatesInput | CatalogOLTScalarWhereWithAggregatesInput[]
    OR?: CatalogOLTScalarWhereWithAggregatesInput[]
    NOT?: CatalogOLTScalarWhereWithAggregatesInput | CatalogOLTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogOLT"> | string
    name?: StringWithAggregatesFilter<"CatalogOLT"> | string
    outputPower?: FloatWithAggregatesFilter<"CatalogOLT"> | number
    slots?: IntWithAggregatesFilter<"CatalogOLT"> | number
    portsPerSlot?: IntWithAggregatesFilter<"CatalogOLT"> | number
    description?: StringNullableWithAggregatesFilter<"CatalogOLT"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CatalogOLT"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogOLT"> | Date | string
    companyId?: StringNullableWithAggregatesFilter<"CatalogOLT"> | string | null
  }

  export type TemplateOLTWhereInput = {
    AND?: TemplateOLTWhereInput | TemplateOLTWhereInput[]
    OR?: TemplateOLTWhereInput[]
    NOT?: TemplateOLTWhereInput | TemplateOLTWhereInput[]
    id?: StringFilter<"TemplateOLT"> | string
    name?: StringFilter<"TemplateOLT"> | string
    outputPower?: FloatFilter<"TemplateOLT"> | number
    slots?: IntFilter<"TemplateOLT"> | number
    portsPerSlot?: IntFilter<"TemplateOLT"> | number
    description?: StringNullableFilter<"TemplateOLT"> | string | null
    createdAt?: DateTimeFilter<"TemplateOLT"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateOLT"> | Date | string
  }

  export type TemplateOLTOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateOLTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplateOLTWhereInput | TemplateOLTWhereInput[]
    OR?: TemplateOLTWhereInput[]
    NOT?: TemplateOLTWhereInput | TemplateOLTWhereInput[]
    name?: StringFilter<"TemplateOLT"> | string
    outputPower?: FloatFilter<"TemplateOLT"> | number
    slots?: IntFilter<"TemplateOLT"> | number
    portsPerSlot?: IntFilter<"TemplateOLT"> | number
    description?: StringNullableFilter<"TemplateOLT"> | string | null
    createdAt?: DateTimeFilter<"TemplateOLT"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateOLT"> | Date | string
  }, "id">

  export type TemplateOLTOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateOLTCountOrderByAggregateInput
    _avg?: TemplateOLTAvgOrderByAggregateInput
    _max?: TemplateOLTMaxOrderByAggregateInput
    _min?: TemplateOLTMinOrderByAggregateInput
    _sum?: TemplateOLTSumOrderByAggregateInput
  }

  export type TemplateOLTScalarWhereWithAggregatesInput = {
    AND?: TemplateOLTScalarWhereWithAggregatesInput | TemplateOLTScalarWhereWithAggregatesInput[]
    OR?: TemplateOLTScalarWhereWithAggregatesInput[]
    NOT?: TemplateOLTScalarWhereWithAggregatesInput | TemplateOLTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TemplateOLT"> | string
    name?: StringWithAggregatesFilter<"TemplateOLT"> | string
    outputPower?: FloatWithAggregatesFilter<"TemplateOLT"> | number
    slots?: IntWithAggregatesFilter<"TemplateOLT"> | number
    portsPerSlot?: IntWithAggregatesFilter<"TemplateOLT"> | number
    description?: StringNullableWithAggregatesFilter<"TemplateOLT"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TemplateOLT"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TemplateOLT"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    passwordHash: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    active?: boolean
    projects?: ProjectCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    passwordHash: string
    createdAt?: Date | string
    companyId?: string | null
    role?: $Enums.UserRole
    active?: boolean
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    projects?: ProjectUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    passwordHash: string
    createdAt?: Date | string
    companyId?: string | null
    role?: $Enums.UserRole
    active?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    price?: number
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    companies?: CompanyCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    price?: number
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    companies?: CompanyUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    price?: number
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    cables?: CableCreateNestedManyWithoutProjectInput
    ctos?: CtoCreateNestedManyWithoutProjectInput
    pops?: PopCreateNestedManyWithoutProjectInput
    poles?: PoleCreateNestedManyWithoutProjectInput
    company?: CompanyCreateNestedOneWithoutProjectsInput
    user: UserCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    cables?: CableUncheckedCreateNestedManyWithoutProjectInput
    ctos?: CtoUncheckedCreateNestedManyWithoutProjectInput
    pops?: PopUncheckedCreateNestedManyWithoutProjectInput
    poles?: PoleUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cables?: CableUpdateManyWithoutProjectNestedInput
    ctos?: CtoUpdateManyWithoutProjectNestedInput
    pops?: PopUpdateManyWithoutProjectNestedInput
    poles?: PoleUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneWithoutProjectsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    cables?: CableUncheckedUpdateManyWithoutProjectNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutProjectNestedInput
    pops?: PopUncheckedUpdateManyWithoutProjectNestedInput
    poles?: PoleUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    userId: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CtoCreateInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: number
    catalogId?: string | null
    type?: string | null
    color?: string | null
    reserveLoopLength?: number | null
    company?: CompanyCreateNestedOneWithoutCtosInput
    project: ProjectCreateNestedOneWithoutCtosInput
  }

  export type CtoUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: number
    catalogId?: string | null
    type?: string | null
    color?: string | null
    reserveLoopLength?: number | null
    companyId?: string | null
  }

  export type CtoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: IntFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneWithoutCtosNestedInput
    project?: ProjectUpdateOneRequiredWithoutCtosNestedInput
  }

  export type CtoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: IntFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CtoCreateManyInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: number
    catalogId?: string | null
    type?: string | null
    color?: string | null
    reserveLoopLength?: number | null
    companyId?: string | null
  }

  export type CtoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: IntFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CtoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: IntFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PopCreateInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    size?: number | null
    company?: CompanyCreateNestedOneWithoutPopsInput
    project: ProjectCreateNestedOneWithoutPopsInput
  }

  export type PopUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    size?: number | null
    companyId?: string | null
  }

  export type PopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneWithoutPopsNestedInput
    project?: ProjectUpdateOneRequiredWithoutPopsNestedInput
  }

  export type PopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PopCreateManyInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    size?: number | null
    companyId?: string | null
  }

  export type PopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CableCreateInput = {
    id?: string
    name: string
    status?: string | null
    fiberCount: number
    looseTubeCount?: number | null
    color?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    fromNodeId?: string | null
    toNodeId?: string | null
    catalogId?: string | null
    company?: CompanyCreateNestedOneWithoutCablesInput
    project: ProjectCreateNestedOneWithoutCablesInput
  }

  export type CableUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    status?: string | null
    fiberCount: number
    looseTubeCount?: number | null
    color?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    fromNodeId?: string | null
    toNodeId?: string | null
    catalogId?: string | null
    companyId?: string | null
  }

  export type CableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    fromNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutCablesNestedInput
    project?: ProjectUpdateOneRequiredWithoutCablesNestedInput
  }

  export type CableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    fromNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CableCreateManyInput = {
    id?: string
    projectId: string
    name: string
    status?: string | null
    fiberCount: number
    looseTubeCount?: number | null
    color?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    fromNodeId?: string | null
    toNodeId?: string | null
    catalogId?: string | null
    companyId?: string | null
  }

  export type CableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    fromNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    fromNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity?: string
    entityId?: string
    details?: NullableJsonNullValueInput | InputJsonValue
    companyId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: string
    entity?: string
    entityId?: string
    details?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    companyId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: string
    entity?: string
    entityId?: string
    details?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    companyId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogSplitterCreateInput = {
    id?: string
    name: string
    type: string
    mode: string
    inputs?: number
    outputs: number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutCatalogSplittersInput
  }

  export type CatalogSplitterUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    mode: string
    inputs?: number
    outputs: number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type CatalogSplitterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    inputs?: IntFieldUpdateOperationsInput | number
    outputs?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutCatalogSplittersNestedInput
  }

  export type CatalogSplitterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    inputs?: IntFieldUpdateOperationsInput | number
    outputs?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogSplitterCreateManyInput = {
    id?: string
    name: string
    type: string
    mode: string
    inputs?: number
    outputs: number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type CatalogSplitterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    inputs?: IntFieldUpdateOperationsInput | number
    outputs?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogSplitterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    inputs?: IntFieldUpdateOperationsInput | number
    outputs?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateSplitterCreateInput = {
    id?: string
    name: string
    type: string
    mode: string
    inputs?: number
    outputs: number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateSplitterUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    mode: string
    inputs?: number
    outputs: number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateSplitterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    inputs?: IntFieldUpdateOperationsInput | number
    outputs?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateSplitterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    inputs?: IntFieldUpdateOperationsInput | number
    outputs?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateSplitterCreateManyInput = {
    id?: string
    name: string
    type: string
    mode: string
    inputs?: number
    outputs: number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateSplitterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    inputs?: IntFieldUpdateOperationsInput | number
    outputs?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateSplitterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    inputs?: IntFieldUpdateOperationsInput | number
    outputs?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCableCreateInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    defaultLevel?: string | null
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation?: number | null
    fiberProfile?: string | null
    description?: string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutCatalogCablesInput
  }

  export type CatalogCableUncheckedCreateInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    defaultLevel?: string | null
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation?: number | null
    fiberProfile?: string | null
    description?: string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type CatalogCableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    defaultLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: IntFieldUpdateOperationsInput | number
    fibersPerTube?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableFloatFieldUpdateOperationsInput | number | null
    fiberProfile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutCatalogCablesNestedInput
  }

  export type CatalogCableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    defaultLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: IntFieldUpdateOperationsInput | number
    fibersPerTube?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableFloatFieldUpdateOperationsInput | number | null
    fiberProfile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogCableCreateManyInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    defaultLevel?: string | null
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation?: number | null
    fiberProfile?: string | null
    description?: string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type CatalogCableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    defaultLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: IntFieldUpdateOperationsInput | number
    fibersPerTube?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableFloatFieldUpdateOperationsInput | number | null
    fiberProfile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    defaultLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: IntFieldUpdateOperationsInput | number
    fibersPerTube?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableFloatFieldUpdateOperationsInput | number | null
    fiberProfile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateCableCreateInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    defaultLevel?: string | null
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation?: number | null
    fiberProfile?: string | null
    description?: string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateCableUncheckedCreateInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    defaultLevel?: string | null
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation?: number | null
    fiberProfile?: string | null
    description?: string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateCableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    defaultLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: IntFieldUpdateOperationsInput | number
    fibersPerTube?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableFloatFieldUpdateOperationsInput | number | null
    fiberProfile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    defaultLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: IntFieldUpdateOperationsInput | number
    fibersPerTube?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableFloatFieldUpdateOperationsInput | number | null
    fiberProfile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCableCreateManyInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    defaultLevel?: string | null
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation?: number | null
    fiberProfile?: string | null
    description?: string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateCableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    defaultLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: IntFieldUpdateOperationsInput | number
    fibersPerTube?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableFloatFieldUpdateOperationsInput | number | null
    fiberProfile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    defaultLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: IntFieldUpdateOperationsInput | number
    fibersPerTube?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableFloatFieldUpdateOperationsInput | number | null
    fiberProfile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogBoxCreateInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    type: string
    reserveLoopLength?: number | null
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutCatalogBoxesInput
  }

  export type CatalogBoxUncheckedCreateInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    type: string
    reserveLoopLength?: number | null
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type CatalogBoxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutCatalogBoxesNestedInput
  }

  export type CatalogBoxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogBoxCreateManyInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    type: string
    reserveLoopLength?: number | null
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type CatalogBoxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogBoxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateBoxCreateInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    type: string
    reserveLoopLength?: number | null
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateBoxUncheckedCreateInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    type: string
    reserveLoopLength?: number | null
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateBoxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateBoxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateBoxCreateManyInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    type: string
    reserveLoopLength?: number | null
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateBoxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateBoxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogPoleCreateInput = {
    id?: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: PoleCreateNestedManyWithoutCatalogInput
    company?: CompanyCreateNestedOneWithoutCatalogPolesInput
  }

  export type CatalogPoleUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    instances?: PoleUncheckedCreateNestedManyWithoutCatalogInput
  }

  export type CatalogPoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: PoleUpdateManyWithoutCatalogNestedInput
    company?: CompanyUpdateOneWithoutCatalogPolesNestedInput
  }

  export type CatalogPoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    instances?: PoleUncheckedUpdateManyWithoutCatalogNestedInput
  }

  export type CatalogPoleCreateManyInput = {
    id?: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type CatalogPoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogPoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplatePoleCreateInput = {
    id?: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplatePoleUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplatePoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplatePoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplatePoleCreateManyInput = {
    id?: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplatePoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplatePoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoleCreateInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    company?: CompanyCreateNestedOneWithoutPolesInput
    project: ProjectCreateNestedOneWithoutPolesInput
    catalog?: CatalogPoleCreateNestedOneWithoutInstancesInput
  }

  export type PoleUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    catalogId?: string | null
    companyId?: string | null
  }

  export type PoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    company?: CompanyUpdateOneWithoutPolesNestedInput
    project?: ProjectUpdateOneRequiredWithoutPolesNestedInput
    catalog?: CatalogPoleUpdateOneWithoutInstancesNestedInput
  }

  export type PoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PoleCreateManyInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    catalogId?: string | null
    companyId?: string | null
  }

  export type PoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
  }

  export type PoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogFusionCreateInput = {
    id?: string
    name: string
    attenuation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutCatalogFusionsInput
  }

  export type CatalogFusionUncheckedCreateInput = {
    id?: string
    name: string
    attenuation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type CatalogFusionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attenuation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutCatalogFusionsNestedInput
  }

  export type CatalogFusionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attenuation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogFusionCreateManyInput = {
    id?: string
    name: string
    attenuation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type CatalogFusionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attenuation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogFusionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attenuation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateFusionCreateInput = {
    id?: string
    name: string
    attenuation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateFusionUncheckedCreateInput = {
    id?: string
    name: string
    attenuation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateFusionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attenuation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateFusionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attenuation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateFusionCreateManyInput = {
    id?: string
    name: string
    attenuation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateFusionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attenuation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateFusionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attenuation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogOLTCreateInput = {
    id?: string
    name: string
    outputPower?: number
    slots?: number
    portsPerSlot?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutCatalogOLTsInput
  }

  export type CatalogOLTUncheckedCreateInput = {
    id?: string
    name: string
    outputPower?: number
    slots?: number
    portsPerSlot?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type CatalogOLTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    outputPower?: FloatFieldUpdateOperationsInput | number
    slots?: IntFieldUpdateOperationsInput | number
    portsPerSlot?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutCatalogOLTsNestedInput
  }

  export type CatalogOLTUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    outputPower?: FloatFieldUpdateOperationsInput | number
    slots?: IntFieldUpdateOperationsInput | number
    portsPerSlot?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogOLTCreateManyInput = {
    id?: string
    name: string
    outputPower?: number
    slots?: number
    portsPerSlot?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type CatalogOLTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    outputPower?: FloatFieldUpdateOperationsInput | number
    slots?: IntFieldUpdateOperationsInput | number
    portsPerSlot?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogOLTUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    outputPower?: FloatFieldUpdateOperationsInput | number
    slots?: IntFieldUpdateOperationsInput | number
    portsPerSlot?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateOLTCreateInput = {
    id?: string
    name: string
    outputPower?: number
    slots?: number
    portsPerSlot?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateOLTUncheckedCreateInput = {
    id?: string
    name: string
    outputPower?: number
    slots?: number
    portsPerSlot?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateOLTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    outputPower?: FloatFieldUpdateOperationsInput | number
    slots?: IntFieldUpdateOperationsInput | number
    portsPerSlot?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateOLTUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    outputPower?: FloatFieldUpdateOperationsInput | number
    slots?: IntFieldUpdateOperationsInput | number
    portsPerSlot?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateOLTCreateManyInput = {
    id?: string
    name: string
    outputPower?: number
    slots?: number
    portsPerSlot?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateOLTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    outputPower?: FloatFieldUpdateOperationsInput | number
    slots?: IntFieldUpdateOperationsInput | number
    portsPerSlot?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateOLTUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    outputPower?: FloatFieldUpdateOperationsInput | number
    slots?: IntFieldUpdateOperationsInput | number
    portsPerSlot?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type CompanyNullableRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    active?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    active?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    active?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CableListRelationFilter = {
    every?: CableWhereInput
    some?: CableWhereInput
    none?: CableWhereInput
  }

  export type PlanNullableRelationFilter = {
    is?: PlanWhereInput | null
    isNot?: PlanWhereInput | null
  }

  export type CtoListRelationFilter = {
    every?: CtoWhereInput
    some?: CtoWhereInput
    none?: CtoWhereInput
  }

  export type PopListRelationFilter = {
    every?: PopWhereInput
    some?: PopWhereInput
    none?: PopWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PoleListRelationFilter = {
    every?: PoleWhereInput
    some?: PoleWhereInput
    none?: PoleWhereInput
  }

  export type CatalogCableListRelationFilter = {
    every?: CatalogCableWhereInput
    some?: CatalogCableWhereInput
    none?: CatalogCableWhereInput
  }

  export type CatalogBoxListRelationFilter = {
    every?: CatalogBoxWhereInput
    some?: CatalogBoxWhereInput
    none?: CatalogBoxWhereInput
  }

  export type CatalogPoleListRelationFilter = {
    every?: CatalogPoleWhereInput
    some?: CatalogPoleWhereInput
    none?: CatalogPoleWhereInput
  }

  export type CatalogSplitterListRelationFilter = {
    every?: CatalogSplitterWhereInput
    some?: CatalogSplitterWhereInput
    none?: CatalogSplitterWhereInput
  }

  export type CatalogFusionListRelationFilter = {
    every?: CatalogFusionWhereInput
    some?: CatalogFusionWhereInput
    none?: CatalogFusionWhereInput
  }

  export type CatalogOLTListRelationFilter = {
    every?: CatalogOLTWhereInput
    some?: CatalogOLTWhereInput
    none?: CatalogOLTWhereInput
  }

  export type CableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CtoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogCableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogBoxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogPoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogSplitterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogFusionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogOLTOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    subscriptionExpiresAt?: SortOrder
    status?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    subscriptionExpiresAt?: SortOrder
    status?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    subscriptionExpiresAt?: SortOrder
    status?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CompanyListRelationFilter = {
    every?: CompanyWhereInput
    some?: CompanyWhereInput
    none?: CompanyWhereInput
  }

  export type CompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    limits?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    centerLat?: SortOrder
    centerLng?: SortOrder
    zoom?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    centerLat?: SortOrder
    centerLng?: SortOrder
    zoom?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    centerLat?: SortOrder
    centerLng?: SortOrder
    zoom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    centerLat?: SortOrder
    centerLng?: SortOrder
    zoom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    centerLat?: SortOrder
    centerLng?: SortOrder
    zoom?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type CtoCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    splitters?: SortOrder
    fusions?: SortOrder
    connections?: SortOrder
    inputCableIds?: SortOrder
    layout?: SortOrder
    clientCount?: SortOrder
    catalogId?: SortOrder
    type?: SortOrder
    color?: SortOrder
    reserveLoopLength?: SortOrder
    companyId?: SortOrder
  }

  export type CtoAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    clientCount?: SortOrder
    reserveLoopLength?: SortOrder
  }

  export type CtoMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    clientCount?: SortOrder
    catalogId?: SortOrder
    type?: SortOrder
    color?: SortOrder
    reserveLoopLength?: SortOrder
    companyId?: SortOrder
  }

  export type CtoMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    clientCount?: SortOrder
    catalogId?: SortOrder
    type?: SortOrder
    color?: SortOrder
    reserveLoopLength?: SortOrder
    companyId?: SortOrder
  }

  export type CtoSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    clientCount?: SortOrder
    reserveLoopLength?: SortOrder
  }

  export type EnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PopCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    olts?: SortOrder
    dios?: SortOrder
    fusions?: SortOrder
    connections?: SortOrder
    inputCableIds?: SortOrder
    layout?: SortOrder
    color?: SortOrder
    size?: SortOrder
    companyId?: SortOrder
  }

  export type PopAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    size?: SortOrder
  }

  export type PopMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    color?: SortOrder
    size?: SortOrder
    companyId?: SortOrder
  }

  export type PopMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    color?: SortOrder
    size?: SortOrder
    companyId?: SortOrder
  }

  export type PopSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    size?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CableCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    color?: SortOrder
    coordinates?: SortOrder
    fromNodeId?: SortOrder
    toNodeId?: SortOrder
    catalogId?: SortOrder
    companyId?: SortOrder
  }

  export type CableAvgOrderByAggregateInput = {
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
  }

  export type CableMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    color?: SortOrder
    fromNodeId?: SortOrder
    toNodeId?: SortOrder
    catalogId?: SortOrder
    companyId?: SortOrder
  }

  export type CableMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    color?: SortOrder
    fromNodeId?: SortOrder
    toNodeId?: SortOrder
    catalogId?: SortOrder
    companyId?: SortOrder
  }

  export type CableSumOrderByAggregateInput = {
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type CatalogSplitterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mode?: SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    attenuation?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogSplitterAvgOrderByAggregateInput = {
    inputs?: SortOrder
    outputs?: SortOrder
  }

  export type CatalogSplitterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mode?: SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogSplitterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mode?: SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogSplitterSumOrderByAggregateInput = {
    inputs?: SortOrder
    outputs?: SortOrder
  }

  export type TemplateSplitterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mode?: SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    attenuation?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSplitterAvgOrderByAggregateInput = {
    inputs?: SortOrder
    outputs?: SortOrder
  }

  export type TemplateSplitterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mode?: SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSplitterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mode?: SortOrder
    inputs?: SortOrder
    outputs?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSplitterSumOrderByAggregateInput = {
    inputs?: SortOrder
    outputs?: SortOrder
  }

  export type CatalogCableCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    defaultLevel?: SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrder
    fiberProfile?: SortOrder
    description?: SortOrder
    deployedSpec?: SortOrder
    plannedSpec?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogCableAvgOrderByAggregateInput = {
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrder
  }

  export type CatalogCableMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    defaultLevel?: SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrder
    fiberProfile?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogCableMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    defaultLevel?: SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrder
    fiberProfile?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogCableSumOrderByAggregateInput = {
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrder
  }

  export type TemplateCableCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    defaultLevel?: SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrder
    fiberProfile?: SortOrder
    description?: SortOrder
    deployedSpec?: SortOrder
    plannedSpec?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateCableAvgOrderByAggregateInput = {
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrder
  }

  export type TemplateCableMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    defaultLevel?: SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrder
    fiberProfile?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateCableMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    defaultLevel?: SortOrder
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrder
    fiberProfile?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateCableSumOrderByAggregateInput = {
    fiberCount?: SortOrder
    looseTubeCount?: SortOrder
    fibersPerTube?: SortOrder
    attenuation?: SortOrder
  }

  export type CatalogBoxCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    type?: SortOrder
    reserveLoopLength?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogBoxAvgOrderByAggregateInput = {
    reserveLoopLength?: SortOrder
  }

  export type CatalogBoxMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    type?: SortOrder
    reserveLoopLength?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogBoxMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    type?: SortOrder
    reserveLoopLength?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogBoxSumOrderByAggregateInput = {
    reserveLoopLength?: SortOrder
  }

  export type TemplateBoxCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    type?: SortOrder
    reserveLoopLength?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateBoxAvgOrderByAggregateInput = {
    reserveLoopLength?: SortOrder
  }

  export type TemplateBoxMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    type?: SortOrder
    reserveLoopLength?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateBoxMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    type?: SortOrder
    reserveLoopLength?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateBoxSumOrderByAggregateInput = {
    reserveLoopLength?: SortOrder
  }

  export type CatalogPoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    height?: SortOrder
    strength?: SortOrder
    shape?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogPoleAvgOrderByAggregateInput = {
    height?: SortOrder
    strength?: SortOrder
  }

  export type CatalogPoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    height?: SortOrder
    strength?: SortOrder
    shape?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogPoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    height?: SortOrder
    strength?: SortOrder
    shape?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogPoleSumOrderByAggregateInput = {
    height?: SortOrder
    strength?: SortOrder
  }

  export type TemplatePoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    height?: SortOrder
    strength?: SortOrder
    shape?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplatePoleAvgOrderByAggregateInput = {
    height?: SortOrder
    strength?: SortOrder
  }

  export type TemplatePoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    height?: SortOrder
    strength?: SortOrder
    shape?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplatePoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    height?: SortOrder
    strength?: SortOrder
    shape?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplatePoleSumOrderByAggregateInput = {
    height?: SortOrder
    strength?: SortOrder
  }

  export type CatalogPoleNullableRelationFilter = {
    is?: CatalogPoleWhereInput | null
    isNot?: CatalogPoleWhereInput | null
  }

  export type PoleCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    catalogId?: SortOrder
    companyId?: SortOrder
  }

  export type PoleAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type PoleMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    catalogId?: SortOrder
    companyId?: SortOrder
  }

  export type PoleMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    catalogId?: SortOrder
    companyId?: SortOrder
  }

  export type PoleSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type CatalogFusionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    attenuation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogFusionAvgOrderByAggregateInput = {
    attenuation?: SortOrder
  }

  export type CatalogFusionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    attenuation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogFusionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    attenuation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogFusionSumOrderByAggregateInput = {
    attenuation?: SortOrder
  }

  export type TemplateFusionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    attenuation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateFusionAvgOrderByAggregateInput = {
    attenuation?: SortOrder
  }

  export type TemplateFusionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    attenuation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateFusionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    attenuation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateFusionSumOrderByAggregateInput = {
    attenuation?: SortOrder
  }

  export type CatalogOLTCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogOLTAvgOrderByAggregateInput = {
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
  }

  export type CatalogOLTMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogOLTMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CatalogOLTSumOrderByAggregateInput = {
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
  }

  export type TemplateOLTCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateOLTAvgOrderByAggregateInput = {
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
  }

  export type TemplateOLTMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateOLTMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateOLTSumOrderByAggregateInput = {
    outputPower?: SortOrder
    slots?: SortOrder
    portsPerSlot?: SortOrder
  }

  export type ProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CableCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CableCreateWithoutCompanyInput, CableUncheckedCreateWithoutCompanyInput> | CableCreateWithoutCompanyInput[] | CableUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CableCreateOrConnectWithoutCompanyInput | CableCreateOrConnectWithoutCompanyInput[]
    createMany?: CableCreateManyCompanyInputEnvelope
    connect?: CableWhereUniqueInput | CableWhereUniqueInput[]
  }

  export type PlanCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<PlanCreateWithoutCompaniesInput, PlanUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: PlanCreateOrConnectWithoutCompaniesInput
    connect?: PlanWhereUniqueInput
  }

  export type CtoCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CtoCreateWithoutCompanyInput, CtoUncheckedCreateWithoutCompanyInput> | CtoCreateWithoutCompanyInput[] | CtoUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CtoCreateOrConnectWithoutCompanyInput | CtoCreateOrConnectWithoutCompanyInput[]
    createMany?: CtoCreateManyCompanyInputEnvelope
    connect?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
  }

  export type PopCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PopCreateWithoutCompanyInput, PopUncheckedCreateWithoutCompanyInput> | PopCreateWithoutCompanyInput[] | PopUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PopCreateOrConnectWithoutCompanyInput | PopCreateOrConnectWithoutCompanyInput[]
    createMany?: PopCreateManyCompanyInputEnvelope
    connect?: PopWhereUniqueInput | PopWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProjectCreateWithoutCompanyInput, ProjectUncheckedCreateWithoutCompanyInput> | ProjectCreateWithoutCompanyInput[] | ProjectUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCompanyInput | ProjectCreateOrConnectWithoutCompanyInput[]
    createMany?: ProjectCreateManyCompanyInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PoleCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PoleCreateWithoutCompanyInput, PoleUncheckedCreateWithoutCompanyInput> | PoleCreateWithoutCompanyInput[] | PoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PoleCreateOrConnectWithoutCompanyInput | PoleCreateOrConnectWithoutCompanyInput[]
    createMany?: PoleCreateManyCompanyInputEnvelope
    connect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
  }

  export type CatalogCableCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CatalogCableCreateWithoutCompanyInput, CatalogCableUncheckedCreateWithoutCompanyInput> | CatalogCableCreateWithoutCompanyInput[] | CatalogCableUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogCableCreateOrConnectWithoutCompanyInput | CatalogCableCreateOrConnectWithoutCompanyInput[]
    createMany?: CatalogCableCreateManyCompanyInputEnvelope
    connect?: CatalogCableWhereUniqueInput | CatalogCableWhereUniqueInput[]
  }

  export type CatalogBoxCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CatalogBoxCreateWithoutCompanyInput, CatalogBoxUncheckedCreateWithoutCompanyInput> | CatalogBoxCreateWithoutCompanyInput[] | CatalogBoxUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogBoxCreateOrConnectWithoutCompanyInput | CatalogBoxCreateOrConnectWithoutCompanyInput[]
    createMany?: CatalogBoxCreateManyCompanyInputEnvelope
    connect?: CatalogBoxWhereUniqueInput | CatalogBoxWhereUniqueInput[]
  }

  export type CatalogPoleCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CatalogPoleCreateWithoutCompanyInput, CatalogPoleUncheckedCreateWithoutCompanyInput> | CatalogPoleCreateWithoutCompanyInput[] | CatalogPoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogPoleCreateOrConnectWithoutCompanyInput | CatalogPoleCreateOrConnectWithoutCompanyInput[]
    createMany?: CatalogPoleCreateManyCompanyInputEnvelope
    connect?: CatalogPoleWhereUniqueInput | CatalogPoleWhereUniqueInput[]
  }

  export type CatalogSplitterCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CatalogSplitterCreateWithoutCompanyInput, CatalogSplitterUncheckedCreateWithoutCompanyInput> | CatalogSplitterCreateWithoutCompanyInput[] | CatalogSplitterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogSplitterCreateOrConnectWithoutCompanyInput | CatalogSplitterCreateOrConnectWithoutCompanyInput[]
    createMany?: CatalogSplitterCreateManyCompanyInputEnvelope
    connect?: CatalogSplitterWhereUniqueInput | CatalogSplitterWhereUniqueInput[]
  }

  export type CatalogFusionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CatalogFusionCreateWithoutCompanyInput, CatalogFusionUncheckedCreateWithoutCompanyInput> | CatalogFusionCreateWithoutCompanyInput[] | CatalogFusionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogFusionCreateOrConnectWithoutCompanyInput | CatalogFusionCreateOrConnectWithoutCompanyInput[]
    createMany?: CatalogFusionCreateManyCompanyInputEnvelope
    connect?: CatalogFusionWhereUniqueInput | CatalogFusionWhereUniqueInput[]
  }

  export type CatalogOLTCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CatalogOLTCreateWithoutCompanyInput, CatalogOLTUncheckedCreateWithoutCompanyInput> | CatalogOLTCreateWithoutCompanyInput[] | CatalogOLTUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogOLTCreateOrConnectWithoutCompanyInput | CatalogOLTCreateOrConnectWithoutCompanyInput[]
    createMany?: CatalogOLTCreateManyCompanyInputEnvelope
    connect?: CatalogOLTWhereUniqueInput | CatalogOLTWhereUniqueInput[]
  }

  export type CableUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CableCreateWithoutCompanyInput, CableUncheckedCreateWithoutCompanyInput> | CableCreateWithoutCompanyInput[] | CableUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CableCreateOrConnectWithoutCompanyInput | CableCreateOrConnectWithoutCompanyInput[]
    createMany?: CableCreateManyCompanyInputEnvelope
    connect?: CableWhereUniqueInput | CableWhereUniqueInput[]
  }

  export type CtoUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CtoCreateWithoutCompanyInput, CtoUncheckedCreateWithoutCompanyInput> | CtoCreateWithoutCompanyInput[] | CtoUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CtoCreateOrConnectWithoutCompanyInput | CtoCreateOrConnectWithoutCompanyInput[]
    createMany?: CtoCreateManyCompanyInputEnvelope
    connect?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
  }

  export type PopUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PopCreateWithoutCompanyInput, PopUncheckedCreateWithoutCompanyInput> | PopCreateWithoutCompanyInput[] | PopUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PopCreateOrConnectWithoutCompanyInput | PopCreateOrConnectWithoutCompanyInput[]
    createMany?: PopCreateManyCompanyInputEnvelope
    connect?: PopWhereUniqueInput | PopWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProjectCreateWithoutCompanyInput, ProjectUncheckedCreateWithoutCompanyInput> | ProjectCreateWithoutCompanyInput[] | ProjectUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCompanyInput | ProjectCreateOrConnectWithoutCompanyInput[]
    createMany?: ProjectCreateManyCompanyInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PoleUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PoleCreateWithoutCompanyInput, PoleUncheckedCreateWithoutCompanyInput> | PoleCreateWithoutCompanyInput[] | PoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PoleCreateOrConnectWithoutCompanyInput | PoleCreateOrConnectWithoutCompanyInput[]
    createMany?: PoleCreateManyCompanyInputEnvelope
    connect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
  }

  export type CatalogCableUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CatalogCableCreateWithoutCompanyInput, CatalogCableUncheckedCreateWithoutCompanyInput> | CatalogCableCreateWithoutCompanyInput[] | CatalogCableUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogCableCreateOrConnectWithoutCompanyInput | CatalogCableCreateOrConnectWithoutCompanyInput[]
    createMany?: CatalogCableCreateManyCompanyInputEnvelope
    connect?: CatalogCableWhereUniqueInput | CatalogCableWhereUniqueInput[]
  }

  export type CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CatalogBoxCreateWithoutCompanyInput, CatalogBoxUncheckedCreateWithoutCompanyInput> | CatalogBoxCreateWithoutCompanyInput[] | CatalogBoxUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogBoxCreateOrConnectWithoutCompanyInput | CatalogBoxCreateOrConnectWithoutCompanyInput[]
    createMany?: CatalogBoxCreateManyCompanyInputEnvelope
    connect?: CatalogBoxWhereUniqueInput | CatalogBoxWhereUniqueInput[]
  }

  export type CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CatalogPoleCreateWithoutCompanyInput, CatalogPoleUncheckedCreateWithoutCompanyInput> | CatalogPoleCreateWithoutCompanyInput[] | CatalogPoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogPoleCreateOrConnectWithoutCompanyInput | CatalogPoleCreateOrConnectWithoutCompanyInput[]
    createMany?: CatalogPoleCreateManyCompanyInputEnvelope
    connect?: CatalogPoleWhereUniqueInput | CatalogPoleWhereUniqueInput[]
  }

  export type CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CatalogSplitterCreateWithoutCompanyInput, CatalogSplitterUncheckedCreateWithoutCompanyInput> | CatalogSplitterCreateWithoutCompanyInput[] | CatalogSplitterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogSplitterCreateOrConnectWithoutCompanyInput | CatalogSplitterCreateOrConnectWithoutCompanyInput[]
    createMany?: CatalogSplitterCreateManyCompanyInputEnvelope
    connect?: CatalogSplitterWhereUniqueInput | CatalogSplitterWhereUniqueInput[]
  }

  export type CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CatalogFusionCreateWithoutCompanyInput, CatalogFusionUncheckedCreateWithoutCompanyInput> | CatalogFusionCreateWithoutCompanyInput[] | CatalogFusionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogFusionCreateOrConnectWithoutCompanyInput | CatalogFusionCreateOrConnectWithoutCompanyInput[]
    createMany?: CatalogFusionCreateManyCompanyInputEnvelope
    connect?: CatalogFusionWhereUniqueInput | CatalogFusionWhereUniqueInput[]
  }

  export type CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CatalogOLTCreateWithoutCompanyInput, CatalogOLTUncheckedCreateWithoutCompanyInput> | CatalogOLTCreateWithoutCompanyInput[] | CatalogOLTUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogOLTCreateOrConnectWithoutCompanyInput | CatalogOLTCreateOrConnectWithoutCompanyInput[]
    createMany?: CatalogOLTCreateManyCompanyInputEnvelope
    connect?: CatalogOLTWhereUniqueInput | CatalogOLTWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CableUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CableCreateWithoutCompanyInput, CableUncheckedCreateWithoutCompanyInput> | CableCreateWithoutCompanyInput[] | CableUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CableCreateOrConnectWithoutCompanyInput | CableCreateOrConnectWithoutCompanyInput[]
    upsert?: CableUpsertWithWhereUniqueWithoutCompanyInput | CableUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CableCreateManyCompanyInputEnvelope
    set?: CableWhereUniqueInput | CableWhereUniqueInput[]
    disconnect?: CableWhereUniqueInput | CableWhereUniqueInput[]
    delete?: CableWhereUniqueInput | CableWhereUniqueInput[]
    connect?: CableWhereUniqueInput | CableWhereUniqueInput[]
    update?: CableUpdateWithWhereUniqueWithoutCompanyInput | CableUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CableUpdateManyWithWhereWithoutCompanyInput | CableUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CableScalarWhereInput | CableScalarWhereInput[]
  }

  export type PlanUpdateOneWithoutCompaniesNestedInput = {
    create?: XOR<PlanCreateWithoutCompaniesInput, PlanUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: PlanCreateOrConnectWithoutCompaniesInput
    upsert?: PlanUpsertWithoutCompaniesInput
    disconnect?: PlanWhereInput | boolean
    delete?: PlanWhereInput | boolean
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutCompaniesInput, PlanUpdateWithoutCompaniesInput>, PlanUncheckedUpdateWithoutCompaniesInput>
  }

  export type CtoUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CtoCreateWithoutCompanyInput, CtoUncheckedCreateWithoutCompanyInput> | CtoCreateWithoutCompanyInput[] | CtoUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CtoCreateOrConnectWithoutCompanyInput | CtoCreateOrConnectWithoutCompanyInput[]
    upsert?: CtoUpsertWithWhereUniqueWithoutCompanyInput | CtoUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CtoCreateManyCompanyInputEnvelope
    set?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    disconnect?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    delete?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    connect?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    update?: CtoUpdateWithWhereUniqueWithoutCompanyInput | CtoUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CtoUpdateManyWithWhereWithoutCompanyInput | CtoUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CtoScalarWhereInput | CtoScalarWhereInput[]
  }

  export type PopUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PopCreateWithoutCompanyInput, PopUncheckedCreateWithoutCompanyInput> | PopCreateWithoutCompanyInput[] | PopUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PopCreateOrConnectWithoutCompanyInput | PopCreateOrConnectWithoutCompanyInput[]
    upsert?: PopUpsertWithWhereUniqueWithoutCompanyInput | PopUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PopCreateManyCompanyInputEnvelope
    set?: PopWhereUniqueInput | PopWhereUniqueInput[]
    disconnect?: PopWhereUniqueInput | PopWhereUniqueInput[]
    delete?: PopWhereUniqueInput | PopWhereUniqueInput[]
    connect?: PopWhereUniqueInput | PopWhereUniqueInput[]
    update?: PopUpdateWithWhereUniqueWithoutCompanyInput | PopUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PopUpdateManyWithWhereWithoutCompanyInput | PopUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PopScalarWhereInput | PopScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProjectCreateWithoutCompanyInput, ProjectUncheckedCreateWithoutCompanyInput> | ProjectCreateWithoutCompanyInput[] | ProjectUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCompanyInput | ProjectCreateOrConnectWithoutCompanyInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCompanyInput | ProjectUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProjectCreateManyCompanyInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCompanyInput | ProjectUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCompanyInput | ProjectUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PoleUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PoleCreateWithoutCompanyInput, PoleUncheckedCreateWithoutCompanyInput> | PoleCreateWithoutCompanyInput[] | PoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PoleCreateOrConnectWithoutCompanyInput | PoleCreateOrConnectWithoutCompanyInput[]
    upsert?: PoleUpsertWithWhereUniqueWithoutCompanyInput | PoleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PoleCreateManyCompanyInputEnvelope
    set?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    disconnect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    delete?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    connect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    update?: PoleUpdateWithWhereUniqueWithoutCompanyInput | PoleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PoleUpdateManyWithWhereWithoutCompanyInput | PoleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PoleScalarWhereInput | PoleScalarWhereInput[]
  }

  export type CatalogCableUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CatalogCableCreateWithoutCompanyInput, CatalogCableUncheckedCreateWithoutCompanyInput> | CatalogCableCreateWithoutCompanyInput[] | CatalogCableUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogCableCreateOrConnectWithoutCompanyInput | CatalogCableCreateOrConnectWithoutCompanyInput[]
    upsert?: CatalogCableUpsertWithWhereUniqueWithoutCompanyInput | CatalogCableUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CatalogCableCreateManyCompanyInputEnvelope
    set?: CatalogCableWhereUniqueInput | CatalogCableWhereUniqueInput[]
    disconnect?: CatalogCableWhereUniqueInput | CatalogCableWhereUniqueInput[]
    delete?: CatalogCableWhereUniqueInput | CatalogCableWhereUniqueInput[]
    connect?: CatalogCableWhereUniqueInput | CatalogCableWhereUniqueInput[]
    update?: CatalogCableUpdateWithWhereUniqueWithoutCompanyInput | CatalogCableUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CatalogCableUpdateManyWithWhereWithoutCompanyInput | CatalogCableUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CatalogCableScalarWhereInput | CatalogCableScalarWhereInput[]
  }

  export type CatalogBoxUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CatalogBoxCreateWithoutCompanyInput, CatalogBoxUncheckedCreateWithoutCompanyInput> | CatalogBoxCreateWithoutCompanyInput[] | CatalogBoxUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogBoxCreateOrConnectWithoutCompanyInput | CatalogBoxCreateOrConnectWithoutCompanyInput[]
    upsert?: CatalogBoxUpsertWithWhereUniqueWithoutCompanyInput | CatalogBoxUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CatalogBoxCreateManyCompanyInputEnvelope
    set?: CatalogBoxWhereUniqueInput | CatalogBoxWhereUniqueInput[]
    disconnect?: CatalogBoxWhereUniqueInput | CatalogBoxWhereUniqueInput[]
    delete?: CatalogBoxWhereUniqueInput | CatalogBoxWhereUniqueInput[]
    connect?: CatalogBoxWhereUniqueInput | CatalogBoxWhereUniqueInput[]
    update?: CatalogBoxUpdateWithWhereUniqueWithoutCompanyInput | CatalogBoxUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CatalogBoxUpdateManyWithWhereWithoutCompanyInput | CatalogBoxUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CatalogBoxScalarWhereInput | CatalogBoxScalarWhereInput[]
  }

  export type CatalogPoleUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CatalogPoleCreateWithoutCompanyInput, CatalogPoleUncheckedCreateWithoutCompanyInput> | CatalogPoleCreateWithoutCompanyInput[] | CatalogPoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogPoleCreateOrConnectWithoutCompanyInput | CatalogPoleCreateOrConnectWithoutCompanyInput[]
    upsert?: CatalogPoleUpsertWithWhereUniqueWithoutCompanyInput | CatalogPoleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CatalogPoleCreateManyCompanyInputEnvelope
    set?: CatalogPoleWhereUniqueInput | CatalogPoleWhereUniqueInput[]
    disconnect?: CatalogPoleWhereUniqueInput | CatalogPoleWhereUniqueInput[]
    delete?: CatalogPoleWhereUniqueInput | CatalogPoleWhereUniqueInput[]
    connect?: CatalogPoleWhereUniqueInput | CatalogPoleWhereUniqueInput[]
    update?: CatalogPoleUpdateWithWhereUniqueWithoutCompanyInput | CatalogPoleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CatalogPoleUpdateManyWithWhereWithoutCompanyInput | CatalogPoleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CatalogPoleScalarWhereInput | CatalogPoleScalarWhereInput[]
  }

  export type CatalogSplitterUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CatalogSplitterCreateWithoutCompanyInput, CatalogSplitterUncheckedCreateWithoutCompanyInput> | CatalogSplitterCreateWithoutCompanyInput[] | CatalogSplitterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogSplitterCreateOrConnectWithoutCompanyInput | CatalogSplitterCreateOrConnectWithoutCompanyInput[]
    upsert?: CatalogSplitterUpsertWithWhereUniqueWithoutCompanyInput | CatalogSplitterUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CatalogSplitterCreateManyCompanyInputEnvelope
    set?: CatalogSplitterWhereUniqueInput | CatalogSplitterWhereUniqueInput[]
    disconnect?: CatalogSplitterWhereUniqueInput | CatalogSplitterWhereUniqueInput[]
    delete?: CatalogSplitterWhereUniqueInput | CatalogSplitterWhereUniqueInput[]
    connect?: CatalogSplitterWhereUniqueInput | CatalogSplitterWhereUniqueInput[]
    update?: CatalogSplitterUpdateWithWhereUniqueWithoutCompanyInput | CatalogSplitterUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CatalogSplitterUpdateManyWithWhereWithoutCompanyInput | CatalogSplitterUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CatalogSplitterScalarWhereInput | CatalogSplitterScalarWhereInput[]
  }

  export type CatalogFusionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CatalogFusionCreateWithoutCompanyInput, CatalogFusionUncheckedCreateWithoutCompanyInput> | CatalogFusionCreateWithoutCompanyInput[] | CatalogFusionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogFusionCreateOrConnectWithoutCompanyInput | CatalogFusionCreateOrConnectWithoutCompanyInput[]
    upsert?: CatalogFusionUpsertWithWhereUniqueWithoutCompanyInput | CatalogFusionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CatalogFusionCreateManyCompanyInputEnvelope
    set?: CatalogFusionWhereUniqueInput | CatalogFusionWhereUniqueInput[]
    disconnect?: CatalogFusionWhereUniqueInput | CatalogFusionWhereUniqueInput[]
    delete?: CatalogFusionWhereUniqueInput | CatalogFusionWhereUniqueInput[]
    connect?: CatalogFusionWhereUniqueInput | CatalogFusionWhereUniqueInput[]
    update?: CatalogFusionUpdateWithWhereUniqueWithoutCompanyInput | CatalogFusionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CatalogFusionUpdateManyWithWhereWithoutCompanyInput | CatalogFusionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CatalogFusionScalarWhereInput | CatalogFusionScalarWhereInput[]
  }

  export type CatalogOLTUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CatalogOLTCreateWithoutCompanyInput, CatalogOLTUncheckedCreateWithoutCompanyInput> | CatalogOLTCreateWithoutCompanyInput[] | CatalogOLTUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogOLTCreateOrConnectWithoutCompanyInput | CatalogOLTCreateOrConnectWithoutCompanyInput[]
    upsert?: CatalogOLTUpsertWithWhereUniqueWithoutCompanyInput | CatalogOLTUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CatalogOLTCreateManyCompanyInputEnvelope
    set?: CatalogOLTWhereUniqueInput | CatalogOLTWhereUniqueInput[]
    disconnect?: CatalogOLTWhereUniqueInput | CatalogOLTWhereUniqueInput[]
    delete?: CatalogOLTWhereUniqueInput | CatalogOLTWhereUniqueInput[]
    connect?: CatalogOLTWhereUniqueInput | CatalogOLTWhereUniqueInput[]
    update?: CatalogOLTUpdateWithWhereUniqueWithoutCompanyInput | CatalogOLTUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CatalogOLTUpdateManyWithWhereWithoutCompanyInput | CatalogOLTUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CatalogOLTScalarWhereInput | CatalogOLTScalarWhereInput[]
  }

  export type CableUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CableCreateWithoutCompanyInput, CableUncheckedCreateWithoutCompanyInput> | CableCreateWithoutCompanyInput[] | CableUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CableCreateOrConnectWithoutCompanyInput | CableCreateOrConnectWithoutCompanyInput[]
    upsert?: CableUpsertWithWhereUniqueWithoutCompanyInput | CableUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CableCreateManyCompanyInputEnvelope
    set?: CableWhereUniqueInput | CableWhereUniqueInput[]
    disconnect?: CableWhereUniqueInput | CableWhereUniqueInput[]
    delete?: CableWhereUniqueInput | CableWhereUniqueInput[]
    connect?: CableWhereUniqueInput | CableWhereUniqueInput[]
    update?: CableUpdateWithWhereUniqueWithoutCompanyInput | CableUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CableUpdateManyWithWhereWithoutCompanyInput | CableUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CableScalarWhereInput | CableScalarWhereInput[]
  }

  export type CtoUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CtoCreateWithoutCompanyInput, CtoUncheckedCreateWithoutCompanyInput> | CtoCreateWithoutCompanyInput[] | CtoUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CtoCreateOrConnectWithoutCompanyInput | CtoCreateOrConnectWithoutCompanyInput[]
    upsert?: CtoUpsertWithWhereUniqueWithoutCompanyInput | CtoUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CtoCreateManyCompanyInputEnvelope
    set?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    disconnect?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    delete?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    connect?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    update?: CtoUpdateWithWhereUniqueWithoutCompanyInput | CtoUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CtoUpdateManyWithWhereWithoutCompanyInput | CtoUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CtoScalarWhereInput | CtoScalarWhereInput[]
  }

  export type PopUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PopCreateWithoutCompanyInput, PopUncheckedCreateWithoutCompanyInput> | PopCreateWithoutCompanyInput[] | PopUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PopCreateOrConnectWithoutCompanyInput | PopCreateOrConnectWithoutCompanyInput[]
    upsert?: PopUpsertWithWhereUniqueWithoutCompanyInput | PopUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PopCreateManyCompanyInputEnvelope
    set?: PopWhereUniqueInput | PopWhereUniqueInput[]
    disconnect?: PopWhereUniqueInput | PopWhereUniqueInput[]
    delete?: PopWhereUniqueInput | PopWhereUniqueInput[]
    connect?: PopWhereUniqueInput | PopWhereUniqueInput[]
    update?: PopUpdateWithWhereUniqueWithoutCompanyInput | PopUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PopUpdateManyWithWhereWithoutCompanyInput | PopUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PopScalarWhereInput | PopScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProjectCreateWithoutCompanyInput, ProjectUncheckedCreateWithoutCompanyInput> | ProjectCreateWithoutCompanyInput[] | ProjectUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCompanyInput | ProjectCreateOrConnectWithoutCompanyInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCompanyInput | ProjectUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProjectCreateManyCompanyInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCompanyInput | ProjectUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCompanyInput | ProjectUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PoleUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PoleCreateWithoutCompanyInput, PoleUncheckedCreateWithoutCompanyInput> | PoleCreateWithoutCompanyInput[] | PoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PoleCreateOrConnectWithoutCompanyInput | PoleCreateOrConnectWithoutCompanyInput[]
    upsert?: PoleUpsertWithWhereUniqueWithoutCompanyInput | PoleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PoleCreateManyCompanyInputEnvelope
    set?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    disconnect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    delete?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    connect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    update?: PoleUpdateWithWhereUniqueWithoutCompanyInput | PoleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PoleUpdateManyWithWhereWithoutCompanyInput | PoleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PoleScalarWhereInput | PoleScalarWhereInput[]
  }

  export type CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CatalogCableCreateWithoutCompanyInput, CatalogCableUncheckedCreateWithoutCompanyInput> | CatalogCableCreateWithoutCompanyInput[] | CatalogCableUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogCableCreateOrConnectWithoutCompanyInput | CatalogCableCreateOrConnectWithoutCompanyInput[]
    upsert?: CatalogCableUpsertWithWhereUniqueWithoutCompanyInput | CatalogCableUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CatalogCableCreateManyCompanyInputEnvelope
    set?: CatalogCableWhereUniqueInput | CatalogCableWhereUniqueInput[]
    disconnect?: CatalogCableWhereUniqueInput | CatalogCableWhereUniqueInput[]
    delete?: CatalogCableWhereUniqueInput | CatalogCableWhereUniqueInput[]
    connect?: CatalogCableWhereUniqueInput | CatalogCableWhereUniqueInput[]
    update?: CatalogCableUpdateWithWhereUniqueWithoutCompanyInput | CatalogCableUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CatalogCableUpdateManyWithWhereWithoutCompanyInput | CatalogCableUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CatalogCableScalarWhereInput | CatalogCableScalarWhereInput[]
  }

  export type CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CatalogBoxCreateWithoutCompanyInput, CatalogBoxUncheckedCreateWithoutCompanyInput> | CatalogBoxCreateWithoutCompanyInput[] | CatalogBoxUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogBoxCreateOrConnectWithoutCompanyInput | CatalogBoxCreateOrConnectWithoutCompanyInput[]
    upsert?: CatalogBoxUpsertWithWhereUniqueWithoutCompanyInput | CatalogBoxUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CatalogBoxCreateManyCompanyInputEnvelope
    set?: CatalogBoxWhereUniqueInput | CatalogBoxWhereUniqueInput[]
    disconnect?: CatalogBoxWhereUniqueInput | CatalogBoxWhereUniqueInput[]
    delete?: CatalogBoxWhereUniqueInput | CatalogBoxWhereUniqueInput[]
    connect?: CatalogBoxWhereUniqueInput | CatalogBoxWhereUniqueInput[]
    update?: CatalogBoxUpdateWithWhereUniqueWithoutCompanyInput | CatalogBoxUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CatalogBoxUpdateManyWithWhereWithoutCompanyInput | CatalogBoxUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CatalogBoxScalarWhereInput | CatalogBoxScalarWhereInput[]
  }

  export type CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CatalogPoleCreateWithoutCompanyInput, CatalogPoleUncheckedCreateWithoutCompanyInput> | CatalogPoleCreateWithoutCompanyInput[] | CatalogPoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogPoleCreateOrConnectWithoutCompanyInput | CatalogPoleCreateOrConnectWithoutCompanyInput[]
    upsert?: CatalogPoleUpsertWithWhereUniqueWithoutCompanyInput | CatalogPoleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CatalogPoleCreateManyCompanyInputEnvelope
    set?: CatalogPoleWhereUniqueInput | CatalogPoleWhereUniqueInput[]
    disconnect?: CatalogPoleWhereUniqueInput | CatalogPoleWhereUniqueInput[]
    delete?: CatalogPoleWhereUniqueInput | CatalogPoleWhereUniqueInput[]
    connect?: CatalogPoleWhereUniqueInput | CatalogPoleWhereUniqueInput[]
    update?: CatalogPoleUpdateWithWhereUniqueWithoutCompanyInput | CatalogPoleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CatalogPoleUpdateManyWithWhereWithoutCompanyInput | CatalogPoleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CatalogPoleScalarWhereInput | CatalogPoleScalarWhereInput[]
  }

  export type CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CatalogSplitterCreateWithoutCompanyInput, CatalogSplitterUncheckedCreateWithoutCompanyInput> | CatalogSplitterCreateWithoutCompanyInput[] | CatalogSplitterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogSplitterCreateOrConnectWithoutCompanyInput | CatalogSplitterCreateOrConnectWithoutCompanyInput[]
    upsert?: CatalogSplitterUpsertWithWhereUniqueWithoutCompanyInput | CatalogSplitterUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CatalogSplitterCreateManyCompanyInputEnvelope
    set?: CatalogSplitterWhereUniqueInput | CatalogSplitterWhereUniqueInput[]
    disconnect?: CatalogSplitterWhereUniqueInput | CatalogSplitterWhereUniqueInput[]
    delete?: CatalogSplitterWhereUniqueInput | CatalogSplitterWhereUniqueInput[]
    connect?: CatalogSplitterWhereUniqueInput | CatalogSplitterWhereUniqueInput[]
    update?: CatalogSplitterUpdateWithWhereUniqueWithoutCompanyInput | CatalogSplitterUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CatalogSplitterUpdateManyWithWhereWithoutCompanyInput | CatalogSplitterUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CatalogSplitterScalarWhereInput | CatalogSplitterScalarWhereInput[]
  }

  export type CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CatalogFusionCreateWithoutCompanyInput, CatalogFusionUncheckedCreateWithoutCompanyInput> | CatalogFusionCreateWithoutCompanyInput[] | CatalogFusionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogFusionCreateOrConnectWithoutCompanyInput | CatalogFusionCreateOrConnectWithoutCompanyInput[]
    upsert?: CatalogFusionUpsertWithWhereUniqueWithoutCompanyInput | CatalogFusionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CatalogFusionCreateManyCompanyInputEnvelope
    set?: CatalogFusionWhereUniqueInput | CatalogFusionWhereUniqueInput[]
    disconnect?: CatalogFusionWhereUniqueInput | CatalogFusionWhereUniqueInput[]
    delete?: CatalogFusionWhereUniqueInput | CatalogFusionWhereUniqueInput[]
    connect?: CatalogFusionWhereUniqueInput | CatalogFusionWhereUniqueInput[]
    update?: CatalogFusionUpdateWithWhereUniqueWithoutCompanyInput | CatalogFusionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CatalogFusionUpdateManyWithWhereWithoutCompanyInput | CatalogFusionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CatalogFusionScalarWhereInput | CatalogFusionScalarWhereInput[]
  }

  export type CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CatalogOLTCreateWithoutCompanyInput, CatalogOLTUncheckedCreateWithoutCompanyInput> | CatalogOLTCreateWithoutCompanyInput[] | CatalogOLTUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CatalogOLTCreateOrConnectWithoutCompanyInput | CatalogOLTCreateOrConnectWithoutCompanyInput[]
    upsert?: CatalogOLTUpsertWithWhereUniqueWithoutCompanyInput | CatalogOLTUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CatalogOLTCreateManyCompanyInputEnvelope
    set?: CatalogOLTWhereUniqueInput | CatalogOLTWhereUniqueInput[]
    disconnect?: CatalogOLTWhereUniqueInput | CatalogOLTWhereUniqueInput[]
    delete?: CatalogOLTWhereUniqueInput | CatalogOLTWhereUniqueInput[]
    connect?: CatalogOLTWhereUniqueInput | CatalogOLTWhereUniqueInput[]
    update?: CatalogOLTUpdateWithWhereUniqueWithoutCompanyInput | CatalogOLTUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CatalogOLTUpdateManyWithWhereWithoutCompanyInput | CatalogOLTUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CatalogOLTScalarWhereInput | CatalogOLTScalarWhereInput[]
  }

  export type CompanyCreateNestedManyWithoutPlanInput = {
    create?: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput> | CompanyCreateWithoutPlanInput[] | CompanyUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutPlanInput | CompanyCreateOrConnectWithoutPlanInput[]
    createMany?: CompanyCreateManyPlanInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type CompanyUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput> | CompanyCreateWithoutPlanInput[] | CompanyUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutPlanInput | CompanyCreateOrConnectWithoutPlanInput[]
    createMany?: CompanyCreateManyPlanInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateManyWithoutPlanNestedInput = {
    create?: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput> | CompanyCreateWithoutPlanInput[] | CompanyUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutPlanInput | CompanyCreateOrConnectWithoutPlanInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutPlanInput | CompanyUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: CompanyCreateManyPlanInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutPlanInput | CompanyUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutPlanInput | CompanyUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type CompanyUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput> | CompanyCreateWithoutPlanInput[] | CompanyUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutPlanInput | CompanyCreateOrConnectWithoutPlanInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutPlanInput | CompanyUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: CompanyCreateManyPlanInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutPlanInput | CompanyUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutPlanInput | CompanyUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type CableCreateNestedManyWithoutProjectInput = {
    create?: XOR<CableCreateWithoutProjectInput, CableUncheckedCreateWithoutProjectInput> | CableCreateWithoutProjectInput[] | CableUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CableCreateOrConnectWithoutProjectInput | CableCreateOrConnectWithoutProjectInput[]
    createMany?: CableCreateManyProjectInputEnvelope
    connect?: CableWhereUniqueInput | CableWhereUniqueInput[]
  }

  export type CtoCreateNestedManyWithoutProjectInput = {
    create?: XOR<CtoCreateWithoutProjectInput, CtoUncheckedCreateWithoutProjectInput> | CtoCreateWithoutProjectInput[] | CtoUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CtoCreateOrConnectWithoutProjectInput | CtoCreateOrConnectWithoutProjectInput[]
    createMany?: CtoCreateManyProjectInputEnvelope
    connect?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
  }

  export type PopCreateNestedManyWithoutProjectInput = {
    create?: XOR<PopCreateWithoutProjectInput, PopUncheckedCreateWithoutProjectInput> | PopCreateWithoutProjectInput[] | PopUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PopCreateOrConnectWithoutProjectInput | PopCreateOrConnectWithoutProjectInput[]
    createMany?: PopCreateManyProjectInputEnvelope
    connect?: PopWhereUniqueInput | PopWhereUniqueInput[]
  }

  export type PoleCreateNestedManyWithoutProjectInput = {
    create?: XOR<PoleCreateWithoutProjectInput, PoleUncheckedCreateWithoutProjectInput> | PoleCreateWithoutProjectInput[] | PoleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PoleCreateOrConnectWithoutProjectInput | PoleCreateOrConnectWithoutProjectInput[]
    createMany?: PoleCreateManyProjectInputEnvelope
    connect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutProjectsInput = {
    create?: XOR<CompanyCreateWithoutProjectsInput, CompanyUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProjectsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type CableUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CableCreateWithoutProjectInput, CableUncheckedCreateWithoutProjectInput> | CableCreateWithoutProjectInput[] | CableUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CableCreateOrConnectWithoutProjectInput | CableCreateOrConnectWithoutProjectInput[]
    createMany?: CableCreateManyProjectInputEnvelope
    connect?: CableWhereUniqueInput | CableWhereUniqueInput[]
  }

  export type CtoUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CtoCreateWithoutProjectInput, CtoUncheckedCreateWithoutProjectInput> | CtoCreateWithoutProjectInput[] | CtoUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CtoCreateOrConnectWithoutProjectInput | CtoCreateOrConnectWithoutProjectInput[]
    createMany?: CtoCreateManyProjectInputEnvelope
    connect?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
  }

  export type PopUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PopCreateWithoutProjectInput, PopUncheckedCreateWithoutProjectInput> | PopCreateWithoutProjectInput[] | PopUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PopCreateOrConnectWithoutProjectInput | PopCreateOrConnectWithoutProjectInput[]
    createMany?: PopCreateManyProjectInputEnvelope
    connect?: PopWhereUniqueInput | PopWhereUniqueInput[]
  }

  export type PoleUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PoleCreateWithoutProjectInput, PoleUncheckedCreateWithoutProjectInput> | PoleCreateWithoutProjectInput[] | PoleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PoleCreateOrConnectWithoutProjectInput | PoleCreateOrConnectWithoutProjectInput[]
    createMany?: PoleCreateManyProjectInputEnvelope
    connect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CableUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CableCreateWithoutProjectInput, CableUncheckedCreateWithoutProjectInput> | CableCreateWithoutProjectInput[] | CableUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CableCreateOrConnectWithoutProjectInput | CableCreateOrConnectWithoutProjectInput[]
    upsert?: CableUpsertWithWhereUniqueWithoutProjectInput | CableUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CableCreateManyProjectInputEnvelope
    set?: CableWhereUniqueInput | CableWhereUniqueInput[]
    disconnect?: CableWhereUniqueInput | CableWhereUniqueInput[]
    delete?: CableWhereUniqueInput | CableWhereUniqueInput[]
    connect?: CableWhereUniqueInput | CableWhereUniqueInput[]
    update?: CableUpdateWithWhereUniqueWithoutProjectInput | CableUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CableUpdateManyWithWhereWithoutProjectInput | CableUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CableScalarWhereInput | CableScalarWhereInput[]
  }

  export type CtoUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CtoCreateWithoutProjectInput, CtoUncheckedCreateWithoutProjectInput> | CtoCreateWithoutProjectInput[] | CtoUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CtoCreateOrConnectWithoutProjectInput | CtoCreateOrConnectWithoutProjectInput[]
    upsert?: CtoUpsertWithWhereUniqueWithoutProjectInput | CtoUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CtoCreateManyProjectInputEnvelope
    set?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    disconnect?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    delete?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    connect?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    update?: CtoUpdateWithWhereUniqueWithoutProjectInput | CtoUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CtoUpdateManyWithWhereWithoutProjectInput | CtoUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CtoScalarWhereInput | CtoScalarWhereInput[]
  }

  export type PopUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PopCreateWithoutProjectInput, PopUncheckedCreateWithoutProjectInput> | PopCreateWithoutProjectInput[] | PopUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PopCreateOrConnectWithoutProjectInput | PopCreateOrConnectWithoutProjectInput[]
    upsert?: PopUpsertWithWhereUniqueWithoutProjectInput | PopUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PopCreateManyProjectInputEnvelope
    set?: PopWhereUniqueInput | PopWhereUniqueInput[]
    disconnect?: PopWhereUniqueInput | PopWhereUniqueInput[]
    delete?: PopWhereUniqueInput | PopWhereUniqueInput[]
    connect?: PopWhereUniqueInput | PopWhereUniqueInput[]
    update?: PopUpdateWithWhereUniqueWithoutProjectInput | PopUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PopUpdateManyWithWhereWithoutProjectInput | PopUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PopScalarWhereInput | PopScalarWhereInput[]
  }

  export type PoleUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PoleCreateWithoutProjectInput, PoleUncheckedCreateWithoutProjectInput> | PoleCreateWithoutProjectInput[] | PoleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PoleCreateOrConnectWithoutProjectInput | PoleCreateOrConnectWithoutProjectInput[]
    upsert?: PoleUpsertWithWhereUniqueWithoutProjectInput | PoleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PoleCreateManyProjectInputEnvelope
    set?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    disconnect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    delete?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    connect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    update?: PoleUpdateWithWhereUniqueWithoutProjectInput | PoleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PoleUpdateManyWithWhereWithoutProjectInput | PoleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PoleScalarWhereInput | PoleScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<CompanyCreateWithoutProjectsInput, CompanyUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProjectsInput
    upsert?: CompanyUpsertWithoutProjectsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutProjectsInput, CompanyUpdateWithoutProjectsInput>, CompanyUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type CableUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CableCreateWithoutProjectInput, CableUncheckedCreateWithoutProjectInput> | CableCreateWithoutProjectInput[] | CableUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CableCreateOrConnectWithoutProjectInput | CableCreateOrConnectWithoutProjectInput[]
    upsert?: CableUpsertWithWhereUniqueWithoutProjectInput | CableUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CableCreateManyProjectInputEnvelope
    set?: CableWhereUniqueInput | CableWhereUniqueInput[]
    disconnect?: CableWhereUniqueInput | CableWhereUniqueInput[]
    delete?: CableWhereUniqueInput | CableWhereUniqueInput[]
    connect?: CableWhereUniqueInput | CableWhereUniqueInput[]
    update?: CableUpdateWithWhereUniqueWithoutProjectInput | CableUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CableUpdateManyWithWhereWithoutProjectInput | CableUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CableScalarWhereInput | CableScalarWhereInput[]
  }

  export type CtoUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CtoCreateWithoutProjectInput, CtoUncheckedCreateWithoutProjectInput> | CtoCreateWithoutProjectInput[] | CtoUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CtoCreateOrConnectWithoutProjectInput | CtoCreateOrConnectWithoutProjectInput[]
    upsert?: CtoUpsertWithWhereUniqueWithoutProjectInput | CtoUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CtoCreateManyProjectInputEnvelope
    set?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    disconnect?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    delete?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    connect?: CtoWhereUniqueInput | CtoWhereUniqueInput[]
    update?: CtoUpdateWithWhereUniqueWithoutProjectInput | CtoUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CtoUpdateManyWithWhereWithoutProjectInput | CtoUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CtoScalarWhereInput | CtoScalarWhereInput[]
  }

  export type PopUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PopCreateWithoutProjectInput, PopUncheckedCreateWithoutProjectInput> | PopCreateWithoutProjectInput[] | PopUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PopCreateOrConnectWithoutProjectInput | PopCreateOrConnectWithoutProjectInput[]
    upsert?: PopUpsertWithWhereUniqueWithoutProjectInput | PopUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PopCreateManyProjectInputEnvelope
    set?: PopWhereUniqueInput | PopWhereUniqueInput[]
    disconnect?: PopWhereUniqueInput | PopWhereUniqueInput[]
    delete?: PopWhereUniqueInput | PopWhereUniqueInput[]
    connect?: PopWhereUniqueInput | PopWhereUniqueInput[]
    update?: PopUpdateWithWhereUniqueWithoutProjectInput | PopUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PopUpdateManyWithWhereWithoutProjectInput | PopUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PopScalarWhereInput | PopScalarWhereInput[]
  }

  export type PoleUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PoleCreateWithoutProjectInput, PoleUncheckedCreateWithoutProjectInput> | PoleCreateWithoutProjectInput[] | PoleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PoleCreateOrConnectWithoutProjectInput | PoleCreateOrConnectWithoutProjectInput[]
    upsert?: PoleUpsertWithWhereUniqueWithoutProjectInput | PoleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PoleCreateManyProjectInputEnvelope
    set?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    disconnect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    delete?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    connect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    update?: PoleUpdateWithWhereUniqueWithoutProjectInput | PoleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PoleUpdateManyWithWhereWithoutProjectInput | PoleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PoleScalarWhereInput | PoleScalarWhereInput[]
  }

  export type CtoCreateinputCableIdsInput = {
    set: string[]
  }

  export type CompanyCreateNestedOneWithoutCtosInput = {
    create?: XOR<CompanyCreateWithoutCtosInput, CompanyUncheckedCreateWithoutCtosInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCtosInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutCtosInput = {
    create?: XOR<ProjectCreateWithoutCtosInput, ProjectUncheckedCreateWithoutCtosInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCtosInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumEquipmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentStatus
  }

  export type CtoUpdateinputCableIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateOneWithoutCtosNestedInput = {
    create?: XOR<CompanyCreateWithoutCtosInput, CompanyUncheckedCreateWithoutCtosInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCtosInput
    upsert?: CompanyUpsertWithoutCtosInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCtosInput, CompanyUpdateWithoutCtosInput>, CompanyUncheckedUpdateWithoutCtosInput>
  }

  export type ProjectUpdateOneRequiredWithoutCtosNestedInput = {
    create?: XOR<ProjectCreateWithoutCtosInput, ProjectUncheckedCreateWithoutCtosInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCtosInput
    upsert?: ProjectUpsertWithoutCtosInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCtosInput, ProjectUpdateWithoutCtosInput>, ProjectUncheckedUpdateWithoutCtosInput>
  }

  export type PopCreateinputCableIdsInput = {
    set: string[]
  }

  export type CompanyCreateNestedOneWithoutPopsInput = {
    create?: XOR<CompanyCreateWithoutPopsInput, CompanyUncheckedCreateWithoutPopsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPopsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutPopsInput = {
    create?: XOR<ProjectCreateWithoutPopsInput, ProjectUncheckedCreateWithoutPopsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPopsInput
    connect?: ProjectWhereUniqueInput
  }

  export type PopUpdateinputCableIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateOneWithoutPopsNestedInput = {
    create?: XOR<CompanyCreateWithoutPopsInput, CompanyUncheckedCreateWithoutPopsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPopsInput
    upsert?: CompanyUpsertWithoutPopsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPopsInput, CompanyUpdateWithoutPopsInput>, CompanyUncheckedUpdateWithoutPopsInput>
  }

  export type ProjectUpdateOneRequiredWithoutPopsNestedInput = {
    create?: XOR<ProjectCreateWithoutPopsInput, ProjectUncheckedCreateWithoutPopsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPopsInput
    upsert?: ProjectUpsertWithoutPopsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPopsInput, ProjectUpdateWithoutPopsInput>, ProjectUncheckedUpdateWithoutPopsInput>
  }

  export type CompanyCreateNestedOneWithoutCablesInput = {
    create?: XOR<CompanyCreateWithoutCablesInput, CompanyUncheckedCreateWithoutCablesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCablesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutCablesInput = {
    create?: XOR<ProjectCreateWithoutCablesInput, ProjectUncheckedCreateWithoutCablesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCablesInput
    connect?: ProjectWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutCablesNestedInput = {
    create?: XOR<CompanyCreateWithoutCablesInput, CompanyUncheckedCreateWithoutCablesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCablesInput
    upsert?: CompanyUpsertWithoutCablesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCablesInput, CompanyUpdateWithoutCablesInput>, CompanyUncheckedUpdateWithoutCablesInput>
  }

  export type ProjectUpdateOneRequiredWithoutCablesNestedInput = {
    create?: XOR<ProjectCreateWithoutCablesInput, ProjectUncheckedCreateWithoutCablesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCablesInput
    upsert?: ProjectUpsertWithoutCablesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCablesInput, ProjectUpdateWithoutCablesInput>, ProjectUncheckedUpdateWithoutCablesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyCreateNestedOneWithoutCatalogSplittersInput = {
    create?: XOR<CompanyCreateWithoutCatalogSplittersInput, CompanyUncheckedCreateWithoutCatalogSplittersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCatalogSplittersInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutCatalogSplittersNestedInput = {
    create?: XOR<CompanyCreateWithoutCatalogSplittersInput, CompanyUncheckedCreateWithoutCatalogSplittersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCatalogSplittersInput
    upsert?: CompanyUpsertWithoutCatalogSplittersInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCatalogSplittersInput, CompanyUpdateWithoutCatalogSplittersInput>, CompanyUncheckedUpdateWithoutCatalogSplittersInput>
  }

  export type CompanyCreateNestedOneWithoutCatalogCablesInput = {
    create?: XOR<CompanyCreateWithoutCatalogCablesInput, CompanyUncheckedCreateWithoutCatalogCablesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCatalogCablesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutCatalogCablesNestedInput = {
    create?: XOR<CompanyCreateWithoutCatalogCablesInput, CompanyUncheckedCreateWithoutCatalogCablesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCatalogCablesInput
    upsert?: CompanyUpsertWithoutCatalogCablesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCatalogCablesInput, CompanyUpdateWithoutCatalogCablesInput>, CompanyUncheckedUpdateWithoutCatalogCablesInput>
  }

  export type CompanyCreateNestedOneWithoutCatalogBoxesInput = {
    create?: XOR<CompanyCreateWithoutCatalogBoxesInput, CompanyUncheckedCreateWithoutCatalogBoxesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCatalogBoxesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutCatalogBoxesNestedInput = {
    create?: XOR<CompanyCreateWithoutCatalogBoxesInput, CompanyUncheckedCreateWithoutCatalogBoxesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCatalogBoxesInput
    upsert?: CompanyUpsertWithoutCatalogBoxesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCatalogBoxesInput, CompanyUpdateWithoutCatalogBoxesInput>, CompanyUncheckedUpdateWithoutCatalogBoxesInput>
  }

  export type PoleCreateNestedManyWithoutCatalogInput = {
    create?: XOR<PoleCreateWithoutCatalogInput, PoleUncheckedCreateWithoutCatalogInput> | PoleCreateWithoutCatalogInput[] | PoleUncheckedCreateWithoutCatalogInput[]
    connectOrCreate?: PoleCreateOrConnectWithoutCatalogInput | PoleCreateOrConnectWithoutCatalogInput[]
    createMany?: PoleCreateManyCatalogInputEnvelope
    connect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutCatalogPolesInput = {
    create?: XOR<CompanyCreateWithoutCatalogPolesInput, CompanyUncheckedCreateWithoutCatalogPolesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCatalogPolesInput
    connect?: CompanyWhereUniqueInput
  }

  export type PoleUncheckedCreateNestedManyWithoutCatalogInput = {
    create?: XOR<PoleCreateWithoutCatalogInput, PoleUncheckedCreateWithoutCatalogInput> | PoleCreateWithoutCatalogInput[] | PoleUncheckedCreateWithoutCatalogInput[]
    connectOrCreate?: PoleCreateOrConnectWithoutCatalogInput | PoleCreateOrConnectWithoutCatalogInput[]
    createMany?: PoleCreateManyCatalogInputEnvelope
    connect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
  }

  export type PoleUpdateManyWithoutCatalogNestedInput = {
    create?: XOR<PoleCreateWithoutCatalogInput, PoleUncheckedCreateWithoutCatalogInput> | PoleCreateWithoutCatalogInput[] | PoleUncheckedCreateWithoutCatalogInput[]
    connectOrCreate?: PoleCreateOrConnectWithoutCatalogInput | PoleCreateOrConnectWithoutCatalogInput[]
    upsert?: PoleUpsertWithWhereUniqueWithoutCatalogInput | PoleUpsertWithWhereUniqueWithoutCatalogInput[]
    createMany?: PoleCreateManyCatalogInputEnvelope
    set?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    disconnect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    delete?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    connect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    update?: PoleUpdateWithWhereUniqueWithoutCatalogInput | PoleUpdateWithWhereUniqueWithoutCatalogInput[]
    updateMany?: PoleUpdateManyWithWhereWithoutCatalogInput | PoleUpdateManyWithWhereWithoutCatalogInput[]
    deleteMany?: PoleScalarWhereInput | PoleScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutCatalogPolesNestedInput = {
    create?: XOR<CompanyCreateWithoutCatalogPolesInput, CompanyUncheckedCreateWithoutCatalogPolesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCatalogPolesInput
    upsert?: CompanyUpsertWithoutCatalogPolesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCatalogPolesInput, CompanyUpdateWithoutCatalogPolesInput>, CompanyUncheckedUpdateWithoutCatalogPolesInput>
  }

  export type PoleUncheckedUpdateManyWithoutCatalogNestedInput = {
    create?: XOR<PoleCreateWithoutCatalogInput, PoleUncheckedCreateWithoutCatalogInput> | PoleCreateWithoutCatalogInput[] | PoleUncheckedCreateWithoutCatalogInput[]
    connectOrCreate?: PoleCreateOrConnectWithoutCatalogInput | PoleCreateOrConnectWithoutCatalogInput[]
    upsert?: PoleUpsertWithWhereUniqueWithoutCatalogInput | PoleUpsertWithWhereUniqueWithoutCatalogInput[]
    createMany?: PoleCreateManyCatalogInputEnvelope
    set?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    disconnect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    delete?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    connect?: PoleWhereUniqueInput | PoleWhereUniqueInput[]
    update?: PoleUpdateWithWhereUniqueWithoutCatalogInput | PoleUpdateWithWhereUniqueWithoutCatalogInput[]
    updateMany?: PoleUpdateManyWithWhereWithoutCatalogInput | PoleUpdateManyWithWhereWithoutCatalogInput[]
    deleteMany?: PoleScalarWhereInput | PoleScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutPolesInput = {
    create?: XOR<CompanyCreateWithoutPolesInput, CompanyUncheckedCreateWithoutPolesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPolesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutPolesInput = {
    create?: XOR<ProjectCreateWithoutPolesInput, ProjectUncheckedCreateWithoutPolesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPolesInput
    connect?: ProjectWhereUniqueInput
  }

  export type CatalogPoleCreateNestedOneWithoutInstancesInput = {
    create?: XOR<CatalogPoleCreateWithoutInstancesInput, CatalogPoleUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: CatalogPoleCreateOrConnectWithoutInstancesInput
    connect?: CatalogPoleWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutPolesNestedInput = {
    create?: XOR<CompanyCreateWithoutPolesInput, CompanyUncheckedCreateWithoutPolesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPolesInput
    upsert?: CompanyUpsertWithoutPolesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPolesInput, CompanyUpdateWithoutPolesInput>, CompanyUncheckedUpdateWithoutPolesInput>
  }

  export type ProjectUpdateOneRequiredWithoutPolesNestedInput = {
    create?: XOR<ProjectCreateWithoutPolesInput, ProjectUncheckedCreateWithoutPolesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPolesInput
    upsert?: ProjectUpsertWithoutPolesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPolesInput, ProjectUpdateWithoutPolesInput>, ProjectUncheckedUpdateWithoutPolesInput>
  }

  export type CatalogPoleUpdateOneWithoutInstancesNestedInput = {
    create?: XOR<CatalogPoleCreateWithoutInstancesInput, CatalogPoleUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: CatalogPoleCreateOrConnectWithoutInstancesInput
    upsert?: CatalogPoleUpsertWithoutInstancesInput
    disconnect?: CatalogPoleWhereInput | boolean
    delete?: CatalogPoleWhereInput | boolean
    connect?: CatalogPoleWhereUniqueInput
    update?: XOR<XOR<CatalogPoleUpdateToOneWithWhereWithoutInstancesInput, CatalogPoleUpdateWithoutInstancesInput>, CatalogPoleUncheckedUpdateWithoutInstancesInput>
  }

  export type CompanyCreateNestedOneWithoutCatalogFusionsInput = {
    create?: XOR<CompanyCreateWithoutCatalogFusionsInput, CompanyUncheckedCreateWithoutCatalogFusionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCatalogFusionsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutCatalogFusionsNestedInput = {
    create?: XOR<CompanyCreateWithoutCatalogFusionsInput, CompanyUncheckedCreateWithoutCatalogFusionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCatalogFusionsInput
    upsert?: CompanyUpsertWithoutCatalogFusionsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCatalogFusionsInput, CompanyUpdateWithoutCatalogFusionsInput>, CompanyUncheckedUpdateWithoutCatalogFusionsInput>
  }

  export type CompanyCreateNestedOneWithoutCatalogOLTsInput = {
    create?: XOR<CompanyCreateWithoutCatalogOLTsInput, CompanyUncheckedCreateWithoutCatalogOLTsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCatalogOLTsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutCatalogOLTsNestedInput = {
    create?: XOR<CompanyCreateWithoutCatalogOLTsInput, CompanyUncheckedCreateWithoutCatalogOLTsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCatalogOLTsInput
    upsert?: CompanyUpsertWithoutCatalogOLTsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCatalogOLTsInput, CompanyUpdateWithoutCatalogOLTsInput>, CompanyUncheckedUpdateWithoutCatalogOLTsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProjectCreateWithoutUserInput = {
    id?: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    cables?: CableCreateNestedManyWithoutProjectInput
    ctos?: CtoCreateNestedManyWithoutProjectInput
    pops?: PopCreateNestedManyWithoutProjectInput
    poles?: PoleCreateNestedManyWithoutProjectInput
    company?: CompanyCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    cables?: CableUncheckedCreateNestedManyWithoutProjectInput
    ctos?: CtoUncheckedCreateNestedManyWithoutProjectInput
    pops?: PopUncheckedCreateNestedManyWithoutProjectInput
    poles?: PoleUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUserInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateManyUserInputEnvelope = {
    data: ProjectCreateManyUserInput | ProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity?: string
    entityId?: string
    details?: NullableJsonNullValueInput | InputJsonValue
    companyId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entity?: string
    entityId?: string
    details?: NullableJsonNullValueInput | InputJsonValue
    companyId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUserInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    centerLat?: FloatFilter<"Project"> | number
    centerLng?: FloatFilter<"Project"> | number
    zoom?: IntFilter<"Project"> | number
    settings?: JsonNullableFilter<"Project">
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    companyId?: StringNullableFilter<"Project"> | string | null
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    userId?: StringNullableFilter<"AuditLog"> | string | null
    companyId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type CableCreateWithoutCompanyInput = {
    id?: string
    name: string
    status?: string | null
    fiberCount: number
    looseTubeCount?: number | null
    color?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    fromNodeId?: string | null
    toNodeId?: string | null
    catalogId?: string | null
    project: ProjectCreateNestedOneWithoutCablesInput
  }

  export type CableUncheckedCreateWithoutCompanyInput = {
    id?: string
    projectId: string
    name: string
    status?: string | null
    fiberCount: number
    looseTubeCount?: number | null
    color?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    fromNodeId?: string | null
    toNodeId?: string | null
    catalogId?: string | null
  }

  export type CableCreateOrConnectWithoutCompanyInput = {
    where: CableWhereUniqueInput
    create: XOR<CableCreateWithoutCompanyInput, CableUncheckedCreateWithoutCompanyInput>
  }

  export type CableCreateManyCompanyInputEnvelope = {
    data: CableCreateManyCompanyInput | CableCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PlanCreateWithoutCompaniesInput = {
    id?: string
    name: string
    price?: number
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PlanUncheckedCreateWithoutCompaniesInput = {
    id?: string
    name: string
    price?: number
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PlanCreateOrConnectWithoutCompaniesInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutCompaniesInput, PlanUncheckedCreateWithoutCompaniesInput>
  }

  export type CtoCreateWithoutCompanyInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: number
    catalogId?: string | null
    type?: string | null
    color?: string | null
    reserveLoopLength?: number | null
    project: ProjectCreateNestedOneWithoutCtosInput
  }

  export type CtoUncheckedCreateWithoutCompanyInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: number
    catalogId?: string | null
    type?: string | null
    color?: string | null
    reserveLoopLength?: number | null
  }

  export type CtoCreateOrConnectWithoutCompanyInput = {
    where: CtoWhereUniqueInput
    create: XOR<CtoCreateWithoutCompanyInput, CtoUncheckedCreateWithoutCompanyInput>
  }

  export type CtoCreateManyCompanyInputEnvelope = {
    data: CtoCreateManyCompanyInput | CtoCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PopCreateWithoutCompanyInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    size?: number | null
    project: ProjectCreateNestedOneWithoutPopsInput
  }

  export type PopUncheckedCreateWithoutCompanyInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    size?: number | null
  }

  export type PopCreateOrConnectWithoutCompanyInput = {
    where: PopWhereUniqueInput
    create: XOR<PopCreateWithoutCompanyInput, PopUncheckedCreateWithoutCompanyInput>
  }

  export type PopCreateManyCompanyInputEnvelope = {
    data: PopCreateManyCompanyInput | PopCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCompanyInput = {
    id?: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    cables?: CableCreateNestedManyWithoutProjectInput
    ctos?: CtoCreateNestedManyWithoutProjectInput
    pops?: PopCreateNestedManyWithoutProjectInput
    poles?: PoleCreateNestedManyWithoutProjectInput
    user: UserCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    cables?: CableUncheckedCreateNestedManyWithoutProjectInput
    ctos?: CtoUncheckedCreateNestedManyWithoutProjectInput
    pops?: PopUncheckedCreateNestedManyWithoutProjectInput
    poles?: PoleUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCompanyInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCompanyInput, ProjectUncheckedCreateWithoutCompanyInput>
  }

  export type ProjectCreateManyCompanyInputEnvelope = {
    data: ProjectCreateManyCompanyInput | ProjectCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    username: string
    passwordHash: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    active?: boolean
    projects?: ProjectCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    username: string
    passwordHash: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    active?: boolean
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PoleCreateWithoutCompanyInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    project: ProjectCreateNestedOneWithoutPolesInput
    catalog?: CatalogPoleCreateNestedOneWithoutInstancesInput
  }

  export type PoleUncheckedCreateWithoutCompanyInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    catalogId?: string | null
  }

  export type PoleCreateOrConnectWithoutCompanyInput = {
    where: PoleWhereUniqueInput
    create: XOR<PoleCreateWithoutCompanyInput, PoleUncheckedCreateWithoutCompanyInput>
  }

  export type PoleCreateManyCompanyInputEnvelope = {
    data: PoleCreateManyCompanyInput | PoleCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CatalogCableCreateWithoutCompanyInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    defaultLevel?: string | null
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation?: number | null
    fiberProfile?: string | null
    description?: string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogCableUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    defaultLevel?: string | null
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation?: number | null
    fiberProfile?: string | null
    description?: string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogCableCreateOrConnectWithoutCompanyInput = {
    where: CatalogCableWhereUniqueInput
    create: XOR<CatalogCableCreateWithoutCompanyInput, CatalogCableUncheckedCreateWithoutCompanyInput>
  }

  export type CatalogCableCreateManyCompanyInputEnvelope = {
    data: CatalogCableCreateManyCompanyInput | CatalogCableCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CatalogBoxCreateWithoutCompanyInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    type: string
    reserveLoopLength?: number | null
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogBoxUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    type: string
    reserveLoopLength?: number | null
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogBoxCreateOrConnectWithoutCompanyInput = {
    where: CatalogBoxWhereUniqueInput
    create: XOR<CatalogBoxCreateWithoutCompanyInput, CatalogBoxUncheckedCreateWithoutCompanyInput>
  }

  export type CatalogBoxCreateManyCompanyInputEnvelope = {
    data: CatalogBoxCreateManyCompanyInput | CatalogBoxCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CatalogPoleCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: PoleCreateNestedManyWithoutCatalogInput
  }

  export type CatalogPoleUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: PoleUncheckedCreateNestedManyWithoutCatalogInput
  }

  export type CatalogPoleCreateOrConnectWithoutCompanyInput = {
    where: CatalogPoleWhereUniqueInput
    create: XOR<CatalogPoleCreateWithoutCompanyInput, CatalogPoleUncheckedCreateWithoutCompanyInput>
  }

  export type CatalogPoleCreateManyCompanyInputEnvelope = {
    data: CatalogPoleCreateManyCompanyInput | CatalogPoleCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CatalogSplitterCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: string
    mode: string
    inputs?: number
    outputs: number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogSplitterUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: string
    mode: string
    inputs?: number
    outputs: number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogSplitterCreateOrConnectWithoutCompanyInput = {
    where: CatalogSplitterWhereUniqueInput
    create: XOR<CatalogSplitterCreateWithoutCompanyInput, CatalogSplitterUncheckedCreateWithoutCompanyInput>
  }

  export type CatalogSplitterCreateManyCompanyInputEnvelope = {
    data: CatalogSplitterCreateManyCompanyInput | CatalogSplitterCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CatalogFusionCreateWithoutCompanyInput = {
    id?: string
    name: string
    attenuation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogFusionUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    attenuation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogFusionCreateOrConnectWithoutCompanyInput = {
    where: CatalogFusionWhereUniqueInput
    create: XOR<CatalogFusionCreateWithoutCompanyInput, CatalogFusionUncheckedCreateWithoutCompanyInput>
  }

  export type CatalogFusionCreateManyCompanyInputEnvelope = {
    data: CatalogFusionCreateManyCompanyInput | CatalogFusionCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CatalogOLTCreateWithoutCompanyInput = {
    id?: string
    name: string
    outputPower?: number
    slots?: number
    portsPerSlot?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogOLTUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    outputPower?: number
    slots?: number
    portsPerSlot?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogOLTCreateOrConnectWithoutCompanyInput = {
    where: CatalogOLTWhereUniqueInput
    create: XOR<CatalogOLTCreateWithoutCompanyInput, CatalogOLTUncheckedCreateWithoutCompanyInput>
  }

  export type CatalogOLTCreateManyCompanyInputEnvelope = {
    data: CatalogOLTCreateManyCompanyInput | CatalogOLTCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CableUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CableWhereUniqueInput
    update: XOR<CableUpdateWithoutCompanyInput, CableUncheckedUpdateWithoutCompanyInput>
    create: XOR<CableCreateWithoutCompanyInput, CableUncheckedCreateWithoutCompanyInput>
  }

  export type CableUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CableWhereUniqueInput
    data: XOR<CableUpdateWithoutCompanyInput, CableUncheckedUpdateWithoutCompanyInput>
  }

  export type CableUpdateManyWithWhereWithoutCompanyInput = {
    where: CableScalarWhereInput
    data: XOR<CableUpdateManyMutationInput, CableUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CableScalarWhereInput = {
    AND?: CableScalarWhereInput | CableScalarWhereInput[]
    OR?: CableScalarWhereInput[]
    NOT?: CableScalarWhereInput | CableScalarWhereInput[]
    id?: StringFilter<"Cable"> | string
    projectId?: StringFilter<"Cable"> | string
    name?: StringFilter<"Cable"> | string
    status?: StringNullableFilter<"Cable"> | string | null
    fiberCount?: IntFilter<"Cable"> | number
    looseTubeCount?: IntNullableFilter<"Cable"> | number | null
    color?: StringNullableFilter<"Cable"> | string | null
    coordinates?: JsonFilter<"Cable">
    fromNodeId?: StringNullableFilter<"Cable"> | string | null
    toNodeId?: StringNullableFilter<"Cable"> | string | null
    catalogId?: StringNullableFilter<"Cable"> | string | null
    companyId?: StringNullableFilter<"Cable"> | string | null
  }

  export type PlanUpsertWithoutCompaniesInput = {
    update: XOR<PlanUpdateWithoutCompaniesInput, PlanUncheckedUpdateWithoutCompaniesInput>
    create: XOR<PlanCreateWithoutCompaniesInput, PlanUncheckedCreateWithoutCompaniesInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutCompaniesInput, PlanUncheckedUpdateWithoutCompaniesInput>
  }

  export type PlanUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CtoUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CtoWhereUniqueInput
    update: XOR<CtoUpdateWithoutCompanyInput, CtoUncheckedUpdateWithoutCompanyInput>
    create: XOR<CtoCreateWithoutCompanyInput, CtoUncheckedCreateWithoutCompanyInput>
  }

  export type CtoUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CtoWhereUniqueInput
    data: XOR<CtoUpdateWithoutCompanyInput, CtoUncheckedUpdateWithoutCompanyInput>
  }

  export type CtoUpdateManyWithWhereWithoutCompanyInput = {
    where: CtoScalarWhereInput
    data: XOR<CtoUpdateManyMutationInput, CtoUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CtoScalarWhereInput = {
    AND?: CtoScalarWhereInput | CtoScalarWhereInput[]
    OR?: CtoScalarWhereInput[]
    NOT?: CtoScalarWhereInput | CtoScalarWhereInput[]
    id?: StringFilter<"Cto"> | string
    projectId?: StringFilter<"Cto"> | string
    name?: StringFilter<"Cto"> | string
    status?: EnumEquipmentStatusFilter<"Cto"> | $Enums.EquipmentStatus
    lat?: FloatFilter<"Cto"> | number
    lng?: FloatFilter<"Cto"> | number
    splitters?: JsonNullableFilter<"Cto">
    fusions?: JsonNullableFilter<"Cto">
    connections?: JsonNullableFilter<"Cto">
    inputCableIds?: StringNullableListFilter<"Cto">
    layout?: JsonNullableFilter<"Cto">
    clientCount?: IntFilter<"Cto"> | number
    catalogId?: StringNullableFilter<"Cto"> | string | null
    type?: StringNullableFilter<"Cto"> | string | null
    color?: StringNullableFilter<"Cto"> | string | null
    reserveLoopLength?: FloatNullableFilter<"Cto"> | number | null
    companyId?: StringNullableFilter<"Cto"> | string | null
  }

  export type PopUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PopWhereUniqueInput
    update: XOR<PopUpdateWithoutCompanyInput, PopUncheckedUpdateWithoutCompanyInput>
    create: XOR<PopCreateWithoutCompanyInput, PopUncheckedCreateWithoutCompanyInput>
  }

  export type PopUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PopWhereUniqueInput
    data: XOR<PopUpdateWithoutCompanyInput, PopUncheckedUpdateWithoutCompanyInput>
  }

  export type PopUpdateManyWithWhereWithoutCompanyInput = {
    where: PopScalarWhereInput
    data: XOR<PopUpdateManyMutationInput, PopUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PopScalarWhereInput = {
    AND?: PopScalarWhereInput | PopScalarWhereInput[]
    OR?: PopScalarWhereInput[]
    NOT?: PopScalarWhereInput | PopScalarWhereInput[]
    id?: StringFilter<"Pop"> | string
    projectId?: StringFilter<"Pop"> | string
    name?: StringFilter<"Pop"> | string
    status?: EnumEquipmentStatusFilter<"Pop"> | $Enums.EquipmentStatus
    lat?: FloatFilter<"Pop"> | number
    lng?: FloatFilter<"Pop"> | number
    olts?: JsonNullableFilter<"Pop">
    dios?: JsonNullableFilter<"Pop">
    fusions?: JsonNullableFilter<"Pop">
    connections?: JsonNullableFilter<"Pop">
    inputCableIds?: StringNullableListFilter<"Pop">
    layout?: JsonNullableFilter<"Pop">
    color?: StringNullableFilter<"Pop"> | string | null
    size?: IntNullableFilter<"Pop"> | number | null
    companyId?: StringNullableFilter<"Pop"> | string | null
  }

  export type ProjectUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCompanyInput, ProjectUncheckedUpdateWithoutCompanyInput>
    create: XOR<ProjectCreateWithoutCompanyInput, ProjectUncheckedCreateWithoutCompanyInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCompanyInput, ProjectUncheckedUpdateWithoutCompanyInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCompanyInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    companyId?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    active?: BoolFilter<"User"> | boolean
  }

  export type PoleUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PoleWhereUniqueInput
    update: XOR<PoleUpdateWithoutCompanyInput, PoleUncheckedUpdateWithoutCompanyInput>
    create: XOR<PoleCreateWithoutCompanyInput, PoleUncheckedCreateWithoutCompanyInput>
  }

  export type PoleUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PoleWhereUniqueInput
    data: XOR<PoleUpdateWithoutCompanyInput, PoleUncheckedUpdateWithoutCompanyInput>
  }

  export type PoleUpdateManyWithWhereWithoutCompanyInput = {
    where: PoleScalarWhereInput
    data: XOR<PoleUpdateManyMutationInput, PoleUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PoleScalarWhereInput = {
    AND?: PoleScalarWhereInput | PoleScalarWhereInput[]
    OR?: PoleScalarWhereInput[]
    NOT?: PoleScalarWhereInput | PoleScalarWhereInput[]
    id?: StringFilter<"Pole"> | string
    projectId?: StringFilter<"Pole"> | string
    name?: StringFilter<"Pole"> | string
    status?: EnumEquipmentStatusFilter<"Pole"> | $Enums.EquipmentStatus
    lat?: FloatFilter<"Pole"> | number
    lng?: FloatFilter<"Pole"> | number
    catalogId?: StringNullableFilter<"Pole"> | string | null
    companyId?: StringNullableFilter<"Pole"> | string | null
  }

  export type CatalogCableUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CatalogCableWhereUniqueInput
    update: XOR<CatalogCableUpdateWithoutCompanyInput, CatalogCableUncheckedUpdateWithoutCompanyInput>
    create: XOR<CatalogCableCreateWithoutCompanyInput, CatalogCableUncheckedCreateWithoutCompanyInput>
  }

  export type CatalogCableUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CatalogCableWhereUniqueInput
    data: XOR<CatalogCableUpdateWithoutCompanyInput, CatalogCableUncheckedUpdateWithoutCompanyInput>
  }

  export type CatalogCableUpdateManyWithWhereWithoutCompanyInput = {
    where: CatalogCableScalarWhereInput
    data: XOR<CatalogCableUpdateManyMutationInput, CatalogCableUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CatalogCableScalarWhereInput = {
    AND?: CatalogCableScalarWhereInput | CatalogCableScalarWhereInput[]
    OR?: CatalogCableScalarWhereInput[]
    NOT?: CatalogCableScalarWhereInput | CatalogCableScalarWhereInput[]
    id?: StringFilter<"CatalogCable"> | string
    name?: StringFilter<"CatalogCable"> | string
    brand?: StringNullableFilter<"CatalogCable"> | string | null
    model?: StringNullableFilter<"CatalogCable"> | string | null
    defaultLevel?: StringNullableFilter<"CatalogCable"> | string | null
    fiberCount?: IntFilter<"CatalogCable"> | number
    looseTubeCount?: IntFilter<"CatalogCable"> | number
    fibersPerTube?: IntFilter<"CatalogCable"> | number
    attenuation?: FloatNullableFilter<"CatalogCable"> | number | null
    fiberProfile?: StringNullableFilter<"CatalogCable"> | string | null
    description?: StringNullableFilter<"CatalogCable"> | string | null
    deployedSpec?: JsonNullableFilter<"CatalogCable">
    plannedSpec?: JsonNullableFilter<"CatalogCable">
    createdAt?: DateTimeFilter<"CatalogCable"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogCable"> | Date | string
    companyId?: StringNullableFilter<"CatalogCable"> | string | null
  }

  export type CatalogBoxUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CatalogBoxWhereUniqueInput
    update: XOR<CatalogBoxUpdateWithoutCompanyInput, CatalogBoxUncheckedUpdateWithoutCompanyInput>
    create: XOR<CatalogBoxCreateWithoutCompanyInput, CatalogBoxUncheckedCreateWithoutCompanyInput>
  }

  export type CatalogBoxUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CatalogBoxWhereUniqueInput
    data: XOR<CatalogBoxUpdateWithoutCompanyInput, CatalogBoxUncheckedUpdateWithoutCompanyInput>
  }

  export type CatalogBoxUpdateManyWithWhereWithoutCompanyInput = {
    where: CatalogBoxScalarWhereInput
    data: XOR<CatalogBoxUpdateManyMutationInput, CatalogBoxUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CatalogBoxScalarWhereInput = {
    AND?: CatalogBoxScalarWhereInput | CatalogBoxScalarWhereInput[]
    OR?: CatalogBoxScalarWhereInput[]
    NOT?: CatalogBoxScalarWhereInput | CatalogBoxScalarWhereInput[]
    id?: StringFilter<"CatalogBox"> | string
    name?: StringFilter<"CatalogBox"> | string
    brand?: StringNullableFilter<"CatalogBox"> | string | null
    model?: StringNullableFilter<"CatalogBox"> | string | null
    type?: StringFilter<"CatalogBox"> | string
    reserveLoopLength?: FloatNullableFilter<"CatalogBox"> | number | null
    color?: StringNullableFilter<"CatalogBox"> | string | null
    description?: StringNullableFilter<"CatalogBox"> | string | null
    createdAt?: DateTimeFilter<"CatalogBox"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogBox"> | Date | string
    companyId?: StringNullableFilter<"CatalogBox"> | string | null
  }

  export type CatalogPoleUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CatalogPoleWhereUniqueInput
    update: XOR<CatalogPoleUpdateWithoutCompanyInput, CatalogPoleUncheckedUpdateWithoutCompanyInput>
    create: XOR<CatalogPoleCreateWithoutCompanyInput, CatalogPoleUncheckedCreateWithoutCompanyInput>
  }

  export type CatalogPoleUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CatalogPoleWhereUniqueInput
    data: XOR<CatalogPoleUpdateWithoutCompanyInput, CatalogPoleUncheckedUpdateWithoutCompanyInput>
  }

  export type CatalogPoleUpdateManyWithWhereWithoutCompanyInput = {
    where: CatalogPoleScalarWhereInput
    data: XOR<CatalogPoleUpdateManyMutationInput, CatalogPoleUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CatalogPoleScalarWhereInput = {
    AND?: CatalogPoleScalarWhereInput | CatalogPoleScalarWhereInput[]
    OR?: CatalogPoleScalarWhereInput[]
    NOT?: CatalogPoleScalarWhereInput | CatalogPoleScalarWhereInput[]
    id?: StringFilter<"CatalogPole"> | string
    name?: StringFilter<"CatalogPole"> | string
    type?: StringFilter<"CatalogPole"> | string
    height?: FloatFilter<"CatalogPole"> | number
    strength?: FloatFilter<"CatalogPole"> | number
    shape?: StringFilter<"CatalogPole"> | string
    description?: StringNullableFilter<"CatalogPole"> | string | null
    createdAt?: DateTimeFilter<"CatalogPole"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogPole"> | Date | string
    companyId?: StringNullableFilter<"CatalogPole"> | string | null
  }

  export type CatalogSplitterUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CatalogSplitterWhereUniqueInput
    update: XOR<CatalogSplitterUpdateWithoutCompanyInput, CatalogSplitterUncheckedUpdateWithoutCompanyInput>
    create: XOR<CatalogSplitterCreateWithoutCompanyInput, CatalogSplitterUncheckedCreateWithoutCompanyInput>
  }

  export type CatalogSplitterUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CatalogSplitterWhereUniqueInput
    data: XOR<CatalogSplitterUpdateWithoutCompanyInput, CatalogSplitterUncheckedUpdateWithoutCompanyInput>
  }

  export type CatalogSplitterUpdateManyWithWhereWithoutCompanyInput = {
    where: CatalogSplitterScalarWhereInput
    data: XOR<CatalogSplitterUpdateManyMutationInput, CatalogSplitterUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CatalogSplitterScalarWhereInput = {
    AND?: CatalogSplitterScalarWhereInput | CatalogSplitterScalarWhereInput[]
    OR?: CatalogSplitterScalarWhereInput[]
    NOT?: CatalogSplitterScalarWhereInput | CatalogSplitterScalarWhereInput[]
    id?: StringFilter<"CatalogSplitter"> | string
    name?: StringFilter<"CatalogSplitter"> | string
    type?: StringFilter<"CatalogSplitter"> | string
    mode?: StringFilter<"CatalogSplitter"> | string
    inputs?: IntFilter<"CatalogSplitter"> | number
    outputs?: IntFilter<"CatalogSplitter"> | number
    attenuation?: JsonNullableFilter<"CatalogSplitter">
    description?: StringNullableFilter<"CatalogSplitter"> | string | null
    createdAt?: DateTimeFilter<"CatalogSplitter"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogSplitter"> | Date | string
    companyId?: StringNullableFilter<"CatalogSplitter"> | string | null
  }

  export type CatalogFusionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CatalogFusionWhereUniqueInput
    update: XOR<CatalogFusionUpdateWithoutCompanyInput, CatalogFusionUncheckedUpdateWithoutCompanyInput>
    create: XOR<CatalogFusionCreateWithoutCompanyInput, CatalogFusionUncheckedCreateWithoutCompanyInput>
  }

  export type CatalogFusionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CatalogFusionWhereUniqueInput
    data: XOR<CatalogFusionUpdateWithoutCompanyInput, CatalogFusionUncheckedUpdateWithoutCompanyInput>
  }

  export type CatalogFusionUpdateManyWithWhereWithoutCompanyInput = {
    where: CatalogFusionScalarWhereInput
    data: XOR<CatalogFusionUpdateManyMutationInput, CatalogFusionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CatalogFusionScalarWhereInput = {
    AND?: CatalogFusionScalarWhereInput | CatalogFusionScalarWhereInput[]
    OR?: CatalogFusionScalarWhereInput[]
    NOT?: CatalogFusionScalarWhereInput | CatalogFusionScalarWhereInput[]
    id?: StringFilter<"CatalogFusion"> | string
    name?: StringFilter<"CatalogFusion"> | string
    attenuation?: FloatFilter<"CatalogFusion"> | number
    createdAt?: DateTimeFilter<"CatalogFusion"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogFusion"> | Date | string
    companyId?: StringNullableFilter<"CatalogFusion"> | string | null
  }

  export type CatalogOLTUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CatalogOLTWhereUniqueInput
    update: XOR<CatalogOLTUpdateWithoutCompanyInput, CatalogOLTUncheckedUpdateWithoutCompanyInput>
    create: XOR<CatalogOLTCreateWithoutCompanyInput, CatalogOLTUncheckedCreateWithoutCompanyInput>
  }

  export type CatalogOLTUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CatalogOLTWhereUniqueInput
    data: XOR<CatalogOLTUpdateWithoutCompanyInput, CatalogOLTUncheckedUpdateWithoutCompanyInput>
  }

  export type CatalogOLTUpdateManyWithWhereWithoutCompanyInput = {
    where: CatalogOLTScalarWhereInput
    data: XOR<CatalogOLTUpdateManyMutationInput, CatalogOLTUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CatalogOLTScalarWhereInput = {
    AND?: CatalogOLTScalarWhereInput | CatalogOLTScalarWhereInput[]
    OR?: CatalogOLTScalarWhereInput[]
    NOT?: CatalogOLTScalarWhereInput | CatalogOLTScalarWhereInput[]
    id?: StringFilter<"CatalogOLT"> | string
    name?: StringFilter<"CatalogOLT"> | string
    outputPower?: FloatFilter<"CatalogOLT"> | number
    slots?: IntFilter<"CatalogOLT"> | number
    portsPerSlot?: IntFilter<"CatalogOLT"> | number
    description?: StringNullableFilter<"CatalogOLT"> | string | null
    createdAt?: DateTimeFilter<"CatalogOLT"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogOLT"> | Date | string
    companyId?: StringNullableFilter<"CatalogOLT"> | string | null
  }

  export type CompanyCreateWithoutPlanInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPlanInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPlanInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput>
  }

  export type CompanyCreateManyPlanInputEnvelope = {
    data: CompanyCreateManyPlanInput | CompanyCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithWhereUniqueWithoutPlanInput = {
    where: CompanyWhereUniqueInput
    update: XOR<CompanyUpdateWithoutPlanInput, CompanyUncheckedUpdateWithoutPlanInput>
    create: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput>
  }

  export type CompanyUpdateWithWhereUniqueWithoutPlanInput = {
    where: CompanyWhereUniqueInput
    data: XOR<CompanyUpdateWithoutPlanInput, CompanyUncheckedUpdateWithoutPlanInput>
  }

  export type CompanyUpdateManyWithWhereWithoutPlanInput = {
    where: CompanyScalarWhereInput
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyWithoutPlanInput>
  }

  export type CompanyScalarWhereInput = {
    AND?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    OR?: CompanyScalarWhereInput[]
    NOT?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    planId?: StringNullableFilter<"Company"> | string | null
    subscriptionExpiresAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    status?: StringFilter<"Company"> | string
  }

  export type CableCreateWithoutProjectInput = {
    id?: string
    name: string
    status?: string | null
    fiberCount: number
    looseTubeCount?: number | null
    color?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    fromNodeId?: string | null
    toNodeId?: string | null
    catalogId?: string | null
    company?: CompanyCreateNestedOneWithoutCablesInput
  }

  export type CableUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    status?: string | null
    fiberCount: number
    looseTubeCount?: number | null
    color?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    fromNodeId?: string | null
    toNodeId?: string | null
    catalogId?: string | null
    companyId?: string | null
  }

  export type CableCreateOrConnectWithoutProjectInput = {
    where: CableWhereUniqueInput
    create: XOR<CableCreateWithoutProjectInput, CableUncheckedCreateWithoutProjectInput>
  }

  export type CableCreateManyProjectInputEnvelope = {
    data: CableCreateManyProjectInput | CableCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CtoCreateWithoutProjectInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: number
    catalogId?: string | null
    type?: string | null
    color?: string | null
    reserveLoopLength?: number | null
    company?: CompanyCreateNestedOneWithoutCtosInput
  }

  export type CtoUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: number
    catalogId?: string | null
    type?: string | null
    color?: string | null
    reserveLoopLength?: number | null
    companyId?: string | null
  }

  export type CtoCreateOrConnectWithoutProjectInput = {
    where: CtoWhereUniqueInput
    create: XOR<CtoCreateWithoutProjectInput, CtoUncheckedCreateWithoutProjectInput>
  }

  export type CtoCreateManyProjectInputEnvelope = {
    data: CtoCreateManyProjectInput | CtoCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PopCreateWithoutProjectInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    size?: number | null
    company?: CompanyCreateNestedOneWithoutPopsInput
  }

  export type PopUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    size?: number | null
    companyId?: string | null
  }

  export type PopCreateOrConnectWithoutProjectInput = {
    where: PopWhereUniqueInput
    create: XOR<PopCreateWithoutProjectInput, PopUncheckedCreateWithoutProjectInput>
  }

  export type PopCreateManyProjectInputEnvelope = {
    data: PopCreateManyProjectInput | PopCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PoleCreateWithoutProjectInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    company?: CompanyCreateNestedOneWithoutPolesInput
    catalog?: CatalogPoleCreateNestedOneWithoutInstancesInput
  }

  export type PoleUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    catalogId?: string | null
    companyId?: string | null
  }

  export type PoleCreateOrConnectWithoutProjectInput = {
    where: PoleWhereUniqueInput
    create: XOR<PoleCreateWithoutProjectInput, PoleUncheckedCreateWithoutProjectInput>
  }

  export type PoleCreateManyProjectInputEnvelope = {
    data: PoleCreateManyProjectInput | PoleCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutProjectsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutProjectsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutProjectsInput, CompanyUncheckedCreateWithoutProjectsInput>
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    username: string
    passwordHash: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    active?: boolean
    company?: CompanyCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    username: string
    passwordHash: string
    createdAt?: Date | string
    companyId?: string | null
    role?: $Enums.UserRole
    active?: boolean
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type CableUpsertWithWhereUniqueWithoutProjectInput = {
    where: CableWhereUniqueInput
    update: XOR<CableUpdateWithoutProjectInput, CableUncheckedUpdateWithoutProjectInput>
    create: XOR<CableCreateWithoutProjectInput, CableUncheckedCreateWithoutProjectInput>
  }

  export type CableUpdateWithWhereUniqueWithoutProjectInput = {
    where: CableWhereUniqueInput
    data: XOR<CableUpdateWithoutProjectInput, CableUncheckedUpdateWithoutProjectInput>
  }

  export type CableUpdateManyWithWhereWithoutProjectInput = {
    where: CableScalarWhereInput
    data: XOR<CableUpdateManyMutationInput, CableUncheckedUpdateManyWithoutProjectInput>
  }

  export type CtoUpsertWithWhereUniqueWithoutProjectInput = {
    where: CtoWhereUniqueInput
    update: XOR<CtoUpdateWithoutProjectInput, CtoUncheckedUpdateWithoutProjectInput>
    create: XOR<CtoCreateWithoutProjectInput, CtoUncheckedCreateWithoutProjectInput>
  }

  export type CtoUpdateWithWhereUniqueWithoutProjectInput = {
    where: CtoWhereUniqueInput
    data: XOR<CtoUpdateWithoutProjectInput, CtoUncheckedUpdateWithoutProjectInput>
  }

  export type CtoUpdateManyWithWhereWithoutProjectInput = {
    where: CtoScalarWhereInput
    data: XOR<CtoUpdateManyMutationInput, CtoUncheckedUpdateManyWithoutProjectInput>
  }

  export type PopUpsertWithWhereUniqueWithoutProjectInput = {
    where: PopWhereUniqueInput
    update: XOR<PopUpdateWithoutProjectInput, PopUncheckedUpdateWithoutProjectInput>
    create: XOR<PopCreateWithoutProjectInput, PopUncheckedCreateWithoutProjectInput>
  }

  export type PopUpdateWithWhereUniqueWithoutProjectInput = {
    where: PopWhereUniqueInput
    data: XOR<PopUpdateWithoutProjectInput, PopUncheckedUpdateWithoutProjectInput>
  }

  export type PopUpdateManyWithWhereWithoutProjectInput = {
    where: PopScalarWhereInput
    data: XOR<PopUpdateManyMutationInput, PopUncheckedUpdateManyWithoutProjectInput>
  }

  export type PoleUpsertWithWhereUniqueWithoutProjectInput = {
    where: PoleWhereUniqueInput
    update: XOR<PoleUpdateWithoutProjectInput, PoleUncheckedUpdateWithoutProjectInput>
    create: XOR<PoleCreateWithoutProjectInput, PoleUncheckedCreateWithoutProjectInput>
  }

  export type PoleUpdateWithWhereUniqueWithoutProjectInput = {
    where: PoleWhereUniqueInput
    data: XOR<PoleUpdateWithoutProjectInput, PoleUncheckedUpdateWithoutProjectInput>
  }

  export type PoleUpdateManyWithWhereWithoutProjectInput = {
    where: PoleScalarWhereInput
    data: XOR<PoleUpdateManyMutationInput, PoleUncheckedUpdateManyWithoutProjectInput>
  }

  export type CompanyUpsertWithoutProjectsInput = {
    update: XOR<CompanyUpdateWithoutProjectsInput, CompanyUncheckedUpdateWithoutProjectsInput>
    create: XOR<CompanyCreateWithoutProjectsInput, CompanyUncheckedCreateWithoutProjectsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutProjectsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutProjectsInput, CompanyUncheckedUpdateWithoutProjectsInput>
  }

  export type CompanyUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    company?: CompanyUpdateOneWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutCtosInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCtosInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCtosInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCtosInput, CompanyUncheckedCreateWithoutCtosInput>
  }

  export type ProjectCreateWithoutCtosInput = {
    id?: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    cables?: CableCreateNestedManyWithoutProjectInput
    pops?: PopCreateNestedManyWithoutProjectInput
    poles?: PoleCreateNestedManyWithoutProjectInput
    company?: CompanyCreateNestedOneWithoutProjectsInput
    user: UserCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutCtosInput = {
    id?: string
    userId: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    cables?: CableUncheckedCreateNestedManyWithoutProjectInput
    pops?: PopUncheckedCreateNestedManyWithoutProjectInput
    poles?: PoleUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCtosInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCtosInput, ProjectUncheckedCreateWithoutCtosInput>
  }

  export type CompanyUpsertWithoutCtosInput = {
    update: XOR<CompanyUpdateWithoutCtosInput, CompanyUncheckedUpdateWithoutCtosInput>
    create: XOR<CompanyCreateWithoutCtosInput, CompanyUncheckedCreateWithoutCtosInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCtosInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCtosInput, CompanyUncheckedUpdateWithoutCtosInput>
  }

  export type CompanyUpdateWithoutCtosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCtosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProjectUpsertWithoutCtosInput = {
    update: XOR<ProjectUpdateWithoutCtosInput, ProjectUncheckedUpdateWithoutCtosInput>
    create: XOR<ProjectCreateWithoutCtosInput, ProjectUncheckedCreateWithoutCtosInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCtosInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCtosInput, ProjectUncheckedUpdateWithoutCtosInput>
  }

  export type ProjectUpdateWithoutCtosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cables?: CableUpdateManyWithoutProjectNestedInput
    pops?: PopUpdateManyWithoutProjectNestedInput
    poles?: PoleUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneWithoutProjectsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCtosInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    cables?: CableUncheckedUpdateManyWithoutProjectNestedInput
    pops?: PopUncheckedUpdateManyWithoutProjectNestedInput
    poles?: PoleUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CompanyCreateWithoutPopsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPopsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPopsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPopsInput, CompanyUncheckedCreateWithoutPopsInput>
  }

  export type ProjectCreateWithoutPopsInput = {
    id?: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    cables?: CableCreateNestedManyWithoutProjectInput
    ctos?: CtoCreateNestedManyWithoutProjectInput
    poles?: PoleCreateNestedManyWithoutProjectInput
    company?: CompanyCreateNestedOneWithoutProjectsInput
    user: UserCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutPopsInput = {
    id?: string
    userId: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    cables?: CableUncheckedCreateNestedManyWithoutProjectInput
    ctos?: CtoUncheckedCreateNestedManyWithoutProjectInput
    poles?: PoleUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPopsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPopsInput, ProjectUncheckedCreateWithoutPopsInput>
  }

  export type CompanyUpsertWithoutPopsInput = {
    update: XOR<CompanyUpdateWithoutPopsInput, CompanyUncheckedUpdateWithoutPopsInput>
    create: XOR<CompanyCreateWithoutPopsInput, CompanyUncheckedCreateWithoutPopsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPopsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPopsInput, CompanyUncheckedUpdateWithoutPopsInput>
  }

  export type CompanyUpdateWithoutPopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProjectUpsertWithoutPopsInput = {
    update: XOR<ProjectUpdateWithoutPopsInput, ProjectUncheckedUpdateWithoutPopsInput>
    create: XOR<ProjectCreateWithoutPopsInput, ProjectUncheckedCreateWithoutPopsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPopsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPopsInput, ProjectUncheckedUpdateWithoutPopsInput>
  }

  export type ProjectUpdateWithoutPopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cables?: CableUpdateManyWithoutProjectNestedInput
    ctos?: CtoUpdateManyWithoutProjectNestedInput
    poles?: PoleUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneWithoutProjectsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    cables?: CableUncheckedUpdateManyWithoutProjectNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutProjectNestedInput
    poles?: PoleUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CompanyCreateWithoutCablesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCablesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCablesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCablesInput, CompanyUncheckedCreateWithoutCablesInput>
  }

  export type ProjectCreateWithoutCablesInput = {
    id?: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ctos?: CtoCreateNestedManyWithoutProjectInput
    pops?: PopCreateNestedManyWithoutProjectInput
    poles?: PoleCreateNestedManyWithoutProjectInput
    company?: CompanyCreateNestedOneWithoutProjectsInput
    user: UserCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutCablesInput = {
    id?: string
    userId: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    ctos?: CtoUncheckedCreateNestedManyWithoutProjectInput
    pops?: PopUncheckedCreateNestedManyWithoutProjectInput
    poles?: PoleUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCablesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCablesInput, ProjectUncheckedCreateWithoutCablesInput>
  }

  export type CompanyUpsertWithoutCablesInput = {
    update: XOR<CompanyUpdateWithoutCablesInput, CompanyUncheckedUpdateWithoutCablesInput>
    create: XOR<CompanyCreateWithoutCablesInput, CompanyUncheckedCreateWithoutCablesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCablesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCablesInput, CompanyUncheckedUpdateWithoutCablesInput>
  }

  export type CompanyUpdateWithoutCablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProjectUpsertWithoutCablesInput = {
    update: XOR<ProjectUpdateWithoutCablesInput, ProjectUncheckedUpdateWithoutCablesInput>
    create: XOR<ProjectCreateWithoutCablesInput, ProjectUncheckedCreateWithoutCablesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCablesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCablesInput, ProjectUncheckedUpdateWithoutCablesInput>
  }

  export type ProjectUpdateWithoutCablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ctos?: CtoUpdateManyWithoutProjectNestedInput
    pops?: PopUpdateManyWithoutProjectNestedInput
    poles?: PoleUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneWithoutProjectsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ctos?: CtoUncheckedUpdateManyWithoutProjectNestedInput
    pops?: PopUncheckedUpdateManyWithoutProjectNestedInput
    poles?: PoleUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    username: string
    passwordHash: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    active?: boolean
    projects?: ProjectCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    username: string
    passwordHash: string
    createdAt?: Date | string
    companyId?: string | null
    role?: $Enums.UserRole
    active?: boolean
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    projects?: ProjectUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutCatalogSplittersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCatalogSplittersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCatalogSplittersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCatalogSplittersInput, CompanyUncheckedCreateWithoutCatalogSplittersInput>
  }

  export type CompanyUpsertWithoutCatalogSplittersInput = {
    update: XOR<CompanyUpdateWithoutCatalogSplittersInput, CompanyUncheckedUpdateWithoutCatalogSplittersInput>
    create: XOR<CompanyCreateWithoutCatalogSplittersInput, CompanyUncheckedCreateWithoutCatalogSplittersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCatalogSplittersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCatalogSplittersInput, CompanyUncheckedUpdateWithoutCatalogSplittersInput>
  }

  export type CompanyUpdateWithoutCatalogSplittersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCatalogSplittersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutCatalogCablesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCatalogCablesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCatalogCablesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCatalogCablesInput, CompanyUncheckedCreateWithoutCatalogCablesInput>
  }

  export type CompanyUpsertWithoutCatalogCablesInput = {
    update: XOR<CompanyUpdateWithoutCatalogCablesInput, CompanyUncheckedUpdateWithoutCatalogCablesInput>
    create: XOR<CompanyCreateWithoutCatalogCablesInput, CompanyUncheckedCreateWithoutCatalogCablesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCatalogCablesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCatalogCablesInput, CompanyUncheckedUpdateWithoutCatalogCablesInput>
  }

  export type CompanyUpdateWithoutCatalogCablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCatalogCablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutCatalogBoxesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCatalogBoxesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCatalogBoxesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCatalogBoxesInput, CompanyUncheckedCreateWithoutCatalogBoxesInput>
  }

  export type CompanyUpsertWithoutCatalogBoxesInput = {
    update: XOR<CompanyUpdateWithoutCatalogBoxesInput, CompanyUncheckedUpdateWithoutCatalogBoxesInput>
    create: XOR<CompanyCreateWithoutCatalogBoxesInput, CompanyUncheckedCreateWithoutCatalogBoxesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCatalogBoxesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCatalogBoxesInput, CompanyUncheckedUpdateWithoutCatalogBoxesInput>
  }

  export type CompanyUpdateWithoutCatalogBoxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCatalogBoxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PoleCreateWithoutCatalogInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    company?: CompanyCreateNestedOneWithoutPolesInput
    project: ProjectCreateNestedOneWithoutPolesInput
  }

  export type PoleUncheckedCreateWithoutCatalogInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    companyId?: string | null
  }

  export type PoleCreateOrConnectWithoutCatalogInput = {
    where: PoleWhereUniqueInput
    create: XOR<PoleCreateWithoutCatalogInput, PoleUncheckedCreateWithoutCatalogInput>
  }

  export type PoleCreateManyCatalogInputEnvelope = {
    data: PoleCreateManyCatalogInput | PoleCreateManyCatalogInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutCatalogPolesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCatalogPolesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCatalogPolesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCatalogPolesInput, CompanyUncheckedCreateWithoutCatalogPolesInput>
  }

  export type PoleUpsertWithWhereUniqueWithoutCatalogInput = {
    where: PoleWhereUniqueInput
    update: XOR<PoleUpdateWithoutCatalogInput, PoleUncheckedUpdateWithoutCatalogInput>
    create: XOR<PoleCreateWithoutCatalogInput, PoleUncheckedCreateWithoutCatalogInput>
  }

  export type PoleUpdateWithWhereUniqueWithoutCatalogInput = {
    where: PoleWhereUniqueInput
    data: XOR<PoleUpdateWithoutCatalogInput, PoleUncheckedUpdateWithoutCatalogInput>
  }

  export type PoleUpdateManyWithWhereWithoutCatalogInput = {
    where: PoleScalarWhereInput
    data: XOR<PoleUpdateManyMutationInput, PoleUncheckedUpdateManyWithoutCatalogInput>
  }

  export type CompanyUpsertWithoutCatalogPolesInput = {
    update: XOR<CompanyUpdateWithoutCatalogPolesInput, CompanyUncheckedUpdateWithoutCatalogPolesInput>
    create: XOR<CompanyCreateWithoutCatalogPolesInput, CompanyUncheckedCreateWithoutCatalogPolesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCatalogPolesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCatalogPolesInput, CompanyUncheckedUpdateWithoutCatalogPolesInput>
  }

  export type CompanyUpdateWithoutCatalogPolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCatalogPolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutPolesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPolesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPolesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPolesInput, CompanyUncheckedCreateWithoutPolesInput>
  }

  export type ProjectCreateWithoutPolesInput = {
    id?: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    cables?: CableCreateNestedManyWithoutProjectInput
    ctos?: CtoCreateNestedManyWithoutProjectInput
    pops?: PopCreateNestedManyWithoutProjectInput
    company?: CompanyCreateNestedOneWithoutProjectsInput
    user: UserCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutPolesInput = {
    id?: string
    userId: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    cables?: CableUncheckedCreateNestedManyWithoutProjectInput
    ctos?: CtoUncheckedCreateNestedManyWithoutProjectInput
    pops?: PopUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPolesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPolesInput, ProjectUncheckedCreateWithoutPolesInput>
  }

  export type CatalogPoleCreateWithoutInstancesInput = {
    id?: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutCatalogPolesInput
  }

  export type CatalogPoleUncheckedCreateWithoutInstancesInput = {
    id?: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type CatalogPoleCreateOrConnectWithoutInstancesInput = {
    where: CatalogPoleWhereUniqueInput
    create: XOR<CatalogPoleCreateWithoutInstancesInput, CatalogPoleUncheckedCreateWithoutInstancesInput>
  }

  export type CompanyUpsertWithoutPolesInput = {
    update: XOR<CompanyUpdateWithoutPolesInput, CompanyUncheckedUpdateWithoutPolesInput>
    create: XOR<CompanyCreateWithoutPolesInput, CompanyUncheckedCreateWithoutPolesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPolesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPolesInput, CompanyUncheckedUpdateWithoutPolesInput>
  }

  export type CompanyUpdateWithoutPolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProjectUpsertWithoutPolesInput = {
    update: XOR<ProjectUpdateWithoutPolesInput, ProjectUncheckedUpdateWithoutPolesInput>
    create: XOR<ProjectCreateWithoutPolesInput, ProjectUncheckedCreateWithoutPolesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPolesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPolesInput, ProjectUncheckedUpdateWithoutPolesInput>
  }

  export type ProjectUpdateWithoutPolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cables?: CableUpdateManyWithoutProjectNestedInput
    ctos?: CtoUpdateManyWithoutProjectNestedInput
    pops?: PopUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneWithoutProjectsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    cables?: CableUncheckedUpdateManyWithoutProjectNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutProjectNestedInput
    pops?: PopUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CatalogPoleUpsertWithoutInstancesInput = {
    update: XOR<CatalogPoleUpdateWithoutInstancesInput, CatalogPoleUncheckedUpdateWithoutInstancesInput>
    create: XOR<CatalogPoleCreateWithoutInstancesInput, CatalogPoleUncheckedCreateWithoutInstancesInput>
    where?: CatalogPoleWhereInput
  }

  export type CatalogPoleUpdateToOneWithWhereWithoutInstancesInput = {
    where?: CatalogPoleWhereInput
    data: XOR<CatalogPoleUpdateWithoutInstancesInput, CatalogPoleUncheckedUpdateWithoutInstancesInput>
  }

  export type CatalogPoleUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutCatalogPolesNestedInput
  }

  export type CatalogPoleUncheckedUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyCreateWithoutCatalogFusionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCatalogFusionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogOLTs?: CatalogOLTUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCatalogFusionsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCatalogFusionsInput, CompanyUncheckedCreateWithoutCatalogFusionsInput>
  }

  export type CompanyUpsertWithoutCatalogFusionsInput = {
    update: XOR<CompanyUpdateWithoutCatalogFusionsInput, CompanyUncheckedUpdateWithoutCatalogFusionsInput>
    create: XOR<CompanyCreateWithoutCatalogFusionsInput, CompanyUncheckedCreateWithoutCatalogFusionsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCatalogFusionsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCatalogFusionsInput, CompanyUncheckedUpdateWithoutCatalogFusionsInput>
  }

  export type CompanyUpdateWithoutCatalogFusionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCatalogFusionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutCatalogOLTsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableCreateNestedManyWithoutCompanyInput
    plan?: PlanCreateNestedOneWithoutCompaniesInput
    ctos?: CtoCreateNestedManyWithoutCompanyInput
    pops?: PopCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    poles?: PoleCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCatalogOLTsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    planId?: string | null
    subscriptionExpiresAt?: Date | string | null
    status?: string
    cables?: CableUncheckedCreateNestedManyWithoutCompanyInput
    ctos?: CtoUncheckedCreateNestedManyWithoutCompanyInput
    pops?: PopUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    poles?: PoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogCables?: CatalogCableUncheckedCreateNestedManyWithoutCompanyInput
    catalogBoxes?: CatalogBoxUncheckedCreateNestedManyWithoutCompanyInput
    catalogPoles?: CatalogPoleUncheckedCreateNestedManyWithoutCompanyInput
    catalogSplitters?: CatalogSplitterUncheckedCreateNestedManyWithoutCompanyInput
    catalogFusions?: CatalogFusionUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCatalogOLTsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCatalogOLTsInput, CompanyUncheckedCreateWithoutCatalogOLTsInput>
  }

  export type CompanyUpsertWithoutCatalogOLTsInput = {
    update: XOR<CompanyUpdateWithoutCatalogOLTsInput, CompanyUncheckedUpdateWithoutCatalogOLTsInput>
    create: XOR<CompanyCreateWithoutCatalogOLTsInput, CompanyUncheckedCreateWithoutCatalogOLTsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCatalogOLTsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCatalogOLTsInput, CompanyUncheckedUpdateWithoutCatalogOLTsInput>
  }

  export type CompanyUpdateWithoutCatalogOLTsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneWithoutCompaniesNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCatalogOLTsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProjectCreateManyUserInput = {
    id?: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entity?: string
    entityId?: string
    details?: NullableJsonNullValueInput | InputJsonValue
    companyId?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type ProjectUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cables?: CableUpdateManyWithoutProjectNestedInput
    ctos?: CtoUpdateManyWithoutProjectNestedInput
    pops?: PopUpdateManyWithoutProjectNestedInput
    poles?: PoleUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    cables?: CableUncheckedUpdateManyWithoutProjectNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutProjectNestedInput
    pops?: PopUncheckedUpdateManyWithoutProjectNestedInput
    poles?: PoleUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CableCreateManyCompanyInput = {
    id?: string
    projectId: string
    name: string
    status?: string | null
    fiberCount: number
    looseTubeCount?: number | null
    color?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    fromNodeId?: string | null
    toNodeId?: string | null
    catalogId?: string | null
  }

  export type CtoCreateManyCompanyInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: number
    catalogId?: string | null
    type?: string | null
    color?: string | null
    reserveLoopLength?: number | null
  }

  export type PopCreateManyCompanyInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    size?: number | null
  }

  export type ProjectCreateManyCompanyInput = {
    id?: string
    userId: string
    name: string
    centerLat: number
    centerLng: number
    zoom?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    username: string
    passwordHash: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    active?: boolean
  }

  export type PoleCreateManyCompanyInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    catalogId?: string | null
  }

  export type CatalogCableCreateManyCompanyInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    defaultLevel?: string | null
    fiberCount: number
    looseTubeCount: number
    fibersPerTube: number
    attenuation?: number | null
    fiberProfile?: string | null
    description?: string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogBoxCreateManyCompanyInput = {
    id?: string
    name: string
    brand?: string | null
    model?: string | null
    type: string
    reserveLoopLength?: number | null
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogPoleCreateManyCompanyInput = {
    id?: string
    name: string
    type: string
    height: number
    strength: number
    shape: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogSplitterCreateManyCompanyInput = {
    id?: string
    name: string
    type: string
    mode: string
    inputs?: number
    outputs: number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogFusionCreateManyCompanyInput = {
    id?: string
    name: string
    attenuation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogOLTCreateManyCompanyInput = {
    id?: string
    name: string
    outputPower?: number
    slots?: number
    portsPerSlot?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CableUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    fromNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutCablesNestedInput
  }

  export type CableUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    fromNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CableUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    fromNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CtoUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: IntFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    project?: ProjectUpdateOneRequiredWithoutCtosNestedInput
  }

  export type CtoUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: IntFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CtoUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: IntFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PopUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    project?: ProjectUpdateOneRequiredWithoutPopsNestedInput
  }

  export type PopUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PopUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cables?: CableUpdateManyWithoutProjectNestedInput
    ctos?: CtoUpdateManyWithoutProjectNestedInput
    pops?: PopUpdateManyWithoutProjectNestedInput
    poles?: PoleUpdateManyWithoutProjectNestedInput
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cables?: CableUncheckedUpdateManyWithoutProjectNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutProjectNestedInput
    pops?: PopUncheckedUpdateManyWithoutProjectNestedInput
    poles?: PoleUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    centerLat?: FloatFieldUpdateOperationsInput | number
    centerLng?: FloatFieldUpdateOperationsInput | number
    zoom?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    projects?: ProjectUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PoleUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutPolesNestedInput
    catalog?: CatalogPoleUpdateOneWithoutInstancesNestedInput
  }

  export type PoleUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PoleUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogCableUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    defaultLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: IntFieldUpdateOperationsInput | number
    fibersPerTube?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableFloatFieldUpdateOperationsInput | number | null
    fiberProfile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCableUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    defaultLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: IntFieldUpdateOperationsInput | number
    fibersPerTube?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableFloatFieldUpdateOperationsInput | number | null
    fiberProfile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCableUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    defaultLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: IntFieldUpdateOperationsInput | number
    fibersPerTube?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableFloatFieldUpdateOperationsInput | number | null
    fiberProfile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deployedSpec?: NullableJsonNullValueInput | InputJsonValue
    plannedSpec?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogBoxUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogBoxUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogBoxUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogPoleUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: PoleUpdateManyWithoutCatalogNestedInput
  }

  export type CatalogPoleUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: PoleUncheckedUpdateManyWithoutCatalogNestedInput
  }

  export type CatalogPoleUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    strength?: FloatFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogSplitterUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    inputs?: IntFieldUpdateOperationsInput | number
    outputs?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogSplitterUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    inputs?: IntFieldUpdateOperationsInput | number
    outputs?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogSplitterUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    inputs?: IntFieldUpdateOperationsInput | number
    outputs?: IntFieldUpdateOperationsInput | number
    attenuation?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogFusionUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attenuation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogFusionUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attenuation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogFusionUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attenuation?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogOLTUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    outputPower?: FloatFieldUpdateOperationsInput | number
    slots?: IntFieldUpdateOperationsInput | number
    portsPerSlot?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogOLTUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    outputPower?: FloatFieldUpdateOperationsInput | number
    slots?: IntFieldUpdateOperationsInput | number
    portsPerSlot?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogOLTUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    outputPower?: FloatFieldUpdateOperationsInput | number
    slots?: IntFieldUpdateOperationsInput | number
    portsPerSlot?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateManyPlanInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionExpiresAt?: Date | string | null
    status?: string
  }

  export type CompanyUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUpdateManyWithoutCompanyNestedInput
    pops?: PopUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    poles?: PoleUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    cables?: CableUncheckedUpdateManyWithoutCompanyNestedInput
    ctos?: CtoUncheckedUpdateManyWithoutCompanyNestedInput
    pops?: PopUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    poles?: PoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogCables?: CatalogCableUncheckedUpdateManyWithoutCompanyNestedInput
    catalogBoxes?: CatalogBoxUncheckedUpdateManyWithoutCompanyNestedInput
    catalogPoles?: CatalogPoleUncheckedUpdateManyWithoutCompanyNestedInput
    catalogSplitters?: CatalogSplitterUncheckedUpdateManyWithoutCompanyNestedInput
    catalogFusions?: CatalogFusionUncheckedUpdateManyWithoutCompanyNestedInput
    catalogOLTs?: CatalogOLTUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CableCreateManyProjectInput = {
    id?: string
    name: string
    status?: string | null
    fiberCount: number
    looseTubeCount?: number | null
    color?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    fromNodeId?: string | null
    toNodeId?: string | null
    catalogId?: string | null
    companyId?: string | null
  }

  export type CtoCreateManyProjectInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: number
    catalogId?: string | null
    type?: string | null
    color?: string | null
    reserveLoopLength?: number | null
    companyId?: string | null
  }

  export type PopCreateManyProjectInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopCreateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    size?: number | null
    companyId?: string | null
  }

  export type PoleCreateManyProjectInput = {
    id?: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    catalogId?: string | null
    companyId?: string | null
  }

  export type CableUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    fromNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutCablesNestedInput
  }

  export type CableUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    fromNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CableUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    fiberCount?: IntFieldUpdateOperationsInput | number
    looseTubeCount?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    fromNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    toNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CtoUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: IntFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneWithoutCtosNestedInput
  }

  export type CtoUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: IntFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CtoUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    splitters?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: CtoUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    clientCount?: IntFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    reserveLoopLength?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PopUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneWithoutPopsNestedInput
  }

  export type PopUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PopUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    olts?: NullableJsonNullValueInput | InputJsonValue
    dios?: NullableJsonNullValueInput | InputJsonValue
    fusions?: NullableJsonNullValueInput | InputJsonValue
    connections?: NullableJsonNullValueInput | InputJsonValue
    inputCableIds?: PopUpdateinputCableIdsInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PoleUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    company?: CompanyUpdateOneWithoutPolesNestedInput
    catalog?: CatalogPoleUpdateOneWithoutInstancesNestedInput
  }

  export type PoleUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PoleUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    catalogId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PoleCreateManyCatalogInput = {
    id?: string
    projectId: string
    name: string
    status?: $Enums.EquipmentStatus
    lat: number
    lng: number
    companyId?: string | null
  }

  export type PoleUpdateWithoutCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    company?: CompanyUpdateOneWithoutPolesNestedInput
    project?: ProjectUpdateOneRequiredWithoutPolesNestedInput
  }

  export type PoleUncheckedUpdateWithoutCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PoleUncheckedUpdateManyWithoutCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanCountOutputTypeDefaultArgs instead
     */
    export type PlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogPoleCountOutputTypeDefaultArgs instead
     */
    export type CatalogPoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogPoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanDefaultArgs instead
     */
    export type PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CtoDefaultArgs instead
     */
    export type CtoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CtoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PopDefaultArgs instead
     */
    export type PopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PopDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CableDefaultArgs instead
     */
    export type CableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogSplitterDefaultArgs instead
     */
    export type CatalogSplitterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogSplitterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateSplitterDefaultArgs instead
     */
    export type TemplateSplitterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateSplitterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogCableDefaultArgs instead
     */
    export type CatalogCableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogCableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateCableDefaultArgs instead
     */
    export type TemplateCableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateCableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogBoxDefaultArgs instead
     */
    export type CatalogBoxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogBoxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateBoxDefaultArgs instead
     */
    export type TemplateBoxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateBoxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogPoleDefaultArgs instead
     */
    export type CatalogPoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogPoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplatePoleDefaultArgs instead
     */
    export type TemplatePoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplatePoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PoleDefaultArgs instead
     */
    export type PoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogFusionDefaultArgs instead
     */
    export type CatalogFusionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogFusionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateFusionDefaultArgs instead
     */
    export type TemplateFusionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateFusionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogOLTDefaultArgs instead
     */
    export type CatalogOLTArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogOLTDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateOLTDefaultArgs instead
     */
    export type TemplateOLTArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateOLTDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}